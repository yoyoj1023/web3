# 模組五：手算演練

## 📚 學習目標

完成本模組後，您將能夠：
- ✅ 親手計算完整的 ECDSA 公鑰生成過程
- ✅ 親手計算完整的 ECDSA 簽署過程
- ✅ 親手計算完整的 ECDSA 驗證過程
- ✅ 深刻理解每個運算步驟的數學意義
- ✅ 能夠識別和解決計算中的問題

**預計學習時間：** 4-6 小時

**重要提示：** 手算過程雖然繁瑣，但對於真正理解 ECDSA 的運作原理至關重要。請耐心完成每個步驟！

---

## 1. 為什麼要手算？

###  1.1 手算的重要性

```
"我聽過了，我忘記了
 我看過了，我記住了
 我做過了，我理解了"
    — 中國諺語
```

**手算的好處：**
```
✓ 深刻理解
  - 不只是知道公式，而是理解「為什麼」
  - 每個步驟的數學意義變得清晰

✓ 記憶持久
  - 親手計算過的知識不容易忘記
  - 建立直覺和肌肉記憶

✓ 除錯能力
  - 知道哪裡可能出錯
  - 能夠識別實現中的問題

✓ 面試準備
  - 許多技術面試要求手算密碼學問題
  - 展示深度理解

✓ 建立信心
  - 完整走過一遍流程
  - 不再是黑盒子
```

### 1.2 學習策略

**第一次：跟著詳細步驟走**
```
- 仔細閱讀每個步驟
- 驗證每個中間結果
- 理解每個公式的意義
- 不要跳過任何步驟
```

**第二次：自己獨立計算**
```
- 只看問題，不看解答
- 嘗試自己完成
- 遇到困難時才參考解答
- 對比自己的答案
```

**第三次：變換參數**
```
- 使用不同的私鑰
- 使用不同的訊息
- 觀察結果如何變化
- 建立更深的理解
```

---

## 2. 課程參數設定

為了讓手算可行，我們使用一個小的橢圓曲線：

### 2.1 曲線參數

```
橢圓曲線 E：y² ≡ x³ + 2x + 2 (mod 17)

參數：
p = 17      （有限體的模數，質數）
a = 2       （曲線係數）
b = 2       （曲線係數）

基準點 G = (5, 1)

階數 n = 19  （G 的階數，19 × G = 𝒪）
```

### 2.2 驗證曲線有效性

**檢查 1：p 是質數**
```
p = 17
17 只能被 1 和 17 整除
✓ 17 是質數
```

**檢查 2：曲線無奇點**
```
判別式 Δ = 4a³ + 27b² ≠ 0 (mod p)

Δ = 4×2³ + 27×2²
  = 4×8 + 27×4
  = 32 + 108
  = 140
  = 140 mod 17
  = 140 - 8×17
  = 140 - 136
  = 4

Δ = 4 ≠ 0 (mod 17) ✓

曲線沒有奇點，是有效的
```

**檢查 3：G 在曲線上**
```
G = (5, 1)
檢查：y² ≡ x³ + ax + b (mod p)

左邊：y² = 1² = 1

右邊：x³ + ax + b
     = 5³ + 2×5 + 2
     = 125 + 10 + 2
     = 137
     = 137 mod 17
     = 137 - 8×17
     = 137 - 136
     = 1

左邊 = 右邊 = 1 ✓

G 確實在曲線上
```

**檢查 4：n × G = 𝒪**
```
我們聲稱 19 × G = 𝒪（無窮遠點）

這個我們在後面計算公鑰時會順便驗證
```

### 2.3 曲線上的點

完整的點集合（供參考）：

```
橢圓曲線 E 上的點（mod 17）：

(0, 6), (0, 11)
(3, 1), (3, 16)
(5, 1), (5, 16)
(6, 3), (6, 14)
(9, 1), (9, 16)
(10, 6), (10, 11)
(13, 7), (13, 10)
(16, 4), (16, 13)
𝒪（無窮遠點）

總共：18 個點 + 𝒪 = 19 個元素

這就是為什麼 n = 19
```

---

## 3. 演練一：公鑰生成

### 3.1 問題設定

```
給定：
- 曲線 E：y² ≡ x³ + 2x + 2 (mod 17)
- 基準點 G = (5, 1)
- 私鑰 d = 6

求：公鑰 Q = d × G = 6 × G
```

### 3.2 計算策略

**方法 1：逐步加法（適合初學者）**
```
6 × G = G + G + G + G + G + G
      = 2G + 2G + 2G
      = 3G + 3G
```

**方法 2：雙倍加法（更高效）**
```
6 = 110₂（二進制）
6 × G = 4×G + 2×G

計算順序：
G → 2G → 3G → 6G
或
G → 2G → 4G → 6G
```

我們使用方法 1（更直觀）

### 3.3 詳細計算步驟

#### 步驟 1：計算 2G = G + G

**使用點加倍公式**（P + P 其中 P = (x₁, y₁)）：

```
斜率公式：
λ = (3x₁² + a) / (2y₁) mod p

其中：
x₁ = 5, y₁ = 1, a = 2, p = 17

計算分子：
3x₁² + a = 3×5² + 2
         = 3×25 + 2
         = 75 + 2
         = 77

計算分母：
2y₁ = 2×1 = 2

現在需要計算：λ = 77 / 2 mod 17
```

**模除法 = 乘以模反元素**

```
需要找到 2⁻¹ mod 17

方法：找到 x 使得 2x ≡ 1 (mod 17)

嘗試：
2×1 = 2 ≢ 1 (mod 17)
2×2 = 4 ≢ 1 (mod 17)
...
2×9 = 18 = 17 + 1 ≡ 1 (mod 17) ✓

所以 2⁻¹ = 9 mod 17
```

**繼續計算斜率：**

```
λ = 77 × 9 mod 17
  = 693 mod 17

693 ÷ 17 = 40 餘 13
693 = 40×17 + 13

λ = 13
```

**計算新點的座標：**

```
x₃ = λ² - 2x₁ mod p
   = 13² - 2×5 mod 17
   = 169 - 10 mod 17
   = 159 mod 17

159 ÷ 17 = 9 餘 6
159 = 9×17 + 6

x₃ = 6
```

```
y₃ = λ(x₁ - x₃) - y₁ mod p
   = 13(5 - 6) - 1 mod 17
   = 13×(-1) - 1 mod 17
   = -13 - 1 mod 17
   = -14 mod 17
   = -14 + 17 mod 17
   = 3

y₃ = 3
```

**驗證結果：**

```
2G = (6, 3)

檢查是否在曲線上：
y² = 3² = 9
x³ + 2x + 2 = 6³ + 2×6 + 2 = 216 + 12 + 2 = 230

230 mod 17 = 230 - 13×17 = 230 - 221 = 9 ✓

確認：2G = (6, 3)
```

---

#### 步驟 2：計算 3G = 2G + G

**使用點加法公式**（P + Q 其中 P ≠ Q）：

```
P = 2G = (6, 3)
Q = G = (5, 1)

斜率公式：
λ = (y₂ - y₁) / (x₂ - x₁) mod p

其中：
(x₁, y₁) = (6, 3)
(x₂, y₂) = (5, 1)

計算分子：
y₂ - y₁ = 1 - 3 = -2

計算分母：
x₂ - x₁ = 5 - 6 = -1

λ = -2 / -1 mod 17
  = 2 mod 17

λ = 2
```

**計算新點的座標：**

```
x₃ = λ² - x₁ - x₂ mod p
   = 2² - 6 - 5 mod 17
   = 4 - 11 mod 17
   = -7 mod 17
   = -7 + 17
   = 10

x₃ = 10
```

```
y₃ = λ(x₁ - x₃) - y₁ mod p
   = 2(6 - 10) - 3 mod 17
   = 2×(-4) - 3 mod 17
   = -8 - 3 mod 17
   = -11 mod 17
   = -11 + 17
   = 6

y₃ = 6
```

**驗證結果：**

```
3G = (10, 6)

檢查是否在曲線上：
y² = 6² = 36 = 36 - 2×17 = 2
x³ + 2x + 2 = 10³ + 2×10 + 2 = 1000 + 20 + 2 = 1022

1022 mod 17 = 1022 - 60×17 = 1022 - 1020 = 2 ✓

確認：3G = (10, 6)
```

---

#### 步驟 3：計算 6G = 3G + 3G

**使用點加倍公式**（P + P）：

```
P = 3G = (10, 6)

斜率公式：
λ = (3x₁² + a) / (2y₁) mod p

計算分子：
3x₁² + a = 3×10² + 2
         = 3×100 + 2
         = 302

302 mod 17 = 302 - 17×17 = 302 - 289 = 13

分子 = 13

計算分母：
2y₁ = 2×6 = 12

λ = 13 / 12 mod 17
```

**求 12⁻¹ mod 17：**

```
需要找到 x 使得 12x ≡ 1 (mod 17)

使用擴展歐幾里得算法：
17 = 1×12 + 5
12 = 2×5 + 2
5 = 2×2 + 1
2 = 2×1 + 0

回代：
1 = 5 - 2×2
1 = 5 - 2×(12 - 2×5)
1 = 5 - 2×12 + 4×5
1 = 5×5 - 2×12
1 = 5×(17 - 12) - 2×12
1 = 5×17 - 5×12 - 2×12
1 = 5×17 - 7×12

所以：-7×12 ≡ 1 (mod 17)
      (-7)×12 ≡ 1 (mod 17)
      10×12 ≡ 1 (mod 17)  [因為 -7 ≡ 10 (mod 17)]

驗證：10×12 = 120 = 7×17 + 1 ≡ 1 (mod 17) ✓

12⁻¹ = 10 mod 17
```

**繼續計算斜率：**

```
λ = 13 × 10 mod 17
  = 130 mod 17
  = 130 - 7×17
  = 130 - 119
  = 11

λ = 11
```

**計算新點的座標：**

```
x₃ = λ² - 2x₁ mod p
   = 11² - 2×10 mod 17
   = 121 - 20 mod 17
   = 101 mod 17
   = 101 - 5×17
   = 101 - 85
   = 16

x₃ = 16
```

```
y₃ = λ(x₁ - x₃) - y₁ mod p
   = 11(10 - 16) - 6 mod 17
   = 11×(-6) - 6 mod 17
   = -66 - 6 mod 17
   = -72 mod 17
   = -72 + 5×17
   = -72 + 85
   = 13

y₃ = 13
```

**驗證結果：**

```
6G = (16, 13)

檢查是否在曲線上：
y² = 13² = 169 = 169 - 9×17 = 169 - 153 = 16
x³ + 2x + 2 = 16³ + 2×16 + 2 = 4096 + 32 + 2 = 4130

4130 mod 17 = 4130 - 242×17 = 4130 - 4114 = 16 ✓

確認：6G = (16, 13)
```

### 3.4 最終答案

```
公鑰 Q = 6 × G = (16, 13)

總結：
私鑰 d = 6（保密）
公鑰 Q = (16, 13)（公開）

中間計算結果：
G = (5, 1)
2G = (6, 3)
3G = (10, 6)
6G = (16, 13)
```

---

## 4. 演練二：簽署訊息

### 4.1 問題設定

```
給定：
- 曲線 E：y² ≡ x³ + 2x + 2 (mod 17)
- 基準點 G = (5, 1)
- 階數 n = 19
- 私鑰 d = 6
- 訊息 m = "Hello"
- 訊息雜湊 z = 8（為簡化，我們假設 Hash("Hello") = 8）
- 隨機數 k = 5（在實際中應該是隨機生成的）

求：簽章 (r, s)
```

### 4.2 簽署流程

```
1. 計算雜湊：z = Hash(m) = 8
2. 選擇隨機數：k = 5
3. 計算點：(x₁, y₁) = k × G = 5 × G
4. 計算 r = x₁ mod n
5. 計算 s = k⁻¹(z + r·d) mod n
6. 輸出簽章 (r, s)
```

### 4.3 詳細計算步驟

#### 步驟 1：計算 5G = k × G

**使用之前的中間結果：**

```
我們已知：
G = (5, 1)
2G = (6, 3)
3G = (10, 6)

需要計算：5G = 3G + 2G
```

**計算 5G = 3G + 2G：**

```
P = 3G = (10, 6)
Q = 2G = (6, 3)

斜率：
λ = (y₂ - y₁) / (x₂ - x₁) mod p
  = (3 - 6) / (6 - 10) mod 17
  = -3 / -4 mod 17
  = 3 / 4 mod 17
```

**求 4⁻¹ mod 17：**

```
需要找到 x 使得 4x ≡ 1 (mod 17)

嘗試：
4×1 = 4 ≢ 1 (mod 17)
...
4×13 = 52 = 3×17 + 1 ≡ 1 (mod 17) ✓

4⁻¹ = 13 mod 17
```

**繼續計算斜率：**

```
λ = 3 × 13 mod 17
  = 39 mod 17
  = 39 - 2×17
  = 39 - 34
  = 5

λ = 5
```

**計算新點的座標：**

```
x₃ = λ² - x₁ - x₂ mod p
   = 5² - 10 - 6 mod 17
   = 25 - 16 mod 17
   = 9

x₃ = 9
```

```
y₃ = λ(x₁ - x₃) - y₁ mod p
   = 5(10 - 9) - 6 mod 17
   = 5×1 - 6 mod 17
   = 5 - 6 mod 17
   = -1 mod 17
   = 16

y₃ = 16
```

**驗證：**

```
5G = (9, 16)

檢查：
y² = 16² = 256 = 256 - 15×17 = 256 - 255 = 1
x³ + 2x + 2 = 9³ + 2×9 + 2 = 729 + 18 + 2 = 749

749 mod 17 = 749 - 44×17 = 749 - 748 = 1 ✓

確認：5G = (9, 16)
```

---

#### 步驟 2：計算 r = x₁ mod n

```
(x₁, y₁) = 5G = (9, 16)

r = x₁ mod n
  = 9 mod 19
  = 9

r = 9
```

---

#### 步驟 3：計算 s = k⁻¹(z + r·d) mod n

**首先求 k⁻¹ mod n：**

```
k = 5, n = 19
需要找到 k⁻¹ mod 19

使用擴展歐幾里得算法：
19 = 3×5 + 4
5 = 1×4 + 1
4 = 4×1 + 0

回代：
1 = 5 - 1×4
1 = 5 - 1×(19 - 3×5)
1 = 5 - 19 + 3×5
1 = 4×5 - 19

所以：4×5 ≡ 1 (mod 19)

驗證：4×5 = 20 = 19 + 1 ≡ 1 (mod 19) ✓

k⁻¹ = 4 mod 19
```

**計算 z + r·d：**

```
z = 8
r = 9
d = 6

z + r·d = 8 + 9×6
        = 8 + 54
        = 62

62 mod 19 = 62 - 3×19 = 62 - 57 = 5
```

**計算 s：**

```
s = k⁻¹(z + r·d) mod n
  = 4 × 5 mod 19
  = 20 mod 19
  = 1

s = 1
```

---

#### 步驟 4：驗證簽章有效性

```
檢查 r ≠ 0：r = 9 ≠ 0 ✓
檢查 s ≠ 0：s = 1 ≠ 0 ✓

簽章有效
```

### 4.4 最終答案

```
簽章 (r, s) = (9, 1)

總結：
訊息：m = "Hello"
訊息雜湊：z = 8
私鑰：d = 6
隨機數：k = 5
簽章點：5G = (9, 16)
簽章：(r, s) = (9, 1)
```

---

## 5. 演練三：驗證簽章

### 5.1 問題設定

```
給定：
- 曲線 E：y² ≡ x³ + 2x + 2 (mod 17)
- 基準點 G = (5, 1)
- 階數 n = 19
- 公鑰 Q = (16, 13)
- 訊息 m = "Hello"
- 訊息雜湊 z = 8
- 簽章 (r, s) = (9, 1)

驗證：簽章是否有效
```

### 5.2 驗證流程

```
1. 檢查 1 ≤ r < n 且 1 ≤ s < n
2. 計算雜湊：z = Hash(m)
3. 計算 w = s⁻¹ mod n
4. 計算 u₁ = z·w mod n
5. 計算 u₂ = r·w mod n
6. 計算點：(x₁, y₁) = u₁×G + u₂×Q
7. 驗證：r ≡ x₁ mod n
```

### 5.3 詳細計算步驟

#### 步驟 1：驗證簽章格式

```
檢查 r：1 ≤ 9 < 19 ✓
檢查 s：1 ≤ 1 < 19 ✓

簽章格式有效
```

---

#### 步驟 2：計算 w = s⁻¹ mod n

```
s = 1, n = 19
需要找到 s⁻¹ mod 19

1 × 1 = 1 ≡ 1 (mod 19)

s⁻¹ = 1 mod 19

w = 1
```

---

#### 步驟 3：計算 u₁ = z·w mod n

```
z = 8
w = 1
n = 19

u₁ = z × w mod n
   = 8 × 1 mod 19
   = 8

u₁ = 8
```

---

#### 步驟 4：計算 u₂ = r·w mod n

```
r = 9
w = 1
n = 19

u₂ = r × w mod n
   = 9 × 1 mod 19
   = 9

u₂ = 9
```

---

#### 步驟 5：計算驗證點 (x₁, y₁) = u₁×G + u₂×Q

**需要計算：8G + 9Q**

**步驟 5a：計算 8G**

```
我們已知：
2G = (6, 3)
4G = 2G + 2G（待計算）
8G = 4G + 4G（待計算）
```

**計算 4G = 2G + 2G：**

```
P = 2G = (6, 3)

λ = (3x₁² + a) / (2y₁) mod p
  = (3×6² + 2) / (2×3) mod 17
  = (3×36 + 2) / 6 mod 17
  = (108 + 2) / 6 mod 17
  = 110 / 6 mod 17

110 mod 17 = 110 - 6×17 = 110 - 102 = 8

λ = 8 / 6 mod 17
```

**求 6⁻¹ mod 17：**

```
6×3 = 18 ≡ 1 (mod 17)

6⁻¹ = 3 mod 17
```

**繼續：**

```
λ = 8 × 3 mod 17
  = 24 mod 17
  = 7

x₃ = 7² - 2×6 mod 17
   = 49 - 12 mod 17
   = 37 mod 17
   = 37 - 2×17
   = 3

y₃ = 7(6 - 3) - 3 mod 17
   = 7×3 - 3 mod 17
   = 21 - 3 mod 17
   = 18 mod 17
   = 1

4G = (3, 1)
```

**計算 8G = 4G + 4G：**

```
P = 4G = (3, 1)

λ = (3×3² + 2) / (2×1) mod 17
  = (27 + 2) / 2 mod 17
  = 29 / 2 mod 17

29 mod 17 = 12
2⁻¹ = 9（之前計算過）

λ = 12 × 9 mod 17
  = 108 mod 17
  = 108 - 6×17
  = 6

x₃ = 6² - 2×3 mod 17
   = 36 - 6 mod 17
   = 30 mod 17
   = 13

y₃ = 6(3 - 13) - 1 mod 17
   = 6×(-10) - 1 mod 17
   = -60 - 1 mod 17
   = -61 mod 17
   = -61 + 4×17
   = -61 + 68
   = 7

8G = (13, 7)
```

---

**步驟 5b：計算 9Q**

```
Q = (16, 13)
需要計算 9Q

9 = 1001₂（二進制）
9Q = 8Q + Q

先計算一些倍數...
```

**計算 2Q = Q + Q：**

```
Q = (16, 13)

λ = (3×16² + 2) / (2×13) mod 17
  = (768 + 2) / 26 mod 17

768 mod 17 = 768 - 45×17 = 768 - 765 = 3
26 mod 17 = 9

λ = (3 + 2) / 9 mod 17
  = 5 / 9 mod 17
```

**求 9⁻¹ mod 17：**

```
9×2 = 18 ≡ 1 (mod 17)

9⁻¹ = 2 mod 17
```

**繼續：**

```
λ = 5 × 2 mod 17
  = 10

x₃ = 10² - 2×16 mod 17
   = 100 - 32 mod 17
   = 68 mod 17
   = 0

y₃ = 10(16 - 0) - 13 mod 17
   = 160 - 13 mod 17
   = 147 mod 17
   = 147 - 8×17
   = 11

2Q = (0, 11)
```

**計算 4Q = 2Q + 2Q：**

```
P = 2Q = (0, 11)

λ = (3×0² + 2) / (2×11) mod 17
  = 2 / 22 mod 17
  = 2 / 5 mod 17
```

**求 5⁻¹ mod 17：**

```
5×7 = 35 = 2×17 + 1 ≡ 1 (mod 17)

5⁻¹ = 7 mod 17
```

**繼續：**

```
λ = 2 × 7 mod 17
  = 14

x₃ = 14² - 2×0 mod 17
   = 196 mod 17
   = 196 - 11×17
   = 9

y₃ = 14(0 - 9) - 11 mod 17
   = -126 - 11 mod 17
   = -137 mod 17
   = -137 + 9×17
   = 16

4Q = (9, 16)
```

**計算 8Q = 4Q + 4Q：**

```
P = 4Q = (9, 16)

λ = (3×9² + 2) / (2×16) mod 17
  = (243 + 2) / 32 mod 17

243 mod 17 = 243 - 14×17 = 243 - 238 = 5
32 mod 17 = 15

λ = (5 + 2) / 15 mod 17
  = 7 / 15 mod 17
```

**求 15⁻¹ mod 17：**

```
15×8 = 120 = 7×17 + 1 ≡ 1 (mod 17)

15⁻¹ = 8 mod 17
```

**繼續：**

```
λ = 7 × 8 mod 17
  = 56 mod 17
  = 56 - 3×17
  = 5

x₃ = 5² - 2×9 mod 17
   = 25 - 18 mod 17
   = 7

y₃ = 5(9 - 7) - 16 mod 17
   = 10 - 16 mod 17
   = -6 mod 17
   = 11

8Q = (7, 11)
```

**計算 9Q = 8Q + Q：**

```
P = 8Q = (7, 11)
Q = (16, 13)

λ = (13 - 11) / (16 - 7) mod 17
  = 2 / 9 mod 17

9⁻¹ = 2（之前計算過）

λ = 2 × 2 mod 17
  = 4

x₃ = 4² - 7 - 16 mod 17
   = 16 - 23 mod 17
   = -7 mod 17
   = 10

y₃ = 4(7 - 10) - 11 mod 17
   = -12 - 11 mod 17
   = -23 mod 17
   = -23 + 2×17
   = 11

9Q = (10, 11)
```

---

**步驟 5c：計算 8G + 9Q**

```
P = 8G = (13, 7)
Q = 9Q = (10, 11)

λ = (11 - 7) / (10 - 13) mod 17
  = 4 / (-3) mod 17
  = 4 / 14 mod 17
```

**求 14⁻¹ mod 17：**

```
14×11 = 154 = 9×17 + 1 ≡ 1 (mod 17)

14⁻¹ = 11 mod 17
```

**繼續：**

```
λ = 4 × 11 mod 17
  = 44 mod 17
  = 44 - 2×17
  = 10

x₃ = 10² - 13 - 10 mod 17
   = 100 - 23 mod 17
   = 77 mod 17
   = 77 - 4×17
   = 9

y₃ = 10(13 - 9) - 7 mod 17
   = 40 - 7 mod 17
   = 33 mod 17
   = 33 - 17
   = 16

驗證點 = (9, 16)
```

---

#### 步驟 6：最終驗證

```
驗證點 (x₁, y₁) = (9, 16)
簽章中的 r = 9

檢查：r ≡ x₁ mod n
      9 ≡ 9 mod 19 ✓

驗證成功！簽章有效！
```

### 5.4 最終答案

```
驗證結果：✓ 簽章有效

總結：
訊息：m = "Hello"
公鑰：Q = (16, 13)
簽章：(r, s) = (9, 1)

驗證計算：
w = s⁻¹ = 1
u₁ = z·w = 8
u₂ = r·w = 9
驗證點 = u₁×G + u₂×Q = 8G + 9Q = (9, 16)
r = 9 ≡ x₁ = 9 (mod 19) ✓

結論：簽章確實由私鑰 d = 6 的擁有者簽署
```

---

## 6. 數學驗證

### 6.1 驗證公式的正確性

**證明驗證點等於簽章點：**

```
驗證點 = u₁×G + u₂×Q
       = (z·w)×G + (r·w)×Q
       = w(z×G + r×Q)
       = s⁻¹(z×G + r×Q)
```

**代入 Q = d×G：**

```
驗證點 = s⁻¹(z×G + r×d×G)
       = s⁻¹(z + r×d)×G
```

**從簽署過程，我們有 s = k⁻¹(z + r×d)：**

```
驗證點 = s⁻¹(z + r×d)×G
       = [k⁻¹(z + r×d)]⁻¹ × (z + r×d) × G
       = k/(z + r×d) × (z + r×d) × G
       = k × G

而簽署時：簽章點 = k × G

所以：驗證點 = 簽章點 ✓
```

### 6.2 具體數值驗證

**用我們的例子驗證：**

```
簽署時：
k = 5
簽章點 = 5G = (9, 16)
r = 9

驗證時：
z = 8, r = 9, s = 1
w = s⁻¹ = 1
u₁ = z·w = 8
u₂ = r·w = 9
驗證點 = 8G + 9Q

檢查 8G + 9Q 是否等於 5G：
```

**使用 Q = d×G = 6G：**

```
8G + 9Q = 8G + 9×(6G)
        = 8G + 54G
        = 62G

但我們需要在模 n 下計算：
62 mod 19 = 62 - 3×19 = 5

所以：62G = 5G (mod n)

驗證點 = 5G = (9, 16) ✓
```

---

## 7. 常見計算錯誤和調試技巧

### 7.1 常見錯誤

**錯誤 1：模運算錯誤**
```
✗ 錯誤：-14 mod 17 = -14
✓ 正確：-14 mod 17 = 3

技巧：負數加上足夠的 p 使結果為正
-14 + 17 = 3
```

**錯誤 2：反元素計算錯誤**
```
✗ 錯誤：1/2 mod 17 = 0.5
✓ 正確：1/2 mod 17 = 2⁻¹ mod 17 = 9

技巧：除法 = 乘以反元素
a/b mod p = a × b⁻¹ mod p
```

**錯誤 3：點加法公式混淆**
```
✗ 錯誤：對 P + Q（P ≠ Q）使用點加倍公式
✓ 正確：P + P 用加倍公式，P + Q（P ≠ Q）用加法公式

檢查：比較 x 座標，如果相同用加倍公式
```

**錯誤 4：忘記模 n vs 模 p**
```
✗ 錯誤：計算 s 時使用 mod p
✓ 正確：
  - 點運算（x, y 座標）使用 mod p
  - 標量運算（r, s, k, d）使用 mod n

記憶：「點在 p 上，數在 n 上」
```

### 7.2 調試技巧

**技巧 1：中間結果檢查**
```
每計算一個點，立即驗證是否在曲線上：
y² ≡ x³ + ax + b (mod p)

如果不在曲線上，前面一定有錯誤
```

**技巧 2：使用已知結果**
```
如果計算 kG：
- 先計算小的倍數（2G, 3G）
- 驗證它們在曲線上
- 再組合計算大的倍數
```

**技巧 3：反向驗證**
```
計算完 P + Q = R 後，
嘗試計算 R - Q 應該等於 P

其中 -Q = (x, -y mod p)
```

**技巧 4：模運算驗證**
```
計算 a mod p 後，驗證：
- 結果在 [0, p-1] 範圍內
- a - (結果) 能被 p 整除
```

### 7.3 計算檢查清單

```
點加法/加倍後：
□ 計算了正確的斜率 λ
□ 使用了正確的公式（加法 vs 加倍）
□ 正確處理了負數（加 p）
□ 驗證新點在曲線上

模反元素計算：
□ 驗證 a × a⁻¹ ≡ 1 (mod m)
□ 結果在 [1, m-1] 範圍內

簽署/驗證：
□ 點運算使用 mod p
□ 標量運算使用 mod n
□ 檢查 r ≠ 0, s ≠ 0
□ 最終驗證 r ≡ x₁ (mod n)
```

---

## 8. 練習題

### 8.1 公鑰生成練習

**練習 1：**
```
使用相同的曲線和基準點：
E：y² ≡ x³ + 2x + 2 (mod 17)
G = (5, 1)

計算以下私鑰對應的公鑰：
a) d = 3
b) d = 7
c) d = 10
```

**提示：**
- 可以重用之前計算的中間結果
- 驗證每個結果是否在曲線上

---

### 8.2 簽署練習

**練習 2：**
```
使用以下參數簽署訊息：
- 私鑰 d = 3
- 訊息雜湊 z = 5
- 隨機數 k = 7

求簽章 (r, s)
```

---

### 8.3 驗證練習

**練習 3：**
```
驗證以下簽章：
- 公鑰 Q = 3G = (10, 6)
- 訊息雜湊 z = 5
- 簽章 (r, s) = (?, ?)（使用練習 2 的結果）

驗證簽章是否有效
```

---

### 8.4 綜合練習

**練習 4：**
```
完整的 ECDSA 流程：
1. 選擇私鑰 d = 8
2. 計算公鑰 Q
3. 對訊息雜湊 z = 10 簽署（使用 k = 4）
4. 驗證你生成的簽章
5. 嘗試用錯誤的公鑰驗證，觀察結果
```

---

## 9. 總結與反思

### 9.1 學習收穫

完成手算演練後，您應該能夠：

```
✓ 完整追蹤 ECDSA 的每個計算步驟
✓ 理解公鑰、簽章和驗證的數學關聯
✓ 識別計算中可能出現的錯誤
✓ 對 ECDSA 的安全性有直觀理解
✓ 解釋為什麼驗證能檢測出偽造簽章
```

### 9.2 關鍵洞察

**洞察 1：隨機性的重要性**
```
在手算中，我們使用 k = 5
在實際中，k 必須是不可預測的隨機數

如果 k 可預測或重複：
- 攻擊者可以恢復私鑰 d
- 所有安全性都失效
```

**洞察 2：模運算的微妙性**
```
mod p（曲線上的點）vs mod n（標量值）
混淆這兩者會導致完全錯誤的結果

這是實現 ECDSA 時常見的錯誤來源
```

**洞察 3：驗證的數學美**
```
驗證不需要知道私鑰 d 或隨機數 k
但能通過公開信息（Q, r, s, z）
數學上證明簽章的有效性

這是公鑰密碼學的核心魔力
```

### 9.3 從小參數到實際應用

**我們的練習：**
```
曲線：y² ≡ x³ + 2x + 2 (mod 17)
p = 17（5 位元）
n = 19（5 位元）
```

**實際應用（Bitcoin）：**
```
曲線：y² ≡ x³ + 7 (mod p)
p ≈ 2²⁵⁶（256 位元）
n ≈ 2²⁵⁶（256 位元）
```

**放大效果：**
```
我們的曲線：
- 19 個點
- 可以窮舉所有可能性
- 用於教學和理解

實際曲線：
- ≈ 2²⁵⁶ 個點
- 窮舉需要 10⁷⁷ 年（超過宇宙年齡）
- 實際安全可用

數學原理完全相同！
```

### 9.4 下一步學習

**鞏固理解：**
```
1. 重做手算演練（不看答案）
2. 嘗試不同的參數組合
3. 完成所有練習題
4. 驗證你的答案
```

**延伸學習：**
```
1. 實現簡單的 ECDSA Python 程式
2. 研究實際的實現（libsecp256k1）
3. 分析 Bitcoin 交易的實際簽章
4. 學習其他橢圓曲線（secp256k1, P-256）
```

**實踐應用：**
```
1. 使用 OpenSSL 生成 ECDSA 金鑰
2. 簽署和驗證實際文件
3. 分析 TLS 證書中的 ECDSA 簽章
4. 構建簡單的簽章驗證工具
```

---

## 🎯 下一步

恭喜完成模組五的手算演練！這是課程中最具挑戰性的部分。

**接下來：**
- **[模組六：習題練習](../module6-practice-exercises/)** - 鞏固所學知識
- 完成本模組的 **[隨堂測驗](./QUIZ.md)** - 檢驗您的計算能力

**學習建議：**
1. 如果覺得困難，不要氣餒，這是正常的
2. 多做幾次練習，熟能生巧
3. 理解比速度更重要
4. 可以使用計算器輔助，但要理解每一步

**實踐建議：**
- 在紙上完整寫出至少一次完整流程
- 與同學討論和驗證結果
- 嘗試用不同參數重複練習

您已經掌握了 ECDSA 的核心！繼續加油！🚀

