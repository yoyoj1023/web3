# 模組三：ECDSA 核心概念

## 📚 學習目標

完成本模組後,您將能夠：
- ✅ 深入理解 ECDSA 的公私鑰系統
- ✅ 掌握橢圓曲線離散對數問題（ECDLP）
- ✅ 理解 ECDSA 的安全性基礎
- ✅ 比較 ECDSA 與其他簽章方案（RSA、DSA）
- ✅ 了解 ECDSA 的參數選擇和標準曲線

**預計學習時間：** 3-4 小時

---

## 1. ECDSA 概述

### 1.1 什麼是 ECDSA？

**ECDSA（Elliptic Curve Digital Signature Algorithm）** 是基於橢圓曲線密碼學的數位簽章演算法。

**核心特點：**
- 🔑 使用橢圓曲線點運算
- 🔒 基於橢圓曲線離散對數問題（ECDLP）的安全性
- ⚡ 相比 RSA 和 DSA 更高效
- 📏 更短的金鑰和簽章長度

### 1.2 ECDSA 的歷史背景

```
1985：Miller 和 Koblitz 獨立提出橢圓曲線密碼學（ECC）
1992：Scott Vanstone 等人提出 ECDSA
1999：ECDSA 被納入 ANSI X9.62 標準
2000：被 IEEE 和 NIST 採納為標準
2009：Bitcoin 採用 ECDSA（secp256k1 曲線）
2015：Ethereum 同樣採用 ECDSA 作為簽名方案
```

**為什麼 ECDSA 變得流行？**
1. **效率需求**：移動設備和物聯網的普及
2. **安全性**：提供與 RSA 相當的安全性但金鑰更短
3. **區塊鏈**：加密貨幣的採用大大提升了知名度
4. **標準化**：主要標準組織的認可和推廣

---

## 2. 公私鑰密碼系統

### 2.1 對稱 vs 非對稱加密

在深入 ECDSA 之前，讓我們先理解它所基於的公私鑰密碼系統。

#### 對稱加密（Symmetric Encryption）

```
        相同金鑰
發送者 ---------> 接收者
       加密/解密

問題：如何安全地分享金鑰？
```

**特點：**
- ✅ 速度快
- ❌ 金鑰分發困難
- ❌ 無法實現數位簽章

#### 非對稱加密（Asymmetric Encryption）

```
私鑰（Private Key）：保密，只有擁有者知道
公鑰（Public Key）：公開，任何人都可以知道

加密：用公鑰加密 → 只有私鑰能解密
簽章：用私鑰簽署 → 任何人用公鑰驗證
```

**特點：**
- ✅ 解決金鑰分發問題
- ✅ 可實現數位簽章
- ❌ 運算較慢

### 2.2 ECDSA 中的公私鑰

#### 密碼學參數

在 ECDSA 中，我們需要以下參數（稱為**域參數 Domain Parameters**）：

```
E: 橢圓曲線
   y² ≡ x³ + ax + b (mod p)
   
p: 大質數（定義有限體 𝔽p）

G: 基準點（Base Point / Generator Point）
   橢圓曲線 E 上的一個特定點
   
n: 基準點 G 的階數（Order）
   即 n × G = 無窮遠點 𝒪
   n 是一個大質數
```

**重要性質：**
- G 是公開已知的
- n 定義了可能的私鑰數量（1 到 n-1）
- 所有公鑰都是 G 的倍數點

#### 金鑰生成過程

**1. 選擇私鑰（Private Key）**
```
d = 隨機選擇一個整數，範圍：1 ≤ d ≤ n-1

要求：
- 必須是真隨機數（不能是偽隨機）
- 必須保密（洩露 = 失去所有安全性）
- 每個用戶的私鑰必須不同
```

**2. 計算公鑰（Public Key）**
```
Q = d × G

其中：
- d：私鑰（純量 scalar）
- G：基準點（橢圓曲線上的點）
- Q：公鑰（橢圓曲線上的點）
- ×：點乘法運算（標量乘法）
```

#### 具體範例

讓我們用一個小的曲線參數來演示：

```
橢圓曲線 E：y² ≡ x³ + 2x + 2 (mod 17)
基準點 G = (5, 1)
階數 n = 19

步驟 1：選擇私鑰
d = 7（在實際應用中是一個非常大的隨機數）

步驟 2：計算公鑰
Q = 7 × G = 7 × (5, 1)

計算過程（使用點加法）：
1×G = (5, 1)
2×G = (5, 1) + (5, 1) = (6, 3)
3×G = (6, 3) + (5, 1) = (10, 6)
4×G = (10, 6) + (5, 1) = (3, 1)
5×G = (3, 1) + (5, 1) = (9, 16)
6×G = (9, 16) + (5, 1) = (16, 13)
7×G = (16, 13) + (5, 1) = (0, 6)

結果：Q = (0, 6)

公開信息：
- 曲線 E：y² ≡ x³ + 2x + 2 (mod 17)
- 基準點 G = (5, 1)
- 階數 n = 19
- 公鑰 Q = (0, 6)

保密信息：
- 私鑰 d = 7
```

### 2.3 為什麼這個系統是安全的？

#### 單向函數（One-Way Function）

```
已知 d 和 G → 計算 Q = d × G    【容易】
已知 Q 和 G → 計算 d = ?        【困難】
```

**正向運算（簡單）：**
```
計算 Q = d × G 使用「雙倍加法」演算法
複雜度：O(log d)

例如計算 100×G：
100 = 64 + 32 + 4（二進制：1100100）
100×G = 64×G + 32×G + 4×G
只需要 6 次加倍運算 + 2 次加法運算
```

**反向運算（困難）：**
```
給定 Q 和 G，找出 d 使得 Q = d×G
需要嘗試所有可能的 d 值（1 到 n-1）
複雜度：O(√n)（使用最佳演算法）

實際例子：
如果 n ≈ 2²⁵⁶（secp256k1）
需要嘗試約 2¹²⁸ 次 ≈ 340,282,366,920,938,463,463,374,607,431,768,211,456 次
即使全世界的計算機一起算，也需要數十億年
```

---

## 3. 橢圓曲線離散對數問題（ECDLP）

### 3.1 問題定義

**橢圓曲線離散對數問題（ECDLP）：**
```
給定：
- 橢圓曲線 E
- 基準點 G
- 點 Q（已知 Q = d×G）

求：整數 d

限制條件：1 ≤ d ≤ n-1
```

### 3.2 為什麼 ECDLP 是困難的？

#### 在有限體中沒有「除法」

在橢圓曲線的有限體中：
```
✓ 加法有定義：P + Q
✓ 乘法有定義：d × P（重複加法）
✗ 除法無定義：Q ÷ G = ?（沒有意義）

因此不能用「除法」來求 d
```

#### 攻擊方法和複雜度

**1. 窮舉搜尋（Brute Force）**
```
方法：嘗試所有可能的 d（1 到 n-1）
複雜度：O(n)
對於 n ≈ 2²⁵⁶：不可行
```

**2. 小步大步演算法（Baby-step Giant-step）**
```
方法：分割搜尋空間
複雜度：O(√n)
空間：O(√n)
對於 n ≈ 2²⁵⁶：仍不可行（需要 2¹²⁸ 次運算）
```

**3. Pollard's Rho 演算法**
```
方法：使用隨機遊走找出碰撞
複雜度：O(√n)
空間：O(1)
對於 n ≈ 2²⁵⁶：最佳方法，但仍不可行
```

**結論：**
目前沒有已知的多項式時間演算法可以解決 ECDLP（在經典計算機上）。

#### 量子計算的威脅

```
⚠️ 重要警告：

Shor's 演算法（1994）可以在量子計算機上以多項式時間解決 ECDLP
複雜度：O((log n)³)

影響：
- 足夠強大的量子計算機可以破解當前的 ECDSA
- 需要研究後量子密碼學（Post-Quantum Cryptography）
- Bitcoin 等系統將需要升級

當前狀態：
- 實用的量子計算機尚未實現
- 預計還需要 10-20 年才能威脅到 256 位元 ECC
- 後量子算法標準化正在進行中（NIST PQC）
```

### 3.3 安全性考量

#### 曲線選擇的重要性

**不是所有橢圓曲線都是安全的！**

**不安全的曲線特徵：**
```
1. 異常曲線（Anomalous Curves）
   n = p 的曲線
   可以用 MOV 攻擊在多項式時間內破解

2. 超奇異曲線（Supersingular Curves）
   可以將 ECDLP 轉化為較簡單的問題
   
3. 小子群攻擊（Small Subgroup Attack）
   曲線的階數有小因子
   
4. 扭曲曲線攻擊（Twist Attack）
   曲線的扭曲也必須是安全的
```

**安全曲線的要求：**
```
✓ n 是大質數（或有一個大質數因子）
✓ n ≠ p
✓ 曲線不是超奇異的
✓ 曲線的扭曲也是安全的
✓ 參數選擇透明（無後門）
```

---

## 4. ECDSA vs 其他簽章方案

### 4.1 ECDSA vs RSA

| 特性 | ECDSA | RSA |
|------|-------|-----|
| **安全基礎** | 橢圓曲線離散對數問題 | 大數分解問題 |
| **金鑰長度（128位安全性）** | 256 bits | 3072 bits |
| **公鑰大小** | 257 bits（壓縮）| 3072 bits |
| **簽章大小** | 512 bits | 3072 bits |
| **簽署速度** | 較快 | 較快 |
| **驗證速度** | 較慢 | 非常快 |
| **金鑰生成速度** | 快 | 慢 |
| **適用場景** | 資源受限環境 | 需要快速驗證 |
| **標準化** | NIST, SEC | 非常成熟 |
| **量子安全性** | 不安全 | 不安全 |

#### 詳細比較

**1. 金鑰大小**
```
128 位元安全等級：
ECDSA: 256 bits
RSA:   3072 bits
比例：1:12

256 位元安全等級：
ECDSA: 512 bits
RSA:   15360 bits
比例：1:30
```

**2. 性能比較（相對值）**
```
操作          ECDSA    RSA-3072
--------------------------------
金鑰生成      1x       50x
簽署          1x       2x
驗證          10x      1x

結論：
- ECDSA 金鑰生成和簽署較快
- RSA 驗證較快
- ECDSA 更適合資源受限環境
```

**3. 實際大小範例**
```
Bitcoin 交易：
公鑰：33 bytes（壓縮）或 65 bytes（未壓縮）
簽章：71-73 bytes（DER 編碼）

如果使用 RSA-3072：
公鑰：384 bytes
簽章：384 bytes
比例：約 6-12 倍
```

### 4.2 ECDSA vs DSA

DSA（Digital Signature Algorithm）是 ECDSA 的前身，使用有限體而不是橢圓曲線。

| 特性 | ECDSA | DSA |
|------|-------|-----|
| **數學基礎** | 橢圓曲線群 | 模 p 的乘法群 |
| **金鑰長度** | 256 bits | 3072 bits |
| **簽章格式** | (r, s) | (r, s) |
| **簽署流程** | 非常相似 | 非常相似 |
| **效率** | 更高 | 較低 |

**相似點：**
```
兩者的簽署和驗證流程幾乎相同：
- 都使用隨機數 k
- 都產生 (r, s) 簽章
- 都需要計算模反元素

ECDSA 可以看作是 DSA 的橢圓曲線版本
```

**差異：**
```
DSA：
- 使用模質數 p 的乘法群
- 公鑰：y = g^x mod p
- 需要更大的參數（3072 bits）

ECDSA：
- 使用橢圓曲線群
- 公鑰：Q = d×G
- 參數更小（256 bits）
```

### 4.3 ECDSA vs EdDSA

EdDSA（Edwards-curve Digital Signature Algorithm）是較新的橢圓曲線簽名方案。

| 特性 | ECDSA | EdDSA |
|------|-------|-------|
| **曲線形式** | Weierstrass 形式 | Edwards 形式 |
| **隨機性** | 需要真隨機數 | 確定性（RFC 6979）|
| **側信道攻擊** | 需要小心實現 | 抗側信道攻擊 |
| **運算速度** | 較慢 | 更快 |
| **實現難度** | 較難 | 較易 |
| **採用程度** | 非常廣泛 | 逐漸增加 |

**EdDSA 的優勢：**
```
1. 確定性簽名：
   - ECDSA：需要真隨機數 k（如果重複使用會洩露私鑰）
   - EdDSA：k = Hash(私鑰 || 訊息)（確定性，無需隨機數）

2. 抗側信道攻擊：
   - 使用完全加法公式
   - 無分支運算
   - 恆定時間實現更容易

3. 更快的運算：
   - Edwards 曲線的加法公式更簡單
   - 通常比 ECDSA 快 2-3 倍

4. 更安全的設計：
   - 避免了許多 ECDSA 的陷阱
   - 更難出錯
```

**為什麼 ECDSA 仍然廣泛使用？**
```
1. 歷史原因：
   - Bitcoin (2009) 和 Ethereum (2015) 採用
   - 大量現有系統使用

2. 標準化：
   - NIST、ANSI、ISO 等標準
   - 廣泛的工具和庫支持

3. 硬體支持：
   - 許多安全芯片和 HSM 支持 ECDSA
   - EdDSA 支持較少

4. 兼容性：
   - 更改簽名方案需要硬分叉
   - 互操作性要求
```

---

## 5. 標準曲線參數

### 5.1 為什麼需要標準曲線？

**問題：**
- 選擇安全的橢圓曲線參數很複雜
- 錯誤的參數選擇可能導致安全漏洞
- 每個人都選擇自己的曲線會導致互操作性問題

**解決方案：**
標準化組織（NIST、SECG）提供了經過驗證的標準曲線參數。

### 5.2 常用標準曲線

#### NIST Curves（FIPS 186-4）

**NIST P-256（secp256r1）**
```
別名：P-256, prime256v1
安全等級：128 位元

參數：
p = 2²⁵⁶ - 2²²⁴ + 2¹⁹² + 2⁹⁶ - 1
a = p - 3
b = 41058363725152142129326129780047268409114441015993725554835256314039467401291

應用：
- TLS/SSL 證書
- 美國政府系統
- Apple Secure Enclave
```

**NIST P-384（secp384r1）**
```
別名：P-384
安全等級：192 位元

應用：
- 高安全性要求系統
- Suite B 密碼套件
```

**NIST P-521（secp521r1）**
```
別名：P-521
安全等級：256 位元

應用：
- 最高安全性要求
- 長期密鑰保護
```

#### SECG Curves

**secp256k1**
```
由 SECG 標準化（SEC 2）
最著名的應用：Bitcoin 和 Ethereum

參數：
p = 2²⁵⁶ - 2³² - 977
a = 0
b = 7

方程式：y² = x³ + 7

基準點 G：
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424

階數 n：
n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
（≈ 2²⁵⁶）

為什麼 Bitcoin 選擇 secp256k1？
1. 特殊形式（a=0, b=7）使運算更快
2. 非 NIST 曲線，避免可能的後門
3. 良好的安全性分析
```

#### Curve25519 系列

**Curve25519**
```
由 Daniel J. Bernstein 設計（2005）
用於 ECDH 金鑰交換

參數：
p = 2²⁵⁵ - 19
Montgomery 形式：y² = x³ + 486662x² + x

特點：
- 設計透明（無隨機參數）
- 抗側信道攻擊
- 非常快速

應用：
- Signal Protocol
- WireGuard VPN
- SSH (draft)
```

**Ed25519**
```
Curve25519 的 Edwards 形式
用於 EdDSA 簽名

應用：
- OpenSSH
- GnuPG
- 許多新的區塊鏈項目
```

### 5.3 曲線選擇建議

#### 安全性考量

**1. 避免已知弱曲線**
```
❌ 不要使用：
- secp112r1, secp128r1（太小）
- 自定義的未經驗證的曲線
- 有安全問題的曲線（如某些超奇異曲線）

✓ 推薦使用：
- NIST P-256/P-384/P-521
- secp256k1
- Curve25519/Ed25519
```

**2. 參數透明度**
```
NIST 曲線的爭議：
- 參數來源不明確（使用隨機 seed）
- 可能存在後門（NSA 爭議）

替代方案：
- secp256k1（參數簡單透明）
- Curve25519（設計過程透明）
```

#### 應用場景建議

**區塊鏈/加密貨幣：**
```
推薦：secp256k1
原因：
- Bitcoin 和 Ethereum 使用
- 豐富的庫支持
- 社區廣泛接受
```

**通用應用：**
```
推薦：NIST P-256
原因：
- 廣泛的標準支持
- 硬體加速支持
- 成熟的實現
```

**新項目：**
```
推薦：Ed25519
原因：
- 更安全的設計
- 更快的性能
- 更易於正確實現
```

**政府/軍事：**
```
推薦：NIST P-384 或 P-521
原因：
- 符合 FIPS 標準
- 更高的安全邊際
- 官方認可
```

### 5.4 參數驗證

在使用橢圓曲線之前，應該驗證參數的有效性：

```python
def verify_curve_parameters(p, a, b, G, n):
    """
    驗證橢圓曲線參數的有效性
    """
    # 1. 檢查 p 是質數
    if not is_prime(p):
        return False, "p 不是質數"
    
    # 2. 檢查曲線方程式有效（無奇點）
    discriminant = (4 * a**3 + 27 * b**2) % p
    if discriminant == 0:
        return False, "曲線有奇點"
    
    # 3. 檢查 G 在曲線上
    Gx, Gy = G
    if (Gy**2) % p != (Gx**3 + a*Gx + b) % p:
        return False, "G 不在曲線上"
    
    # 4. 檢查 n 是質數
    if not is_prime(n):
        return False, "n 不是質數"
    
    # 5. 檢查 n × G = 𝒪
    if not is_point_at_infinity(scalar_mult(n, G)):
        return False, "n × G ≠ 𝒪"
    
    # 6. 檢查 MOV 條件（避免異常曲線）
    if n == p:
        return False, "異常曲線（n = p）"
    
    # 7. 檢查 n 不太小
    if n.bit_length() < 160:
        return False, "n 太小（不安全）"
    
    return True, "參數有效"
```

---

## 6. ECDSA 的安全性分析

### 6.1 理論安全性

**假設：**
```
ECDSA 的安全性基於以下假設：
1. ECDLP 在計算上是困難的
2. 使用的雜湊函數是抗碰撞的
3. 隨機數 k 是真隨機且保密的
4. 實現沒有側信道洩露
```

**安全性歸約：**
```
如果攻擊者可以偽造簽名 → 可以解決 ECDLP
這是一個歸約證明，表明 ECDSA 至少和 ECDLP 一樣安全
```

### 6.2 實際攻擊向量

#### 1. 隨機數 k 的重複使用

**災難性後果：**
```
如果對兩個不同的訊息使用相同的 k：

簽章 1：s₁ = k⁻¹(z₁ + r·d) mod n
簽章 2：s₂ = k⁻¹(z₂ + r·d) mod n

攻擊者可以計算：
s₁ - s₂ = k⁻¹(z₁ - z₂) mod n
k = (z₁ - z₂)/(s₁ - s₂) mod n

然後恢復私鑰：
d = (s₁·k - z₁)/r mod n
```

**真實案例：PlayStation 3 Hack（2010）**
```
Sony 的 PS3 簽名實現使用了固定的 k
安全研究人員發現後，成功恢復了 Sony 的私鑰
結果：PS3 的安全系統被完全破解
```

**防範措施：**
```
1. 使用真隨機數生成器（TRNG）
2. 使用 RFC 6979 確定性簽名
3. 每次簽名後銷毀 k
4. 實現簽名審計
```

#### 2. 部分 k 洩露攻擊

```
即使只洩露 k 的部分位元也是危險的：

洩露 k 的前 4 位元 → 暴力破解剩餘位元
洩露 k 的約 50% 位元 → 使用格基攻擊恢復私鑰

防範：確保 k 完全保密
```

#### 3. 側信道攻擊

**時間攻擊（Timing Attack）**
```
問題：模反元素計算時間依賴於輸入
攻擊：測量簽名時間，推斷 k 的資訊

防範：使用恆定時間實現
```

**功耗分析（Power Analysis）**
```
問題：運算時的功耗洩露資訊
攻擊：差分功耗分析（DPA）

防範：
- 功耗掩蔽（Power Masking）
- 隨機延遲
- 雙重檢查
```

**電磁洩漏（EM Emission）**
```
問題：電磁輻射洩露運算資訊
防範：遮蔽、隨機化
```

#### 4. 錯誤注入攻擊

```
攻擊方式：
1. 注入故障導致錯誤簽名
2. 分析錯誤簽名恢復私鑰

防範：
- 簽名驗證（自我檢查）
- 錯誤檢測碼
- 安全的硬體環境
```

### 6.3 安全實現準則

#### 基本原則

```
1. 使用經過驗證的密碼學庫
   ✓ OpenSSL, libsecp256k1, BouncyCastle
   ✗ 不要自己實現底層原語

2. 使用標準曲線
   ✓ secp256k1, P-256, Ed25519
   ✗ 不要設計自己的曲線

3. 正確的隨機數生成
   ✓ /dev/urandom（Linux）, CryptGenRandom（Windows）
   ✓ RFC 6979 確定性簽名
   ✗ rand(), Math.random()

4. 保護私鑰
   ✓ 加密存儲
   ✓ 使用硬體安全模組（HSM）
   ✓ 使用後立即清除記憶體
   ✗ 明文存儲
   ✗ 記錄到日誌

5. 點的驗證
   ✓ 驗證點在曲線上
   ✓ 檢查點不是無窮遠點
   ✓ 檢查點的階數
```

#### 代碼安全檢查清單

```python
# ✓ 好的做法
import secrets  # 使用密碼學安全的隨機數
import hmac     # 使用 HMAC 進行確定性簽名

def generate_private_key():
    # 使用密碼學安全的隨機數生成器
    return secrets.randbelow(n - 1) + 1

def clear_sensitive_data(data):
    # 清除敏感資料
    if isinstance(data, bytearray):
        for i in range(len(data)):
            data[i] = 0

# ✗ 壞的做法
import random  # 不安全！

def generate_private_key_bad():
    return random.randint(1, n-1)  # 可預測！
```

---

## 7. 實際應用中的 ECDSA

### 7.1 Bitcoin 中的 ECDSA

**參數：**
```
曲線：secp256k1
方程式：y² = x³ + 7

私鑰：32 bytes（256 bits）
公鑰：33 bytes（壓縮）或 65 bytes（未壓縮）
簽章：約 71-73 bytes（DER 編碼）
```

**地址生成：**
```
1. 生成私鑰 d（32 bytes 隨機數）
2. 計算公鑰 Q = d × G
3. SHA-256 雜湊：h1 = SHA256(Q)
4. RIPEMD-160 雜湊：h2 = RIPEMD160(h1)
5. 添加版本字節和校驗碼
6. Base58 編碼 → Bitcoin 地址
```

**交易簽名：**
```
1. 構建交易訊息
2. 計算交易雜湊（雙 SHA-256）
3. 使用私鑰簽署雜湊
4. 將簽章和公鑰添加到交易中
5. 廣播交易
```

### 7.2 Ethereum 中的 ECDSA

**與 Bitcoin 的不同：**
```
曲線：相同（secp256k1）
雜湊函數：Keccak-256（不是 SHA-256）
地址：公鑰雜湊的最後 20 bytes
簽章格式：(r, s, v)
  - v：恢復 ID（用於從簽章恢復公鑰）
```

**簽章恢復：**
```
Ethereum 的特殊功能：從簽章恢復公鑰

ecrecover(hash, v, r, s) → address

好處：
- 減少交易大小（不需要包含公鑰）
- 簡化驗證過程
```

### 7.3 TLS/SSL 證書

**使用場景：**
```
ECDSA 在 TLS 1.3 中廣泛使用：
- 伺服器身份驗證
- 客戶端證書（可選）
- 金鑰交換（ECDHE）

常用曲線：
- P-256（最常見）
- P-384（高安全性）
```

**證書範例：**
```
Subject: www.example.com
Issuer: Let's Encrypt Authority
Signature Algorithm: ecdsa-with-SHA256
Public Key Algorithm: id-ecPublicKey
  Curve: prime256v1 (P-256)
  Public Key: 04:xx:xx:...（65 bytes）
Signature: xx:xx:...（約 72 bytes）
```

---

## 8. 進階主題

### 8.1 確定性簽名（RFC 6979）

**問題：**
真隨機數 k 的生成很困難，且容易出錯。

**解決方案：**
```
使用確定性方法生成 k：
k = HMAC_DRBG(私鑰 || 訊息雜湊)

優點：
✓ 不需要隨機數生成器
✓ 簽名是確定性的（相同輸入 → 相同簽名）
✓ 避免 k 重複使用問題

缺點：
✗ 失去隨機性（對某些協議可能是問題）
✗ 需要小心實現避免側信道攻擊
```

### 8.2 簽章壓縮

**標準簽章：(r, s)**
```
大小：64 bytes（各 32 bytes）
```

**壓縮技術：**
```
1. 公鑰壓縮：
   完整：04 || x || y（65 bytes）
   壓縮：02/03 || x（33 bytes）
   節省：32 bytes

2. 簽章壓縮（Schnorr-style）：
   使用不同的簽名方案可以進一步壓縮
```

### 8.3 批次驗證

**問題：**
驗證多個簽章很慢。

**解決方案：**
```
批次驗證算法：
一次驗證多個簽章

性能提升：
驗證 n 個簽章的時間 < n × 單個驗證時間

適用場景：
- 區塊鏈區塊驗證
- 證書鏈驗證
```

### 8.4 門限簽名

**概念：**
```
n 個參與者，需要至少 t 個人合作才能生成簽章
記為 t-of-n 門限簽名

應用：
- 多重簽名錢包
- 企業金鑰管理
- 分散式金鑰生成
```

### 8.5 適應性簽名（Adaptor Signatures）

**用途：**
```
在 Lightning Network 和 Atomic Swaps 中使用
實現無需信任的條件支付

特性：
- 簽名可以「適應」到秘密值
- 揭露簽名會洩露秘密
- 實現原子性交換
```

---

## 9. 總結與檢查清單

### 9.1 核心概念回顧

```
✓ ECDSA 是基於橢圓曲線的數位簽章算法
✓ 安全性基於橢圓曲線離散對數問題（ECDLP）
✓ 公鑰 = 私鑰 × 基準點（Q = d × G）
✓ 從公鑰反推私鑰在計算上不可行
✓ 相比 RSA，ECDSA 金鑰更短但同樣安全
✓ 標準曲線（如 secp256k1、P-256）已經過充分驗證
✓ 隨機數 k 的安全性至關重要
✓ 實現時必須考慮側信道攻擊
```

### 9.2 關鍵要點

**安全性：**
```
1. ECDLP 目前無已知的有效攻擊（經典計算機）
2. 量子計算機可能破解（使用 Shor's 算法）
3. 實現錯誤比數學弱點更危險
```

**效率：**
```
1. 256 位元 ECC ≈ 3072 位元 RSA（安全性）
2. 更短的金鑰和簽章
3. 適合資源受限環境
```

**實用性：**
```
1. 廣泛應用於區塊鏈、TLS、SSH 等
2. 豐富的庫和工具支持
3. 標準化程度高
```

### 9.3 學習檢查清單

#### 概念理解
- [ ] 理解公私鑰密碼系統的原理
- [ ] 理解 ECDLP 為什麼是困難的
- [ ] 理解公鑰生成過程：Q = d × G
- [ ] 理解 ECDSA 的安全性假設
- [ ] 理解為什麼 k 的安全性如此重要

#### 比較分析
- [ ] 能夠比較 ECDSA 和 RSA 的優缺點
- [ ] 理解不同橢圓曲線的特點
- [ ] 知道如何為應用選擇合適的曲線

#### 安全意識
- [ ] 了解常見的攻擊向量
- [ ] 知道安全實現的基本原則
- [ ] 理解側信道攻擊的威脅

#### 實際應用
- [ ] 了解 ECDSA 在 Bitcoin 中的應用
- [ ] 了解 ECDSA 在 Ethereum 中的應用
- [ ] 了解 ECDSA 在 TLS 中的應用

---

## 10. 延伸閱讀

### 技術標準
- [SEC 1: Elliptic Curve Cryptography](http://www.secg.org/sec1-v2.pdf)
- [NIST FIPS 186-4: Digital Signature Standard](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf)
- [RFC 6979: Deterministic Usage of DSA and ECDSA](https://tools.ietf.org/html/rfc6979)

### 學術論文
- N. Koblitz, "Elliptic Curve Cryptosystems", Mathematics of Computation, 1987
- V. Miller, "Use of Elliptic Curves in Cryptography", CRYPTO 1985
- D. J. Bernstein, "Curve25519: New Diffie-Hellman Speed Records", PKC 2006

### 實踐資源
- [Bitcoin Developer Guide - Transactions](https://bitcoin.org/en/developer-guide#transactions)
- [Understanding Bitcoin Cryptography](https://github.com/bitcoin/bips)
- [OpenSSL EC Documentation](https://www.openssl.org/docs/man1.1.1/man3/EC_KEY_new.html)

### 安全研究
- "PlayStation 3 ECDSA Signature Fail"
- "Side-Channel Attacks on ECC Implementations"
- "Lattice Attacks on ECDSA with Partial Nonce Exposure"

---

## 🎯 下一步

恭喜完成模組三！您現在已經理解了 ECDSA 的核心概念和安全性基礎。

**接下來：**
- **[模組四：簽署與驗證流程](../module4-signing-verification-flow/)** - 學習 ECDSA 的具體操作步驟
- 完成本模組的 **[隨堂測驗](./QUIZ.md)** - 檢驗您的理解程度

**學習建議：**
1. 確保您理解公私鑰系統的基本原理
2. 重點理解為什麼 ECDLP 是困難的
3. 了解實際應用中的安全考量
4. 在進入下一模組前完成測驗

繼續加油！🚀

