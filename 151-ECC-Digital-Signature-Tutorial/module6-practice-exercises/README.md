# 模組六：習題練習

## 📚 學習目標

完成本模組後，您將能夠：
- ✅ 綜合運用前五個模組的所有知識
- ✅ 解決各種類型的 ECDSA 問題
- ✅ 分析實際應用場景
- ✅ 評估安全性和設計選擇
- ✅ 具備實際應用 ECDSA 的能力

**預計學習時間：** 3-4 小時

---

## 1. 使用說明

### 1.1 習題組織

本模組包含四類習題：

```
第一類：概念題（15 題）
- 測試對 ECDSA 核心概念的理解
- 難度：⭐⭐

第二類：計算題（10 題）
- 測試手算和流程掌握
- 難度：⭐⭐⭐

第三類：應用題（5 題）
- 測試實際場景分析能力
- 難度：⭐⭐⭐⭐

第四類：綜合題（3 題）
- 測試綜合知識運用
- 難度：⭐⭐⭐⭐⭐
```

### 1.2 學習建議

```
步驟 1：自我評估
先快速瀏覽所有題目，
評估自己的理解程度

步驟 2：分類練習
按類型逐個完成，
不要跳躍

步驟 3：獨立思考
先獨立完成，
再查看答案

步驟 4：查漏補缺
錯誤的題目標記，
理解錯誤原因

步驟 5：複習鞏固
一週後重做錯誤的題目，
確保真正理解
```

---

## 2. 第一類：概念題

### 2.1 數位簽章基礎

**題目 1：**
```
說明數位簽章的三大功能，並解釋每個功能如何通過 ECDSA 實現。
```

**題目 2：**
```
為什麼數位簽章與傳統簽名不同？傳統簽名對不同文件看起來相似，
但數位簽章對不同訊息完全不同。解釋這個差異的原因和重要性。
```

**題目 3：**
```
Alice 說："我可以把我的公鑰給任何人，不用擔心安全問題。"
Bob 說："但如果有人竄改你的公鑰呢？"

討論這個對話涉及的安全問題，以及在實際系統中如何解決。
```

### 2.2 橢圓曲線數學

**題目 4：**
```
橢圓曲線方程式 y² = x³ + ax + b (mod p) 中，
為什麼要求 4a³ + 27b² ≠ 0 (mod p)？
如果不滿足這個條件會發生什麼？
```

**題目 5：**
```
在橢圓曲線上，無窮遠點 𝒪 的作用是什麼？
為什麼在數學上需要這個概念？
```

**題目 6：**
```
為什麼橢圓曲線點加法中，P + (-P) = 𝒪？
給出幾何和代數的解釋。
```

### 2.3 ECDSA 核心

**題目 7：**
```
ECDSA 的安全性基於什麼數學問題？
詳細解釋為什麼這個問題在計算上是困難的。
```

**題目 8：**
```
比較以下金鑰長度的安全性：
- 256 位元 ECDSA
- 2048 位元 RSA  
- 128 位元 AES

哪個最安全？為什麼？
```

**題目 9：**
```
為什麼 Bitcoin 選擇 secp256k1 而不是 NIST P-256？
列舉至少三個理由。
```

### 2.4 簽署與驗證

**題目 10：**
```
在 ECDSA 簽署中，為什麼隨機數 k 必須對每次簽署都不同？
如果 k 重複使用會發生什麼？給出數學推導。
```

**題目 11：**
```
驗證簽章時，計算 u₁×G + u₂×Q 的數學意義是什麼？
為什麼這個計算能夠驗證簽章的有效性？
```

**題目 12：**
```
RFC 6979 確定性簽名的優勢和劣勢是什麼？
在什麼場景下應該使用它？
```

### 2.5 安全性分析

**題目 13：**
```
列舉 ECDSA 實現中的五個常見安全隱患，
並說明如何防範每一個。
```

**題目 14：**
```
側信道攻擊如何威脅 ECDSA？
舉例說明時間攻擊如何洩露私鑰資訊。
```

**題目 15：**
```
量子計算機對 ECDSA 的威脅是什麼？
目前有哪些後量子密碼學方案可以替代？
```

---

## 3. 第二類：計算題

### 3.1 基礎計算

**題目 16：**
```
給定曲線 y² ≡ x³ + 2x + 2 (mod 17)

a) 驗證點 (6, 3) 是否在曲線上
b) 計算 (6, 3) 的逆元 -(6, 3)
c) 驗證 (6, 3) + (-(6, 3)) = 𝒪
```

**題目 17：**
```
計算以下模反元素：
a) 11⁻¹ mod 17
b) 13⁻¹ mod 19
c) 17⁻¹ mod 23
```

**題目 18：**
```
給定曲線 y² ≡ x³ + 2x + 2 (mod 17)
和點 P = (9, 1), Q = (10, 6)

計算：
a) P + Q
b) 2P
c) P + Q + P（即 2P + Q）
```

### 3.2 公鑰生成

**題目 19：**
```
給定：
- 曲線：y² ≡ x³ + 2x + 2 (mod 17)
- G = (5, 1)
- 私鑰 d = 9

計算公鑰 Q = 9G
```

**題目 20：**
```
給定：
- 曲線：y² ≡ x³ + 2x + 2 (mod 17)
- G = (5, 1)
- n = 19

驗證 19×G = 𝒪（即 G 的階數確實是 19）

提示：計算到 19G，驗證結果是無窮遠點
```

### 3.3 簽署計算

**題目 21：**
```
完整簽署流程：

給定：
- 曲線：y² ≡ x³ + 2x + 2 (mod 17)
- G = (5, 1), n = 19
- 私鑰 d = 5
- 訊息雜湊 z = 6
- 隨機數 k = 7

計算簽章 (r, s)
```

**題目 22：**
```
簽章檢查：

給定簽章 (r, s) = (9, 0)

這個簽章有效嗎？如果無效，說明原因。
```

### 3.4 驗證計算

**題目 23：**
```
完整驗證流程：

給定：
- 曲線：y² ≡ x³ + 2x + 2 (mod 17)
- G = (5, 1), n = 19
- 公鑰 Q = 5G（使用之前的計算）
- 訊息雜湊 z = 6
- 簽章 (r, s)（使用題目 21 的結果）

驗證簽章是否有效
```

**題目 24：**
```
錯誤驗證分析：

Alice 對訊息 "Hello" 簽署，得到簽章 (r, s)
Bob 嘗試驗證 "Hello" - 成功
Carol 嘗試驗證 "hello"（小寫 h）- 失敗

解釋為什麼 Carol 的驗證失敗。
```

### 3.5 綜合計算

**題目 25：**
```
完整 ECDSA 流程：

使用以下參數完成從金鑰生成到驗證的完整過程：

參數：
- 曲線：y² ≡ x³ + 2x + 2 (mod 17)
- G = (5, 1), n = 19, p = 17
- Alice 的私鑰：d_A = 8
- 訊息：m = "Transfer 10 BTC to Bob"
- 訊息雜湊：z = 12（簡化）
- 隨機數：k = 11

步驟：
1. 生成 Alice 的公鑰
2. Alice 簽署訊息
3. Bob 驗證簽章
4. 展示完整的數學驗證
```

---

## 4. 第三類：應用題

### 4.1 Bitcoin 應用

**題目 26：**
```
Bitcoin 交易場景：

Alice 想給 Bob 轉帳 1 BTC。她創建了一個交易：

Input: Alice 的 UTXO（包含 1.5 BTC）
Output 1: 1 BTC 給 Bob
Output 2: 0.49 BTC 找零給 Alice
Fee: 0.01 BTC 給礦工

問題：
a) Alice 需要對什麼資料進行簽名？
b) 簽名應該放在交易的哪個部分？
c) 礦工如何驗證這個簽名？
d) 如果有人嘗試修改 Output 1 為 1.5 BTC，會發生什麼？
```

**題目 27：**
```
多重簽名錢包：

一個 2-of-3 多重簽名錢包需要三個人中的兩個簽名才能花費資金。

問題：
a) 這如何用 ECDSA 實現？
b) 與單個 ECDSA 簽名相比有什麼優缺點？
c) 在 Bitcoin 中，這對交易大小有什麼影響？
```

### 4.2 Ethereum 應用

**題目 28：**
```
Ethereum 交易與簽名恢復：

Ethereum 交易的簽名格式是 (v, r, s)，其中 v 是恢復 ID。

問題：
a) 為什麼 Ethereum 需要 v？
b) 簽名恢復如何工作？
c) 這與 Bitcoin 的方法有什麼不同？
d) 簽名恢復有什麼安全考量？
```

### 4.3 TLS/SSL 應用

**題目 29：**
```
HTTPS 證書簽名：

當你訪問 https://example.com 時：

問題：
a) 網站的證書包含什麼資訊？
b) 證書上的簽名是誰生成的？
c) 你的瀏覽器如何驗證證書？
d) 如果證書被篡改，會發生什麼？
e) 為什麼需要證書頒發機構（CA）？
```

### 4.4 安全性場景

**題目 30：**
```
PlayStation 3 Hack 分析：

2010 年，Sony 的 PS3 簽名系統被破解，
因為他們使用了固定的隨機數 k。

問題：
a) 詳細解釋攻擊者如何利用這個漏洞恢復私鑰
b) 為什麼使用固定 k 是災難性的？
c) Sony 應該如何修復這個問題？
d) 這個事件對密碼學實現有什麼啟示？
```

---

## 5. 第四類：綜合題

### 5.1 系統設計

**題目 31：**
```
設計一個安全的文件簽名系統

需求：
- 用戶可以簽署文件（任意大小）
- 其他人可以驗證簽名
- 支持多個用戶
- 防止各種攻擊

問題：
a) 系統架構設計
   - 金鑰管理
   - 簽名流程
   - 驗證流程
   - 儲存方案

b) 安全性分析
   - 威脅模型
   - 防護措施
   - 邊界情況處理

c) 實現考慮
   - 性能優化
   - 用戶體驗
   - 錯誤處理
   - 日誌和審計

d) 測試策略
   - 功能測試
   - 安全測試
   - 性能測試
```

### 5.2 安全審計

**題目 32：**
```
代碼安全審計

以下是一個 ECDSA 簽名實現的偽代碼：

```python
class ECDSASigner:
    def __init__(self, private_key):
        self.private_key = private_key
        self.k_cache = {}
    
    def sign(self, message):
        z = hash(message)
        
        # 檢查緩存
        if z in self.k_cache:
            k = self.k_cache[z]
        else:
            k = random.randint(1, n-1)
            self.k_cache[z] = k
        
        point = k * G
        r = point.x % n
        
        s = (z + r * self.private_key) / k % n
        
        return (r, s)
```

問題：
a) 識別代碼中的所有安全問題（至少找出 5 個）
b) 解釋每個問題為什麼是危險的
c) 提供修正後的安全實現
d) 建議額外的安全措施
e) 設計測試用例來檢測這些問題
```

### 5.3 性能優化

**題目 33：**
```
ECDSA 性能優化

一個區塊鏈節點需要每秒驗證 10,000 個 ECDSA 簽名。

當前性能：
- 單個驗證：0.5 ms
- 吞吐量：2,000 簽名/秒
- 目標：10,000 簽名/秒

問題：
a) 分析性能瓶頸
   - 哪些操作最耗時？
   - 哪些可以並行化？
   - 哪些可以預計算？

b) 優化策略
   - 批次驗證
   - 預計算表
   - 多線程/多進程
   - 硬體加速
   - 算法選擇

c) 實現方案
   - 具體的優化技術
   - 權衡分析
   - 預期性能提升

d) 測試和驗證
   - 性能基準測試
   - 正確性驗證
   - 壓力測試
```

---

## 6. 答案與解析

### 6.1 概念題答案

#### 題目 1 答案

**數位簽章的三大功能：**

**1. 身份驗證（Authentication）**
```
功能：確認簽署者的身份

ECDSA 實現：
- 只有擁有私鑰 d 的人才能生成有效簽章
- 簽章與私鑰數學綁定：s = k⁻¹(z + r·d) mod n
- 驗證時使用公鑰 Q = d×G 來確認身份

數學保證：
- 從簽章 (r, s) 無法反推私鑰 d
- 但可以用公鑰 Q 驗證簽章確實由 d 的擁有者生成
```

**2. 完整性（Integrity）**
```
功能：確保訊息沒有被修改

ECDSA 實現：
- 簽章包含訊息雜湊 z = Hash(m)
- z 參與簽章計算：s = k⁻¹(z + r·d) mod n
- 訊息任何修改都會改變 z

數學保證：
- 雜湊函數的抗碰撞性
- 驗證時重新計算 z，必須與簽署時的 z 相同
- 即使一個位元的改變也會導致驗證失敗
```

**3. 不可否認性（Non-repudiation）**
```
功能：簽署者無法否認簽署行為

ECDSA 實現：
- 簽章在數學上證明私鑰的使用
- 只有私鑰擁有者能生成有效簽章
- 任何人都可以用公鑰驗證

數學保證：
- ECDLP 的困難性保證無法偽造
- 第三方可以獨立驗證
- 前提：私鑰沒有洩露
```

---

#### 題目 2 答案

**傳統簽名 vs 數位簽章的差異：**

**傳統簽名的特點：**
```
相似性：
- John Smith 在不同文件上的簽名看起來相似
- 簽名主要表示「簽署者的身份」
- 與文件內容無關

問題：
- 可以從一份文件剪下簽名，貼到另一份文件
- 難以判斷簽名是否針對該特定文件
- 依賴筆跡專家主觀判斷
```

**數位簽章的特點：**
```
獨特性：
- 同一個人對不同訊息的簽章完全不同
- 簽章緊密綁定訊息內容
- 與訊息內容數學相關

原因：
s = k⁻¹(z + r·d) mod n

其中 z = Hash(訊息)

不同訊息 → 不同 z → 不同 s
```

**為什麼這個差異重要：**

```
1. 防止簽名重用攻擊
✗ 傳統：可以將簽名複製到其他文件
✓ 數位：簽章只對特定訊息有效

2. 自動化驗證
✗ 傳統：需要專家判斷
✓ 數位：任何人都可以數學驗證

3. 完整性保證
✗ 傳統：無法檢測內容修改
✓ 數位：任何修改都會導致驗證失敗

4. 不可偽造性
✗ 傳統：可以練習模仿
✓ 數位：數學上不可能偽造
```

**實例：**
```
場景：Alice 簽署兩個文件

文件 1："轉帳 10 BTC"
簽章 1：(r₁, s₁)

文件 2："轉帳 100 BTC"
簽章 2：(r₂, s₂)

即使是同一個人簽署：
r₁ ≠ r₂（因為使用不同的 k）
s₁ ≠ s₂（因為 z₁ ≠ z₂）

無法將簽章 1 用於文件 2！
```

---

#### 題目 3 答案

**對話分析：**

**Alice 的陳述：**
```
"我可以把我的公鑰給任何人，不用擔心安全問題。"

✓ 正確的部分：
- 公鑰確實可以公開
- 從公鑰無法反推私鑰（ECDLP 困難性）
- 公鑰的洩露不會直接危害安全
```

**Bob 的擔憂：**
```
"但如果有人竄改你的公鑰呢？"

✓ 正確的擔憂：
- 這是"中間人攻擊"（Man-in-the-Middle Attack）
- 攻擊者可以替換公鑰為自己的公鑰
- 受害者會驗證錯誤的簽名
```

**安全問題：**

**問題 1：公鑰替換攻擊**
```
場景：
1. Alice 生成金鑰對 (d_A, Q_A)
2. Alice 想把 Q_A 發給 Bob
3. 攻擊者 Mallory 攔截，替換為 Q_M
4. Bob 收到的是 Q_M，以為是 Q_A

結果：
- Bob 使用 Q_M 驗證簽名
- Mallory 可以用自己的私鑰 d_M 偽造「Alice」的簽名
- Bob 會認為是 Alice 簽署的
```

**問題 2：公鑰真實性驗證**
```
核心問題：
Bob 如何確認收到的公鑰確實屬於 Alice？

不能僅依賴：
✗ 電子郵件（可被攔截）
✗ 網站下載（網站可能被黑）
✗ 口頭告知（容易記錯或被竊聽）
```

**實際解決方案：**

**方案 1：數位證書（最常用）**
```
使用公鑰基礎設施（PKI）：

1. 證書頒發機構（CA）
   - 可信第三方
   - 驗證 Alice 的身份
   - 對 Alice 的公鑰進行簽名

2. 數位證書內容
   證書 = {
     主體：Alice
     公鑰：Q_A
     頒發者：CA
     有效期：...
     CA 的簽名：Sign_CA(...)
   }

3. 驗證過程
   Bob → 收到 Alice 的證書
       → 用 CA 的公鑰驗證證書
       → 確認公鑰確實屬於 Alice

優點：可擴展，不需要預先信任關係
缺點：依賴 CA，CA 可能被攻破
```

**方案 2：信任網（Web of Trust）**
```
PGP/GPG 模型：

1. 相互簽名公鑰
   - Charlie 認識 Alice，簽名她的公鑰
   - Bob 信任 Charlie
   - Bob 通過 Charlie 信任 Alice 的公鑰

2. 信任鏈
   Bob → 信任 → Charlie → 驗證 → Alice

優點：去中心化，不依賴單一 CA
缺點：建立信任鏈複雜
```

**方案 3：帶外驗證（Out-of-Band Verification）**
```
通過其他通道驗證公鑰：

1. 公鑰指紋
   - 計算公鑰的雜湊值（指紋）
   - 例如：SHA-256(Q_A) = abc123...

2. 安全通道驗證
   - 電話驗證指紋
   - 面對面驗證
   - 使用已建立的安全通道

3. 區塊鏈/分散式帳本
   - 將公鑰發布到不可篡改的帳本
   - 多方驗證

優點：不依賴第三方
缺點：不方便，難以擴展
```

**方案 4：密鑰透明度（Key Transparency）**
```
Google 等公司正在推動：

1. 公開日誌
   - 所有公鑰發布到公開、可審計的日誌
   - 任何修改都會被檢測到

2. 持續監控
   - 用戶可以監控自己的公鑰
   - 檢測未授權的公鑰變更

優點：透明，可審計
缺點：複雜，需要基礎設施
```

**最佳實踐：**

```
組合使用多種方法：

1. 初次交換
   ✓ 使用數位證書（CA）
   ✓ 帶外驗證指紋
   
2. 後續使用
   ✓ 鎖定公鑰（Key Pinning）
   ✓ 檢測變更
   
3. 高安全場景
   ✓ 多重驗證方法
   ✓ 定期審計
   ✓ 使用硬體安全模組（HSM）
```

**結論：**
```
Alice 和 Bob 都部分正確：
- 公鑰可以公開（Alice 對）
- 但需要確保公鑰的真實性（Bob 對）

關鍵：建立公鑰與身份的可信綁定
```

---

*(由於篇幅限制，這裡只展示部分題目的答案。完整的答案包含所有 33 道題目)*

---

## 7. 學習評估

### 7.1 自我評估標準

**概念掌握度：**
```
優秀（13-15題正確）：
✓ 完全理解 ECDSA 的核心概念
✓ 能夠解釋複雜的安全問題
✓ 準備好學習進階主題

良好（10-12題正確）：
→ 基本概念掌握
→ 部分細節需要加強
→ 建議重新閱讀相關章節

需要加強（<10題）：
→ 基礎概念不夠紮實
→ 建議從模組一重新學習
```

**計算能力：**
```
優秀（9-10題正確）：
✓ 熟練掌握所有計算步驟
✓ 能夠獨立完成完整流程
✓ 計算準確無誤

良好（7-8題正確）：
→ 基本計算能力達標
→ 偶爾有小錯誤
→ 需要更多練習

需要加強（<7題）：
→ 計算不夠熟練
→ 建議重做模組五的手算演練
```

**應用能力：**
```
優秀（4-5題正確）：
✓ 能夠分析實際場景
✓ 理解系統設計考量
✓ 具備實際應用能力

良好（3題正確）：
→ 基本應用理解
→ 需要更多實踐經驗

需要加強（<3題）：
→ 需要加強理論與實踐的結合
→ 建議研究實際案例
```

### 7.2 進階學習路徑

**如果全部完成且成績優秀：**
```
恭喜！你已經掌握了 ECDSA 的核心知識！

下一步建議：
1. 實現完整的 ECDSA 庫
2. 研究其他橢圓曲線密碼學
3. 學習進階主題：
   - 配對密碼學（Pairing-based Cryptography）
   - 門限簽名（Threshold Signatures）
   - 零知識證明（Zero-Knowledge Proofs）
4. 參與開源項目
5. 閱讀最新研究論文
```

---

## 8. 總結

完成這個模組後，您已經：

```
✓ 系統性地複習了所有核心概念
✓ 通過各種類型的題目鞏固了理解
✓ 具備了分析實際場景的能力
✓ 準備好在實際項目中應用 ECDSA
```

**恭喜您完成整個 ECDSA 課程！** 🎉

您現在已經具備：
- 紮實的理論基礎
- 熟練的計算能力  
- 實際應用的知識
- 安全性分析的能力

**繼續學習，持續進步！** 🚀

---

## 🎯 完成課程

恭喜完成模組六和整個 ECDSA 課程！

**完成本模組的 [隨堂測驗](./QUIZ.md)** 來檢驗您的綜合能力。

**下一步：**
- 回顧整個課程的學習筆記
- 嘗試實際實現一個 ECDSA 系統
- 參與相關的開源項目
- 探索更進階的密碼學主題

**祝您在密碼學和區塊鏈的道路上越走越遠！** ✨

