# 模組六測驗：綜合習題練習

**測驗時間：** 30 分鐘  
**總分：** 100 分  
**及格分數：** 70 分

---

## 📝 測驗說明

- 本測驗是課程的最終綜合測驗
- 涵蓋所有六個模組的核心知識
- 包含概念、計算和應用題
- 建議在完成所有模組學習後進行

---

## 第一部分：概念題（每題 5 分，共 40 分）

### 1. ECDSA 的安全性主要基於哪個數學問題？

A. 大數分解問題  
B. 離散對數問題  
C. 橢圓曲線離散對數問題（ECDLP）  
D. 背包問題

---

### 2. 在 ECDSA 簽署中，如果兩次使用相同的隨機數 k 對不同訊息簽署，會導致：

A. 簽章無效  
B. 私鑰洩露  
C. 公鑰洩露  
D. 沒有任何問題

---

### 3. 驗證 ECDSA 簽章時，計算的驗證點是：

A. k × G  
B. d × G  
C. u₁ × G + u₂ × Q  
D. r × G + s × Q

---

### 4. 256 位元的 ECC 金鑰約等於多長的 RSA 金鑰（安全性相當）？

A. 256 bits  
B. 1024 bits  
C. 2048 bits  
D. 3072 bits

---

### 5. Bitcoin 使用哪條橢圓曲線？

A. P-256  
B. secp256k1  
C. Curve25519  
D. Ed25519

---

### 6. RFC 6979 確定性簽名的主要優勢是：

A. 更快的簽名速度  
B. 更小的簽章大小  
C. 不需要隨機數生成器  
D. 更高的安全性

---

### 7. 在橢圓曲線上，無窮遠點 𝒪 的作用是：

A. 曲線的起點  
B. 加法運算的單位元  
C. 乘法運算的單位元  
D. 曲線的終點

---

### 8. 以下哪項不是數位簽章的核心功能？

A. 身份驗證  
B. 完整性保護  
C. 不可否認性  
D. 資料加密

---

## 第二部分：計算題（30 分）

### 9. 模運算計算（10 分）

計算以下值：

a) 15 × 11 mod 17（2分）  
b) (-23) mod 19（2分）  
c) 6⁻¹ mod 17（3分）  
d) 驗證 c) 的答案（3分）

**答案空間：**
```
[請在此處填寫您的答案]









```

---

### 10. 點運算計算（20 分）

**給定曲線：** y² ≡ x³ + 2x + 2 (mod 17)

a) 驗證點 (5, 16) 是否在曲線上（5分）  
b) 計算點 (5, 1) 和點 (5, 16) 的和（5分）  
c) 計算 2×(6, 3)（10分）

**答案空間：**
```
[請在此處填寫您的答案]



















```

---

## 第三部分：應用題（30 分）

### 11. 安全性分析（15 分）

**場景：**
一個開發者實現了 ECDSA 簽名功能，但使用以下方法生成隨機數 k：

```python
import time
k = int(time.time()) % n
```

**問題：**
a) 這個實現有什麼安全問題？（5分）  
b) 攻擊者如何利用這個漏洞？（5分）  
c) 應該如何正確實現？（5分）

**答案空間：**
```
[請在此處填寫您的答案]















```

---

### 12. 實際應用分析（15 分）

**場景：**
Alice 想要發送一個已簽名的電子合約給 Bob。

**問題：**
a) Alice 需要執行哪些步驟來簽署合約？（5分）  
b) Bob 如何驗證這個合約確實來自 Alice？（5分）  
c) 如果合約內容被竄改一個字，Bob 驗證時會發生什麼？（5分）

**答案空間：**
```
[請在此處填寫您的答案]















```

---

## 📊 評分標準

### 總分評級
- **90-100 分：優秀**  
  完全掌握 ECDSA 的所有核心知識，可以開始實際應用
  
- **70-89 分：良好**  
  基本掌握核心概念，建議複習薄弱環節
  
- **60-69 分：及格**  
  理解基本概念，但需要加強計算和應用能力
  
- **60 分以下：需要加強**  
  建議重新學習課程，特別是模組三到五

---

# 📘 測驗解答

## 第一部分：選擇題解答

### 1. 答案：C
**解釋：**  
ECDSA 的安全性基於**橢圓曲線離散對數問題（ECDLP）**。

ECDLP 是指：給定橢圓曲線上的兩個點 Q 和 G，找出整數 d 使得 Q = d × G 在計算上是困難的。

- A 錯誤：大數分解是 RSA 的安全基礎
- B 部分正確：但 ECDLP 是更具體的描述
- D 錯誤：背包問題用於其他密碼系統

---

### 2. 答案：B
**解釋：**  
如果兩次使用相同的 k，**私鑰會洩露**。

數學推導：
```
簽章 1：s₁ = k⁻¹(z₁ + r·d) mod n
簽章 2：s₂ = k⁻¹(z₂ + r·d) mod n

因為 k 相同，r 也相同（r = x₁ mod n，而 x₁ 來自 k×G）

攻擊者可以計算：
s₁ - s₂ = k⁻¹(z₁ - z₂) mod n

解出 k：
k = (z₁ - z₂)/(s₁ - s₂) mod n

然後恢復私鑰：
d = (s₁·k - z₁)/r mod n
```

真實案例：2010 年 Sony PlayStation 3 因為使用固定 k 而被破解。

---

### 3. 答案：C
**解釋：**  
驗證點的計算公式是：**u₁ × G + u₂ × Q**

其中：
- u₁ = z·s⁻¹ mod n
- u₂ = r·s⁻¹ mod n
- G 是基準點
- Q 是公鑰

如果簽章有效，這個驗證點應該等於簽署時的點 k×G，它們的 x 座標應該等於 r。

---

### 4. 答案：D
**解釋：**  
256 位元的 ECC 約等於 **3072 位元的 RSA**（都提供 128 位元的安全等級）。

安全等級對照表：
```
安全等級  | ECC 金鑰 | RSA 金鑰 | 比例
---------|---------|---------|-----
128 bits | 256     | 3072    | 1:12
192 bits | 384     | 7680    | 1:20
256 bits | 512     | 15360   | 1:30
```

這就是為什麼 ECC 在移動設備和物聯網中特別有優勢。

---

### 5. 答案：B
**解釋：**  
Bitcoin 使用 **secp256k1** 曲線。

```
曲線方程式：y² = x³ + 7（即 a=0, b=7）
域：𝔽p，其中 p = 2²⁵⁶ - 2³² - 977

選擇理由：
- 特殊係數（a=0, b=7）使運算更快
- 非 NIST 曲線，避免可能的後門
- 經過充分的安全性分析
- 由 SECG 標準化（SEC 2）
```

其他選項：
- A：P-256 主要用於 TLS/SSL
- C, D：Curve25519/Ed25519 用於 Signal、WireGuard 等

---

### 6. 答案：C
**解釋：**  
RFC 6979 的主要優勢是**不需要隨機數生成器**。

```
傳統 ECDSA：
k = 真隨機數

RFC 6979：
k = HMAC_DRBG(私鑰 || 訊息雜湊)
```

**優點：**
- 不依賴隨機數生成器的質量
- 簽名是確定性的（相同輸入→相同簽章）
- 避免 k 重複使用問題
- 更容易測試和審計

**注意：**
- 簽名仍然看起來是隨機的
- 不影響安全性
- 已被許多系統採用

---

### 7. 答案：B
**解釋：**  
無窮遠點 𝒪 是橢圓曲線群的**加法單位元**。

```
定義：
對於任意點 P，P + 𝒪 = P

類比：
- 整數加法的單位元：0（因為 a + 0 = a）
- 橢圓曲線加法的單位元：𝒪（因為 P + 𝒪 = P）
```

**重要性質：**
```
1. 單位元：P + 𝒪 = 𝒪 + P = P
2. 逆元：P + (-P) = 𝒪
3. 階數：n × G = 𝒪
```

**幾何意義：**
```
當兩個互為逆元的點相加時：
- 連線是垂直線
- 垂直線與曲線沒有第三個交點
- 定義這個"交點"為無窮遠點
```

---

### 8. 答案：D
**解釋：**  
**資料加密**不是數位簽章的核心功能。

數位簽章的三大功能：
```
✓ 身份驗證（Authentication）
✓ 完整性保護（Integrity）
✓ 不可否認性（Non-repudiation）
```

**重要區別：**
```
數位簽章：
- 用私鑰簽署
- 用公鑰驗證
- 不提供機密性
- 任何人都可以讀取簽署的訊息

加密：
- 用公鑰加密
- 用私鑰解密
- 提供機密性
- 只有私鑰擁有者能解密
```

**如果需要同時實現：**
```
簽章 + 加密 = Sign-then-Encrypt 或 Encrypt-then-Sign

例如：
1. Alice 用自己的私鑰簽署訊息
2. Alice 用 Bob 的公鑰加密（訊息 + 簽章）
3. Bob 用自己的私鑰解密
4. Bob 用 Alice 的公鑰驗證簽章

這樣既保證機密性又保證真實性
```

---

## 第二部分：計算題解答

### 9. 模運算計算

**a) 15 × 11 mod 17（2分）**

```
15 × 11 = 165

165 ÷ 17 = 9 餘 12
165 = 9×17 + 12

答案：12
```

---

**b) (-23) mod 19（2分）**

```
方法：加上足夠的 19 使結果為正

-23 + 19 = -4
-4 + 19 = 15

答案：15

驗證：15 ≡ -23 (mod 19)
因為 15 = -23 + 2×19
```

---

**c) 6⁻¹ mod 17（3分）**

```
需要找到 x 使得 6x ≡ 1 (mod 17)

方法 1：嘗試法
6×1 = 6 ≢ 1 (mod 17)
6×2 = 12 ≢ 1 (mod 17)
6×3 = 18 = 17 + 1 ≡ 1 (mod 17) ✓

方法 2：擴展歐幾里得算法
17 = 2×6 + 5
6 = 1×5 + 1
5 = 5×1 + 0

回代：
1 = 6 - 1×5
1 = 6 - 1×(17 - 2×6)
1 = 6 - 17 + 2×6
1 = 3×6 - 17

所以：3×6 ≡ 1 (mod 17)

答案：3
```

---

**d) 驗證（3分）**

```
驗證 6 × 3 ≡ 1 (mod 17)

6 × 3 = 18
18 = 1×17 + 1
18 ≡ 1 (mod 17) ✓

驗證成功！
```

---

**評分標準（10分）：**
- a) 正確計算（2分）
- b) 正確處理負數（2分）
- c) 正確找到反元素（3分）
- d) 正確驗證（3分）

---

### 10. 點運算計算

**給定曲線：** y² ≡ x³ + 2x + 2 (mod 17)

**a) 驗證點 (5, 16) 是否在曲線上（5分）**

```
檢查：y² ≡ x³ + 2x + 2 (mod 17)

左邊：
y² = 16²
   = 256
   = 256 - 15×17
   = 256 - 255
   = 1

右邊：
x³ + 2x + 2 = 5³ + 2×5 + 2
            = 125 + 10 + 2
            = 137
            = 137 - 8×17
            = 137 - 136
            = 1

左邊 = 右邊 = 1 ✓

答案：點 (5, 16) 在曲線上
```

---

**b) 計算 (5, 1) + (5, 16)（5分）**

```
P = (5, 1)
Q = (5, 16)

注意：這兩個點的 x 座標相同！

檢查是否互為逆元：
y₁ + y₂ = 1 + 16 = 17 ≡ 0 (mod 17)

是的！所以：
(5, 1) + (5, 16) = 𝒪（無窮遠點）

答案：無窮遠點 𝒪
```

**說明：**
```
當兩個點的 x 座標相同但 y 座標不同時：
- 如果 y₁ + y₂ ≡ 0 (mod p)，它們互為逆元
- 相加結果是無窮遠點

幾何意義：
連接這兩個點的直線是垂直線，
與曲線沒有第三個交點
```

---

**c) 計算 2×(6, 3)（10分）**

```
P = (6, 3)
使用點加倍公式

步驟 1：計算斜率
λ = (3x₁² + a) / (2y₁) mod p

其中 a = 2（曲線參數）

分子：3×6² + 2 = 3×36 + 2 = 108 + 2 = 110
     110 mod 17 = 110 - 6×17 = 8

分母：2×3 = 6

λ = 8 / 6 mod 17
```

**求 6⁻¹ mod 17：**
```
從 a) 我們知道：6⁻¹ = 3 mod 17
```

**繼續計算斜率：**
```
λ = 8 × 3 mod 17
  = 24 mod 17
  = 7
```

**步驟 2：計算 x₃**
```
x₃ = λ² - 2x₁ mod p
   = 7² - 2×6 mod 17
   = 49 - 12 mod 17
   = 37 mod 17
   = 37 - 2×17
   = 3
```

**步驟 3：計算 y₃**
```
y₃ = λ(x₁ - x₃) - y₁ mod p
   = 7(6 - 3) - 3 mod 17
   = 7×3 - 3 mod 17
   = 21 - 3 mod 17
   = 18 mod 17
   = 1
```

**驗證：**
```
(3, 1) 是否在曲線上？

y² = 1² = 1
x³ + 2x + 2 = 3³ + 2×3 + 2 = 27 + 6 + 2 = 35

35 mod 17 = 35 - 2×17 = 1 ✓
```

**答案：2×(6, 3) = (3, 1)**

---

**評分標準（20分）：**
- a) 正確驗證點在曲線上（5分）
  - 計算左邊（2分）
  - 計算右邊（2分）
  - 比較（1分）
- b) 正確識別互為逆元（5分）
  - 注意到 x 座標相同（2分）
  - 檢查 y 座標和（2分）
  - 得出正確結論（1分）
- c) 正確計算點加倍（10分）
  - 計算斜率（4分）
  - 計算 x₃（3分）
  - 計算 y₃（2分）
  - 驗證（1分）

---

## 第三部分：應用題解答

### 11. 安全性分析

**場景分析：**
```python
k = int(time.time()) % n
```

**a) 安全問題（5分）**

**問題 1：可預測性**
```
time.time() 返回當前時間戳（Unix 時間）
例如：1697472345（秒）

這不是隨機數！它是：
- 可預測的
- 單調遞增的
- 精度只到秒級
```

**問題 2：低熵**
```
即使攻擊者不知道確切時間，
搜索空間也很小：

假設簽名時間範圍：
- 當前時間 ± 1 小時 = ± 3600 秒
- 只需要嘗試 7200 個可能的 k 值

比較：
- 理想情況：k 有 2²⁵⁶ 種可能
- 實際情況：k 只有約 10⁴ 種可能
```

**問題 3：可觀察性**
```
攻擊者可以：
1. 記錄簽章被創建的時間（通過網路時間戳）
2. 估計伺服器的時間
3. 窮舉附近的時間戳
```

---

**b) 攻擊方法（5分）**

**攻擊步驟：**

```
假設攻擊者獲得了一個簽章 (r, s) 和訊息 m：

步驟 1：確定時間範圍
- 記錄簽章產生的大致時間
- 例如：2023-10-16 10:30:00
- Unix 時間戳：t₀ = 1697451000

步驟 2：窮舉可能的 k
for t in range(t₀ - 3600, t₀ + 3600):
    k_guess = t % n
    
    # 從簽章恢復私鑰
    # s = k⁻¹(z + r·d) mod n
    # → d = (s·k - z) / r mod n
    
    d_guess = (s * k_guess - z) * mod_inverse(r, n) % n
    
    # 驗證猜測的私鑰
    Q_guess = d_guess * G
    if Q_guess == Q_public:
        # 找到了私鑰！
        return d_guess

步驟 3：恢復私鑰
只需要嘗試幾千次，就能找到正確的 k
然後直接計算出私鑰 d
```

**數學推導：**
```
已知：
- 簽章 (r, s)
- 訊息雜湊 z
- 公鑰 Q

如果猜對了 k：
從 s = k⁻¹(z + r·d) mod n

解出 d：
s·k ≡ z + r·d (mod n)
r·d ≡ s·k - z (mod n)
d ≡ (s·k - z) / r (mod n)
d ≡ (s·k - z) · r⁻¹ (mod n)

驗證：
計算 Q' = d × G
如果 Q' = Q（公鑰），則 d 正確
```

**實際攻擊複雜度：**
```
最壞情況：
- 時間範圍：± 1 小時 = 7200 秒
- 每次嘗試：1 次模運算 + 1 次點乘法
- 總時間：約幾秒鐘（現代計算機）

結論：極其容易破解！
```

---

**c) 正確實現（5分）**

**方法 1：使用密碼學安全的隨機數生成器（推薦）**
```python
import secrets

def generate_secure_k(n):
    """
    生成密碼學安全的隨機 k
    """
    # secrets 模組使用作業系統的隨機數源
    # Linux: /dev/urandom
    # Windows: CryptGenRandom
    k = secrets.randbelow(n - 1) + 1
    return k

# 使用
k = generate_secure_k(n)
```

**為什麼這是安全的：**
```
✓ 使用作業系統的隨機數生成器
✓ 密碼學安全（不可預測）
✓ 均勻分布
✓ 足夠的熵
```

---

**方法 2：RFC 6979 確定性簽名（最推薦）**
```python
import hmac
import hashlib

def generate_deterministic_k(message_hash, private_key, n):
    """
    RFC 6979 確定性 k 生成
    """
    # 將輸入轉換為 bytes
    h1 = message_hash.to_bytes(32, 'big')
    x = private_key.to_bytes(32, 'big')
    
    # HMAC-DRBG 初始化
    v = b'\x01' * 32
    k_hmac = b'\x00' * 32
    
    # HMAC-DRBG 更新
    k_hmac = hmac.new(k_hmac, v + b'\x00' + x + h1, hashlib.sha256).digest()
    v = hmac.new(k_hmac, v, hashlib.sha256).digest()
    k_hmac = hmac.new(k_hmac, v + b'\x01' + x + h1, hashlib.sha256).digest()
    v = hmac.new(k_hmac, v, hashlib.sha256).digest()
    
    # 生成 k
    while True:
        v = hmac.new(k_hmac, v, hashlib.sha256).digest()
        k = int.from_bytes(v, 'big')
        
        if 1 <= k < n:
            return k
        
        k_hmac = hmac.new(k_hmac, v + b'\x00', hashlib.sha256).digest()
        v = hmac.new(k_hmac, v, hashlib.sha256).digest()

# 使用
k = generate_deterministic_k(z, d, n)
```

**優勢：**
```
✓ 不需要隨機數生成器
✓ 確定性（相同輸入 → 相同 k）
✓ 但對外看起來隨機
✓ 不會重複使用 k
✓ 易於測試和審計
✓ 防止弱隨機數問題
```

---

**方法 3：混合方法（最保守）**
```python
def generate_hybrid_k(message_hash, private_key, additional_entropy, n):
    """
    結合 RFC 6979 和額外熵
    """
    # 基礎 k（確定性）
    k_base = generate_deterministic_k(message_hash, private_key, n)
    
    # 額外隨機性
    random_bytes = secrets.token_bytes(32)
    
    # 結合
    combined = int.from_bytes(
        hashlib.sha256(
            k_base.to_bytes(32, 'big') +
            random_bytes
        ).digest(),
        'big'
    )
    
    k = (combined % (n - 1)) + 1
    return k
```

**最佳實踐總結：**
```
1. 絕對不要使用：
   ✗ time.time()
   ✗ random.randint()
   ✗ 固定值
   ✗ 可預測的序列

2. 推薦使用：
   ✓ secrets.randbelow()（Python 3.6+）
   ✓ RFC 6979 確定性簽名
   ✓ 作業系統的 CSPRNG

3. 額外措施：
   ✓ 使用後立即清除 k
   ✓ 實現常數時間算法
   ✓ 添加簽名自我驗證
   ✓ 定期安全審計
```

---

**評分標準（15分）：**
- a) 識別安全問題（5分）
  - 可預測性（2分）
  - 低熵（2分）
  - 可觀察性（1分）
- b) 說明攻擊方法（5分）
  - 攻擊步驟（3分）
  - 數學推導（2分）
- c) 正確實現（5分）
  - 使用安全的方法（3分）
  - 解釋原因（2分）

---

### 12. 實際應用分析

**場景：** Alice 發送已簽名的電子合約給 Bob

**a) Alice 簽署合約的步驟（5分）**

**完整步驟：**

```
步驟 1：準備合約
- 撰寫合約內容
- 確定合約的最終版本
- 將合約轉換為位元組格式

步驟 2：計算雜湊
z = Hash(合約內容)

通常使用：
- SHA-256（Bitcoin、多數應用）
- Keccak-256（Ethereum）
- SHA-3（新標準）

例如：
z = SHA256("合約內容...")
```

```
步驟 3：生成簽章
使用 Alice 的私鑰 d_A 和 ECDSA 簽署：

1. 選擇隨機數 k（或使用 RFC 6979）
2. 計算點 (x₁, y₁) = k × G
3. r = x₁ mod n
4. s = k⁻¹(z + r·d_A) mod n
5. 簽章 = (r, s)
```

```
步驟 4：組合數據
創建簽章包：
{
  "合約內容": "...",
  "簽章": {
    "r": "...",
    "s": "...",
    "簽名算法": "ECDSA-secp256k1-SHA256"
  },
  "公鑰": "...", （Alice 的公鑰）
  "時間戳": "2023-10-16T10:30:00Z"
}
```

```
步驟 5：發送
將簽章包發送給 Bob：
- 電子郵件（附件）
- API 傳輸
- 區塊鏈交易
- 文件傳輸協定
```

---

**b) Bob 驗證合約的方法（5分）**

**完整驗證步驟：**

```
步驟 1：接收數據
Bob 收到：
- 合約內容
- 簽章 (r, s)
- Alice 的公鑰 Q_A
```

```
步驟 2：驗證公鑰真實性（關鍵！）
Bob 需要確認公鑰確實屬於 Alice：

方法：
a) 使用數位證書
   - 檢查證書上的簽名
   - 驗證證書頒發機構（CA）
   - 確認證書未過期或被撤銷

b) 帶外驗證
   - 電話確認公鑰指紋
   - 面對面驗證
   - 使用已建立的信任關係

c) 區塊鏈/公開帳本
   - 查詢公開記錄
   - 多方驗證

如果跳過這步 → 中間人攻擊風險！
```

```
步驟 3：驗證簽章格式
檢查簽章有效性：
- 1 ≤ r < n？
- 1 ≤ s < n？
- 公鑰 Q_A 在曲線上？
- Q_A ≠ 𝒪？
```

```
步驟 4：計算訊息雜湊
z = Hash(合約內容)

重要：
- 使用與簽署相同的雜湊函數
- 對完全相同的合約內容雜湊
- 任何差異都會導致驗證失敗
```

```
步驟 5：執行 ECDSA 驗證
1. 計算 w = s⁻¹ mod n
2. 計算 u₁ = z·w mod n
3. 計算 u₂ = r·w mod n
4. 計算驗證點 (x₁, y₁) = u₁×G + u₂×Q_A
5. 檢查：r ≡ x₁ mod n？
```

```
步驟 6：驗證結果處理
if r ≡ x₁ mod n:
    ✓ 簽章有效
    ✓ 合約確實由 Alice 簽署
    ✓ 合約內容未被修改
    ✓ 可以接受合約
else:
    ✗ 簽章無效
    ✗ 可能的原因：
      - 合約被篡改
      - 簽章不是 Alice 生成的
      - 公鑰錯誤
      - 簽章損壞
    ✗ 拒絕合約
```

---

**c) 合約被篡改的後果（5分）**

**場景：攻擊者修改了一個字**

```
原始合約：
"Alice 同意支付 $1000 給 Bob"

篡改後：
"Alice 同意支付 $9000 給 Bob"
                    ^
                    只改了一個數字
```

**驗證時發生的事：**

```
步驟 1：計算新的雜湊
z' = Hash("Alice 同意支付 $9000 給 Bob")

由於雜湊函數的特性：
z' ≠ z（完全不同！）

例如：
z  = 0x3a7bd3e2...
z' = 0x8f2c91a4...
（完全不同的值）
```

```
步驟 2：驗證計算
使用 z' 進行驗證：

w = s⁻¹ mod n
u₁ = z'·w mod n  ← 注意：使用 z' 而不是 z
u₂ = r·w mod n
(x₁, y₁) = u₁×G + u₂×Q_A
```

```
步驟 3：驗證失敗
因為簽章是用原始的 z 計算的：
s = k⁻¹(z + r·d) mod n

但驗證時使用的是 z'：
驗證點 = s⁻¹(z' + r·d)×G

數學上：
z ≠ z' → 驗證點 ≠ 簽章點 → x₁ ≠ r

結果：r ≢ x₁ mod n

驗證失敗！✗
```

**Bob 看到的結果：**

```
錯誤：簽章驗證失敗

可能原因：
1. 合約內容被篡改
2. 簽章損壞或偽造
3. 使用了錯誤的公鑰

建議：
- 拒絕該合約
- 聯繫 Alice 確認
- 請求重新發送
- 檢查數據完整性
```

**為什麼即使一個字也會被檢測到：**

```
1. 雜湊函數的敏感性（雪崩效應）
   即使改變一個位元，雜湊值也會
   完全不同（約 50% 的位元翻轉）

2. 數學的嚴格性
   簽章驗證是精確的數學檢查
   不是模糊的相似度比較

3. 密碼學的安全性
   這正是數位簽章的核心價值：
   提供完美的完整性保護
```

**實際意義：**

```
✓ Bob 可以完全信任：
  - 如果驗證通過，合約100%未被修改
  - 如果驗證失敗，合約可能被篡改

✓ 攻擊者無法：
  - 修改合約而不被發現
  - 生成有效的簽章（沒有私鑰）
  - 繞過驗證機制

✓ 這提供了比傳統簽名更強的保障
```

---

**評分標準（15分）：**
- a) Alice 的簽署步驟（5分）
  - 計算雜湊（1分）
  - 生成簽章（2分）
  - 組合和發送（2分）
- b) Bob 的驗證方法（5分）
  - 驗證公鑰真實性（2分）
  - 執行 ECDSA 驗證（2分）
  - 處理結果（1分）
- c) 篡改的後果（5分）
  - 雜湊值改變（2分）
  - 驗證失敗（2分）
  - 解釋原因（1分）

---

## 🎓 測驗總結

### 完成課程

恭喜您完成了整個 ECDSA 課程的最終測驗！

**您已經掌握：**
```
✓ 數位簽章的核心概念
✓ 橢圓曲線的數學基礎
✓ ECDSA 的完整流程
✓ 手算和驗證能力
✓ 安全性分析技能
✓ 實際應用知識
```

### 學習成果

**如果得分 90 分以上：**
🎉 優秀！您已經完全掌握了 ECDSA
- 可以開始實際項目開發
- 可以參與密碼學相關工作
- 準備好學習進階主題

**如果得分 70-89 分：**
👍 良好！您有扎實的基礎
- 建議復習薄弱環節
- 多做實踐項目
- 繼續深化理解

**如果得分 60-69 分：**
📚 及格，但需要加強
- 重新學習不確定的部分
- 多做計算練習
- 加強實際應用理解

### 後續學習建議

**實踐項目：**
```
1. 實現完整的 ECDSA 庫
2. 開發簽名驗證工具
3. 分析實際的區塊鏈交易
4. 參與開源密碼學項目
```

**進階學習：**
```
1. 其他簽名方案
   - Schnorr 簽名
   - BLS 簽名
   - 門限簽名

2. 零知識證明
   - zk-SNARKs
   - zk-STARKs

3. 後量子密碼學
   - 格基密碼學
   - 基於哈希的簽名
   - 多變量密碼學
```

**職業發展：**
```
✓ 區塊鏈開發者
✓ 密碼學工程師
✓ 安全研究員
✓ 協議設計師
```

---

**恭喜您完成整個 ECDSA 入門課程！**

您現在已經具備了紮實的橢圓曲線數位簽名知識，
準備好在密碼學和區塊鏈領域大展身手了！

**繼續探索，持續學習！** 🚀✨

