# 第一課：留言板合約的資料結構設計

## 🎯 學習目標

完成本課後，您將能夠：
- 理解不同資料結構設計方案的優缺點
- 學會根據應用場景設計最優的合約資料結構
- 掌握 Solidity 中 struct、array、mapping 的最佳實踐
- 為可擴展的 DApp 奠定堅實的合約基礎

## 📋 課程大綱

1. [簡單方案 vs 結構化方案](#簡單方案-vs-結構化方案)
2. [資料結構設計原則](#資料結構設計原則)
3. [Message Struct 設計詳解](#message-struct-設計詳解)
4. [Gas 優化考量](#gas-優化考量)
5. [可擴展性設計](#可擴展性設計)

---

## 簡單方案 vs 結構化方案

### 🔸 方案一：簡單字串陣列

```solidity
contract SimpleMessageBoard {
    string[] public messages;
    
    function postMessage(string memory _message) public {
        messages.push(_message);
    }
    
    function getAllMessages() public view returns (string[] memory) {
        return messages;
    }
}
```

**優點：**
- 程式碼簡潔
- 實作快速
- 概念直觀

**缺點：**
- 無法知道是誰發送的留言
- 無法記錄留言時間
- 難以實現進階功能（如留言回覆、按讚等）
- 不利於未來擴展

### 🔸 方案二：結構化設計

```solidity
contract StructuredMessageBoard {
    struct Message {
        address sender;        // 發送者地址
        uint256 timestamp;     // 發送時間戳
        string ipfsCid;       // IPFS 內容識別碼
        uint256 likes;        // 按讚數量（可選）
        bool isActive;        // 訊息狀態（可選）
    }
    
    Message[] public messages;
    
    function postMessage(string memory _ipfsCid) public {
        Message memory newMessage = Message({
            sender: msg.sender,
            timestamp: block.timestamp,
            ipfsCid: _ipfsCid,
            likes: 0,
            isActive: true
        });
        
        messages.push(newMessage);
    }
    
    function getAllMessages() public view returns (Message[] memory) {
        return messages;
    }
}
```

**優點：**
- 豐富的鏈上資料
- 支援複雜功能實現
- 良好的可擴展性
- 便於前端處理和展示

**缺點：**
- 程式碼稍微複雜
- Gas 消耗略高（但差異很小）

---

## 資料結構設計原則

### 🎯 **原則一：最小夠用原則**

只在鏈上儲存必要的資料，避免不必要的 Gas 消耗：

```solidity
// ❌ 過度設計
struct Message {
    address sender;
    uint256 timestamp;
    string ipfsCid;
    string title;           // 應該放在 IPFS 中
    string content;         // 應該放在 IPFS 中
    string authorName;      // 應該放在 IPFS 中
    string[] tags;          // 應該放在 IPFS 中
}

// ✅ 精簡設計
struct Message {
    address sender;         // 鏈上驗證需要
    uint256 timestamp;      // 鏈上排序需要
    string ipfsCid;        // 連結 IPFS 內容
}
```

### 🎯 **原則二：未來擴展考量**

設計時考慮未來可能的功能需求：

```solidity
// ✅ 具有擴展性的設計
struct Message {
    address sender;
    uint256 timestamp;
    string ipfsCid;
    uint256 likes;          // 未來可實現按讚功能
    uint256 replies;        // 未來可實現回覆計數
    bool isActive;          // 未來可實現訊息狀態管理
}
```

### 🎯 **原則三：Gas 效率優化**

合理安排 struct 成員順序，利用 Storage Packing：

```solidity
// ❌ 未優化的順序
struct Message {
    bool isActive;      // 1 byte
    address sender;     // 20 bytes  -> 新的 slot
    uint256 timestamp;  // 32 bytes  -> 新的 slot
    string ipfsCid;     // dynamic   -> 新的 slot
}
// 總共使用 4 個 storage slots

// ✅ 優化後的順序  
struct Message {
    address sender;     // 20 bytes
    bool isActive;      // 1 byte    -> 同一個 slot
    uint256 timestamp;  // 32 bytes  -> 新的 slot
    string ipfsCid;     // dynamic   -> 新的 slot
}
// 總共使用 3 個 storage slots，節省 Gas
```

---

## Message Struct 設計詳解

### 🏗️ 核心版本（推薦用於課程）

```solidity
struct Message {
    address sender;        // 發送者地址
    uint256 timestamp;     // 發送時間戳
    string ipfsCid;       // IPFS 內容識別碼
}
```

**各欄位說明：**

#### **`address sender`**
- **用途**：記錄留言發送者
- **為什麼需要**：
  - 前端可以顯示「由 0x1234... 發送」
  - 可以實現使用者個人頁面
  - 為未來的權限控制功能打基礎

#### **`uint256 timestamp`**
- **用途**：記錄留言發送時間
- **為什麼需要**：
  - 前端可以顯示「發送於 2023/12/25 10:30」
  - 可以按時間排序留言
  - 為未來的時間範圍查詢打基礎

#### **`string ipfsCid`**
- **用途**：連結到 IPFS 儲存的實際內容
- **為什麼用 string**：
  - CID 的長度可能變化（不同的雜湊演算法）
  - 便於前端處理
  - 支援未來的 CID 格式升級

### 🔧 擴展版本（適合進階需求）

```solidity
struct Message {
    address sender;
    uint256 timestamp;
    string ipfsCid;
    uint256 likes;         // 按讚數量
    uint256 replyCount;    // 回覆數量
    bool isActive;         // 訊息是否啟用
    uint256 messageId;     // 訊息唯一 ID
}
```

---

## Gas 優化考量

### ⛽ **Storage vs Memory vs Calldata**

```solidity
// ✅ 正確的參數使用
function postMessage(string calldata _ipfsCid) public {
    // 使用 calldata 節省 Gas（外部呼叫時）
}

function getAllMessages() public view returns (Message[] memory) {
    // 返回時使用 memory
}

// ✅ 內部處理優化
function postMessage(string calldata _ipfsCid) public {
    Message memory newMessage = Message({
        sender: msg.sender,
        timestamp: block.timestamp,
        ipfsCid: _ipfsCid
    });
    // 先在 memory 中構建，再一次性寫入 storage
    messages.push(newMessage);
}
```

### ⛽ **事件使用優化**

善用事件來減少 Storage 讀取：

```solidity
event MessagePosted(
    uint256 indexed messageId,
    address indexed sender,
    uint256 timestamp,
    string ipfsCid
);

function postMessage(string calldata _ipfsCid) public {
    uint256 messageId = messages.length;
    
    Message memory newMessage = Message({
        sender: msg.sender,
        timestamp: block.timestamp,
        ipfsCid: _ipfsCid
    });
    
    messages.push(newMessage);
    
    // 發出事件，前端可以監聽而不需要輪詢
    emit MessagePosted(messageId, msg.sender, block.timestamp, _ipfsCid);
}
```

---

## 可擴展性設計

### 🚀 **支援回覆功能的設計**

```solidity
struct Message {
    address sender;
    uint256 timestamp;
    string ipfsCid;
    uint256 replyToId;     // 回覆哪一則訊息（0 表示原始留言）
    uint256[] replies;     // 此訊息的回覆列表
}
```

### 🚀 **支援使用者資料的設計**

```solidity
struct UserProfile {
    string profileCid;     // 使用者資料的 IPFS CID
    uint256 messageCount;  // 發送的訊息數量
    bool isVerified;       // 是否為驗證使用者
}

mapping(address => UserProfile) public userProfiles;
```

### 🚀 **支援留言分類的設計**

```solidity
struct Message {
    address sender;
    uint256 timestamp;
    string ipfsCid;
    uint256 categoryId;    // 留言分類
}

struct Category {
    string name;
    string description;
    bool isActive;
}

Category[] public categories;
```

---

## 💡 實作建議

### **階段式開發策略**

1. **第一階段**：實作核心版本
   ```solidity
   struct Message {
       address sender;
       uint256 timestamp;
       string ipfsCid;
   }
   ```

2. **第二階段**：根據需求添加功能
   ```solidity
   struct Message {
       address sender;
       uint256 timestamp;
       string ipfsCid;
       uint256 likes;     // 添加按讚功能
   }
   ```

3. **第三階段**：實現複雜功能
   ```solidity
   // 添加回覆、分類等進階功能
   ```

### **資料驗證策略**

```solidity
// ✅ 添加必要的驗證
function postMessage(string calldata _ipfsCid) public {
    require(bytes(_ipfsCid).length > 0, "CID cannot be empty");
    require(bytes(_ipfsCid).length < 100, "CID too long");
    
    // 可選：驗證 CID 格式
    require(isValidCid(_ipfsCid), "Invalid CID format");
    
    // ... 其餘邏輯
}
```

---

## 📝 本課總結

### **關鍵要點**

1. **結構化設計優於簡單設計**：雖然複雜度略增，但可擴展性大幅提升
2. **最小夠用原則**：只在鏈上儲存必要資料，其餘放在 IPFS
3. **Gas 優化**：合理安排 struct 順序，善用 events
4. **未來規劃**：設計時考慮可能的功能擴展

### **下一課預告**

在下一課中，我們將把這個設計實際實作出來，在 Scaffold-eth-2 專案中撰寫完整的 `MessageBoard.sol` 合約！

---

## 🔗 延伸閱讀

- [Solidity Storage Layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html)
- [Gas 優化最佳實踐](https://github.com/iskdrews/awesome-solidity-gas-optimization)
- [Ethereum 資料結構設計模式](https://soliditydeveloper.com/solidity-design-patterns)

**下一課：** [第二課：【實作】在 Scaffold-eth-2 中撰寫留言板合約](第二課-在Scaffold-eth-2中撰寫留言板合約.md)
