# 第四課：【實作】讀取並展示留言板內容

## 🎯 學習目標

完成本課後，您將能夠：
- 使用 useScaffoldContractRead Hook 讀取智能合約資料
- 實作從 IPFS 獲取並解析 JSON 內容的邏輯
- 建立響應式的留言列表介面
- 處理載入狀態和錯誤情況
- 實現自動重新整理和即時更新

## 📋 課程大綱

1. [智能合約資料讀取](#智能合約資料讀取)
2. [IPFS 內容獲取與解析](#ipfs-內容獲取與解析)
3. [留言列表介面設計](#留言列表介面設計)
4. [載入狀態與錯誤處理](#載入狀態與錯誤處理)
5. [效能優化與快取策略](#效能優化與快取策略)

---

## 智能合約資料讀取

### 📖 **使用 Scaffold-eth-2 讀取合約**

首先，我們需要從智能合約讀取所有留言的基本資訊：

```typescript
// packages/nextjs/hooks/useMessages.ts
import { useState, useEffect, useCallback } from 'react';
import { useScaffoldContractRead } from '~~/hooks/scaffold-eth';

export interface OnChainMessage {
  sender: string;
  timestamp: number;
  ipfsCid: string;
  messageId: number;
}

export interface MessageWithContent extends OnChainMessage {
  content?: {
    text: string;
    author?: string;
    title?: string;
    tags?: string[];
    createdAt: string;
    version: string;
  };
  isLoading?: boolean;
  hasError?: boolean;
  errorMessage?: string;
}

export const useMessages = () => {
  const [messages, setMessages] = useState<MessageWithContent[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // 從智能合約讀取所有留言
  const { 
    data: onChainMessages,
    isLoading: contractLoading,
    error: contractError,
    refetch: refetchMessages
  } = useScaffoldContractRead({
    contractName: 'MessageBoard',
    functionName: 'getAllMessages',
    watch: true, // 自動監聽合約變化
  });

  // 處理合約資料變化
  useEffect(() => {
    if (contractLoading) {
      setIsLoading(true);
      return;
    }

    if (contractError) {
      setError('讀取合約資料失敗: ' + contractError.message);
      setIsLoading(false);
      return;
    }

    if (onChainMessages) {
      console.log('📋 讀取到合約資料:', onChainMessages);
      
      // 轉換格式並設定初始狀態
      const formattedMessages: MessageWithContent[] = (onChainMessages as any[])
        .map((msg, index) => ({
          sender: msg.sender,
          timestamp: Number(msg.timestamp),
          ipfsCid: msg.ipfsCid,
          messageId: Number(msg.messageId || index),
          isLoading: true, // 初始設為載入中
          hasError: false,
        }))
        .reverse(); // 最新的在前面

      setMessages(formattedMessages);
      setError(null);
    }

    setIsLoading(false);
  }, [onChainMessages, contractLoading, contractError]);

  // 手動重新整理
  const refresh = useCallback(() => {
    refetchMessages();
  }, [refetchMessages]);

  return {
    messages,
    isLoading,
    error,
    refresh,
  };
};
```

### 📖 **優化的合約讀取策略**

對於大量留言的情況，我們可以實作分頁讀取：

```typescript
// packages/nextjs/hooks/usePaginatedMessages.ts
import { useState, useCallback } from 'react';
import { useScaffoldContractRead } from '~~/hooks/scaffold-eth';

interface PaginationConfig {
  pageSize: number;
  initialPage: number;
}

export const usePaginatedMessages = (config: PaginationConfig = {
  pageSize: 10,
  initialPage: 0,
}) => {
  const [currentPage, setCurrentPage] = useState(config.initialPage);

  // 讀取留言總數
  const { data: totalMessages } = useScaffoldContractRead({
    contractName: 'MessageBoard',
    functionName: 'getTotalMessages',
    watch: true,
  });

  // 讀取最新的 N 則留言
  const { 
    data: latestMessages,
    isLoading,
    error,
    refetch
  } = useScaffoldContractRead({
    contractName: 'MessageBoard',
    functionName: 'getLatestMessages',
    args: [BigInt(config.pageSize * (currentPage + 1))],
    watch: true,
  });

  const totalPages = totalMessages ? 
    Math.ceil(Number(totalMessages) / config.pageSize) : 0;

  const nextPage = useCallback(() => {
    if (currentPage < totalPages - 1) {
      setCurrentPage(prev => prev + 1);
    }
  }, [currentPage, totalPages]);

  const prevPage = useCallback(() => {
    if (currentPage > 0) {
      setCurrentPage(prev => prev - 1);
    }
  }, [currentPage]);

  const goToPage = useCallback((page: number) => {
    if (page >= 0 && page < totalPages) {
      setCurrentPage(page);
    }
  }, [totalPages]);

  // 計算當前頁面的留言
  const currentPageMessages = latestMessages ? 
    (latestMessages as any[]).slice(
      currentPage * config.pageSize,
      (currentPage + 1) * config.pageSize
    ) : [];

  return {
    messages: currentPageMessages,
    isLoading,
    error,
    currentPage,
    totalPages,
    totalMessages: Number(totalMessages || 0),
    nextPage,
    prevPage,
    goToPage,
    refresh: refetch,
  };
};
```

---

## IPFS 內容獲取與解析

### 🌐 **IPFS 內容獲取 Hook**

建立專門處理 IPFS 內容獲取的 Hook：

```typescript
// packages/nextjs/hooks/useIPFSContent.ts
import { useState, useEffect, useCallback } from 'react';
import config from '~~/config/app';

interface IPFSContent {
  text: string;
  author?: string;
  title?: string;
  tags?: string[];
  createdAt: string;
  version: string;
}

interface UseIPFSContentResult {
  content: IPFSContent | null;
  isLoading: boolean;
  error: string | null;
  retry: () => void;
}

export const useIPFSContent = (cid: string): UseIPFSContentResult => {
  const [content, setContent] = useState<IPFSContent | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchContent = useCallback(async () => {
    if (!cid) return;

    setIsLoading(true);
    setError(null);

    try {
      // 構建 IPFS Gateway URL
      const gatewayUrl = `${config.pinata.gatewayUrl}/ipfs/${cid}`;
      
      console.log(`📥 從 IPFS 獲取內容: ${cid}`);
      
      const response = await fetch(gatewayUrl, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
        },
        // 5 秒超時
        signal: AbortSignal.timeout(5000),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: 無法獲取 IPFS 內容`);
      }

      const contentType = response.headers.get('content-type');
      if (!contentType?.includes('application/json')) {
        throw new Error('IPFS 內容不是有效的 JSON 格式');
      }

      const data = await response.json();
      
      // 驗證資料格式
      if (!data.text) {
        throw new Error('IPFS 內容缺少必要的 text 欄位');
      }

      console.log(`✅ 成功獲取 IPFS 內容: ${cid.substring(0, 10)}...`);
      setContent(data);

    } catch (err: any) {
      console.error(`❌ 獲取 IPFS 內容失敗 (${cid}):`, err);
      
      if (err.name === 'AbortError') {
        setError('請求超時，請檢查網路連線');
      } else if (err.message.includes('HTTP 404')) {
        setError('內容未找到，可能已被移除');
      } else {
        setError(err.message || 'IPFS 內容獲取失敗');
      }
    } finally {
      setIsLoading(false);
    }
  }, [cid]);

  const retry = useCallback(() => {
    fetchContent();
  }, [fetchContent]);

  useEffect(() => {
    if (cid) {
      fetchContent();
    }
  }, [fetchContent, cid]);

  return {
    content,
    isLoading,
    error,
    retry,
  };
};
```

### 🌐 **批次 IPFS 內容獲取**

為了優化效能，我們可以批次獲取多個 IPFS 內容：

```typescript
// packages/nextjs/hooks/useBatchIPFSContent.ts
import { useState, useEffect, useCallback } from 'react';
import config from '~~/config/app';

interface BatchResult {
  [cid: string]: {
    content: any | null;
    isLoading: boolean;
    error: string | null;
  };
}

export const useBatchIPFSContent = (cids: string[]) => {
  const [results, setResults] = useState<BatchResult>({});

  const fetchContent = useCallback(async (cid: string) => {
    try {
      const gatewayUrl = `${config.pinata.gatewayUrl}/ipfs/${cid}`;
      const response = await fetch(gatewayUrl, {
        signal: AbortSignal.timeout(10000),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();
      return { content: data, error: null };
    } catch (error: any) {
      return { content: null, error: error.message };
    }
  }, []);

  const fetchBatch = useCallback(async (cidList: string[]) => {
    // 設定初始載入狀態
    const initialState: BatchResult = {};
    cidList.forEach(cid => {
      initialState[cid] = {
        content: null,
        isLoading: true,
        error: null,
      };
    });
    setResults(initialState);

    // 並行獲取所有內容
    const promises = cidList.map(async (cid) => {
      const result = await fetchContent(cid);
      return { cid, ...result };
    });

    const batchResults = await Promise.all(promises);

    // 更新結果
    const finalResults: BatchResult = {};
    batchResults.forEach(({ cid, content, error }) => {
      finalResults[cid] = {
        content,
        isLoading: false,
        error,
      };
    });

    setResults(finalResults);
  }, [fetchContent]);

  useEffect(() => {
    if (cids.length > 0) {
      fetchBatch(cids);
    }
  }, [cids, fetchBatch]);

  return results;
};
```

---

## 留言列表介面設計

### 🎨 **MessageCard 元件**

建立單則留言的顯示卡片：

```typescript
// packages/nextjs/components/MessageCard.tsx
import React from 'react';
import { MessageWithContent } from '~~/hooks/useMessages';
import { useIPFSContent } from '~~/hooks/useIPFSContent';

interface MessageCardProps {
  message: MessageWithContent;
}

export const MessageCard: React.FC<MessageCardProps> = ({ message }) => {
  const { content, isLoading, error, retry } = useIPFSContent(message.ipfsCid);

  const formatTimestamp = (timestamp: number) => {
    return new Date(timestamp * 1000).toLocaleString('zh-TW', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const formatAddress = (address: string) => {
    return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-6 mb-4 transition-all hover:shadow-lg">
      {/* 標題區域 */}
      <div className="flex justify-between items-start mb-4">
        <div>
          {content?.title && (
            <h3 className="text-lg font-semibold text-gray-900 mb-2">
              {content.title}
            </h3>
          )}
          <div className="flex items-center space-x-4 text-sm text-gray-500">
            <span className="flex items-center">
              👤 {content?.author || formatAddress(message.sender)}
            </span>
            <span className="flex items-center">
              🕒 {formatTimestamp(message.timestamp)}
            </span>
            <span className="text-xs bg-gray-100 px-2 py-1 rounded">
              #{message.messageId}
            </span>
          </div>
        </div>
        
        {/* CID 顯示 */}
        <div className="text-xs text-gray-400">
          <span className="font-mono bg-gray-50 px-2 py-1 rounded">
            {message.ipfsCid.substring(0, 10)}...
          </span>
        </div>
      </div>

      {/* 內容區域 */}
      <div className="mb-4">
        {isLoading ? (
          <div className="animate-pulse">
            <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
            <div className="h-4 bg-gray-200 rounded w-1/2"></div>
          </div>
        ) : error ? (
          <div className="bg-red-50 border border-red-200 rounded-md p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-red-700 text-sm">⚠️ 載入內容失敗</p>
                <p className="text-red-600 text-xs mt-1">{error}</p>
              </div>
              <button
                onClick={retry}
                className="text-red-600 hover:text-red-800 text-sm underline"
              >
                重試
              </button>
            </div>
          </div>
        ) : content ? (
          <div>
            <p className="text-gray-800 leading-relaxed whitespace-pre-wrap">
              {content.text}
            </p>
          </div>
        ) : null}
      </div>

      {/* 標籤區域 */}
      {content?.tags && content.tags.length > 0 && (
        <div className="flex flex-wrap gap-2 mb-3">
          {content.tags.map((tag, index) => (
            <span
              key={index}
              className="inline-block bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full"
            >
              #{tag}
            </span>
          ))}
        </div>
      )}

      {/* 底部資訊 */}
      <div className="border-t pt-3 flex justify-between items-center text-xs text-gray-400">
        <div className="flex space-x-4">
          <span>發送者: {formatAddress(message.sender)}</span>
          {content?.createdAt && (
            <span>建立: {new Date(content.createdAt).toLocaleDateString('zh-TW')}</span>
          )}
        </div>
        <div className="flex items-center space-x-2">
          <span>🔗 IPFS</span>
          <a
            href={`https://gateway.pinata.cloud/ipfs/${message.ipfsCid}`}
            target="_blank"
            rel="noopener noreferrer"
            className="text-blue-500 hover:text-blue-700 underline"
          >
            查看原始內容
          </a>
        </div>
      </div>
    </div>
  );
};
```

### 🎨 **MessageList 元件**

建立留言列表容器元件：

```typescript
// packages/nextjs/components/MessageList.tsx
import React, { useState } from 'react';
import { MessageCard } from './MessageCard';
import { useMessages } from '~~/hooks/useMessages';

export const MessageList: React.FC = () => {
  const { messages, isLoading, error, refresh } = useMessages();
  const [autoRefresh, setAutoRefresh] = useState(true);

  // 自動重新整理 (每 30 秒)
  React.useEffect(() => {
    if (!autoRefresh) return;

    const interval = setInterval(() => {
      refresh();
    }, 30000);

    return () => clearInterval(interval);
  }, [autoRefresh, refresh]);

  if (isLoading && messages.length === 0) {
    return (
      <div className="space-y-4">
        {/* 載入骨架 */}
        {[...Array(3)].map((_, index) => (
          <div key={index} className="bg-white rounded-lg shadow-md p-6 animate-pulse">
            <div className="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
            <div className="space-y-2">
              <div className="h-4 bg-gray-200 rounded w-3/4"></div>
              <div className="h-4 bg-gray-200 rounded w-1/2"></div>
            </div>
          </div>
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-6 text-center">
        <h3 className="text-lg font-semibold text-red-800 mb-2">載入失敗</h3>
        <p className="text-red-600 mb-4">{error}</p>
        <button
          onClick={refresh}
          className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 transition-colors"
        >
          重新載入
        </button>
      </div>
    );
  }

  if (messages.length === 0) {
    return (
      <div className="bg-gray-50 border-2 border-dashed border-gray-300 rounded-lg p-12 text-center">
        <div className="text-6xl mb-4">💬</div>
        <h3 className="text-lg font-semibold text-gray-700 mb-2">還沒有留言</h3>
        <p className="text-gray-500 mb-4">成為第一個在這個去中心化留言板上發言的人！</p>
        <button
          onClick={refresh}
          className="text-blue-600 hover:text-blue-800 underline"
        >
          重新檢查
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* 控制面板 */}
      <div className="bg-white rounded-lg shadow-sm p-4 flex justify-between items-center">
        <div className="flex items-center space-x-4">
          <span className="text-sm text-gray-600">
            共 {messages.length} 則留言
          </span>
          {isLoading && (
            <span className="text-sm text-blue-600 flex items-center">
              <div className="animate-spin w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full mr-2"></div>
              更新中...
            </span>
          )}
        </div>
        
        <div className="flex items-center space-x-3">
          <label className="flex items-center text-sm text-gray-600">
            <input
              type="checkbox"
              checked={autoRefresh}
              onChange={(e) => setAutoRefresh(e.target.checked)}
              className="mr-2"
            />
            自動重新整理
          </label>
          
          <button
            onClick={refresh}
            className="text-blue-600 hover:text-blue-800 text-sm px-3 py-1 border border-blue-300 rounded-md hover:bg-blue-50 transition-colors"
          >
            🔄 手動重新整理
          </button>
        </div>
      </div>

      {/* 留言列表 */}
      <div className="space-y-4">
        {messages.map((message) => (
          <MessageCard key={message.messageId} message={message} />
        ))}
      </div>

      {/* 載入更多 (如果使用分頁) */}
      {messages.length > 0 && (
        <div className="text-center py-8">
          <p className="text-gray-500 text-sm">
            💡 提示：新留言會自動出現在頂部
          </p>
        </div>
      )}
    </div>
  );
};
```

---

## 載入狀態與錯誤處理

### 🔄 **載入狀態管理**

建立統一的載入狀態元件：

```typescript
// packages/nextjs/components/LoadingStates.tsx
import React from 'react';

export const SkeletonCard: React.FC = () => (
  <div className="bg-white rounded-lg shadow-md p-6 animate-pulse">
    <div className="flex justify-between items-start mb-4">
      <div className="space-y-2">
        <div className="h-5 bg-gray-200 rounded w-32"></div>
        <div className="h-4 bg-gray-200 rounded w-48"></div>
      </div>
      <div className="h-4 bg-gray-200 rounded w-20"></div>
    </div>
    
    <div className="space-y-2 mb-4">
      <div className="h-4 bg-gray-200 rounded w-full"></div>
      <div className="h-4 bg-gray-200 rounded w-3/4"></div>
      <div className="h-4 bg-gray-200 rounded w-1/2"></div>
    </div>
    
    <div className="flex space-x-2 mb-3">
      <div className="h-6 bg-gray-200 rounded-full w-16"></div>
      <div className="h-6 bg-gray-200 rounded-full w-20"></div>
    </div>
    
    <div className="border-t pt-3">
      <div className="h-3 bg-gray-200 rounded w-2/3"></div>
    </div>
  </div>
);

export const LoadingSpinner: React.FC<{ size?: 'sm' | 'md' | 'lg' }> = ({ 
  size = 'md' 
}) => {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
  };

  return (
    <div className="flex justify-center items-center p-8">
      <div className={`${sizeClasses[size]} border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin`}>
      </div>
    </div>
  );
};

export const EmptyState: React.FC<{
  icon?: string;
  title: string;
  description: string;
  action?: {
    label: string;
    onClick: () => void;
  };
}> = ({ icon = '📭', title, description, action }) => (
  <div className="bg-gray-50 border-2 border-dashed border-gray-300 rounded-lg p-12 text-center">
    <div className="text-6xl mb-4">{icon}</div>
    <h3 className="text-lg font-semibold text-gray-700 mb-2">{title}</h3>
    <p className="text-gray-500 mb-4">{description}</p>
    {action && (
      <button
        onClick={action.onClick}
        className="text-blue-600 hover:text-blue-800 underline"
      >
        {action.label}
      </button>
    )}
  </div>
);
```

### 🔄 **錯誤邊界元件**

```typescript
// packages/nextjs/components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  private handleRetry = () => {
    this.setState({ hasError: false, error: undefined });
  };

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="bg-red-50 border border-red-200 rounded-lg p-6 text-center">
          <div className="text-6xl mb-4">⚠️</div>
          <h3 className="text-lg font-semibold text-red-800 mb-2">發生錯誤</h3>
          <p className="text-red-600 mb-4">
            {this.state.error?.message || '應用程式遇到未預期的錯誤'}
          </p>
          <button
            onClick={this.handleRetry}
            className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 transition-colors mr-3"
          >
            重試
          </button>
          <button
            onClick={() => window.location.reload()}
            className="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 transition-colors"
          >
            重新載入頁面
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

---

## 效能優化與快取策略

### ⚡ **記憶體快取實作**

```typescript
// packages/nextjs/utils/cache.ts
interface CacheItem<T> {
  data: T;
  timestamp: number;
  expiry: number;
}

class MemoryCache {
  private cache = new Map<string, CacheItem<any>>();
  private defaultTTL = 5 * 60 * 1000; // 5 分鐘

  set<T>(key: string, data: T, ttl?: number): void {
    const expiry = Date.now() + (ttl || this.defaultTTL);
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      expiry,
    });
  }

  get<T>(key: string): T | null {
    const item = this.cache.get(key);
    
    if (!item) {
      return null;
    }

    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }

    return item.data;
  }

  has(key: string): boolean {
    const item = this.cache.get(key);
    
    if (!item) {
      return false;
    }

    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }
}

export const ipfsCache = new MemoryCache();
```

### ⚡ **優化的 IPFS Hook**

```typescript
// packages/nextjs/hooks/useIPFSContentWithCache.ts
import { useState, useEffect, useCallback } from 'react';
import { ipfsCache } from '~~/utils/cache';
import config from '~~/config/app';

export const useIPFSContentWithCache = (cid: string) => {
  const [content, setContent] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchContent = useCallback(async () => {
    if (!cid) return;

    // 檢查快取
    const cached = ipfsCache.get(cid);
    if (cached) {
      console.log(`💾 從快取獲取內容: ${cid}`);
      setContent(cached);
      setError(null);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const gatewayUrl = `${config.pinata.gatewayUrl}/ipfs/${cid}`;
      
      const response = await fetch(gatewayUrl, {
        signal: AbortSignal.timeout(10000),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: 無法獲取 IPFS 內容`);
      }

      const data = await response.json();
      
      // 儲存到快取
      ipfsCache.set(cid, data);
      
      console.log(`✅ 成功獲取並快取 IPFS 內容: ${cid}`);
      setContent(data);

    } catch (err: any) {
      console.error(`❌ 獲取 IPFS 內容失敗 (${cid}):`, err);
      setError(err.message || 'IPFS 內容獲取失敗');
    } finally {
      setIsLoading(false);
    }
  }, [cid]);

  useEffect(() => {
    fetchContent();
  }, [fetchContent]);

  return {
    content,
    isLoading,
    error,
    retry: fetchContent,
  };
};
```

---

## 📝 本課總結

### **已完成的功能**

1. ✅ **智能合約資料讀取**：使用 Scaffold-eth-2 Hooks 讀取留言資料
2. ✅ **IPFS 內容解析**：從 IPFS Gateway 獲取並解析 JSON 內容
3. ✅ **響應式 UI 介面**：美觀的留言卡片和列表設計
4. ✅ **載入狀態管理**：骨架載入、錯誤邊界、空狀態處理
5. ✅ **效能優化**：記憶體快取、批次獲取、自動重新整理

### **關鍵學習點**

1. **資料流整合**：區塊鏈 ↔ IPFS ↔ 前端的完整資料流
2. **使用者體驗**：載入狀態、錯誤處理、自動更新
3. **效能優化**：快取策略、批次處理、記憶體管理
4. **錯誤處理**：優雅的錯誤顯示和重試機制

### **下一步規劃**

您現在已經完成了一個功能完整的去中心化留言板！接下來可以考慮：

1. **部署到測試網**：將 DApp 部署到公開的測試網路
2. **新增功能**：留言回覆、按讚、使用者資料等
3. **UI/UX 改進**：更好的響應式設計、暗色模式等
4. **效能優化**：虛擬滾動、無限載入等

---

## 🔗 延伸閱讀

- [React 效能優化指南](https://react.dev/learn/render-and-commit)
- [IPFS Gateway 最佳實踐](https://docs.ipfs.io/concepts/ipfs-gateway/)
- [Web3 前端架構設計](https://web3.storage/docs/how-tos/work-with-car-files/)

**恭喜您完成了整個 IPFS 到 DApp 的開發課程！** 🎉
