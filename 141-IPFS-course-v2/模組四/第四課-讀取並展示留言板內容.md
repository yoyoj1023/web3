# ç¬¬å››èª²ï¼šã€å¯¦ä½œã€‘è®€å–ä¸¦å±•ç¤ºç•™è¨€æ¿å…§å®¹

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬èª²å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š
- ä½¿ç”¨ useScaffoldContractRead Hook è®€å–æ™ºèƒ½åˆç´„è³‡æ–™
- å¯¦ä½œå¾ IPFS ç²å–ä¸¦è§£æ JSON å…§å®¹çš„é‚è¼¯
- å»ºç«‹éŸ¿æ‡‰å¼çš„ç•™è¨€åˆ—è¡¨ä»‹é¢
- è™•ç†è¼‰å…¥ç‹€æ…‹å’ŒéŒ¯èª¤æƒ…æ³
- å¯¦ç¾è‡ªå‹•é‡æ–°æ•´ç†å’Œå³æ™‚æ›´æ–°

## ğŸ“‹ èª²ç¨‹å¤§ç¶±

1. [æ™ºèƒ½åˆç´„è³‡æ–™è®€å–](#æ™ºèƒ½åˆç´„è³‡æ–™è®€å–)
2. [IPFS å…§å®¹ç²å–èˆ‡è§£æ](#ipfs-å…§å®¹ç²å–èˆ‡è§£æ)
3. [ç•™è¨€åˆ—è¡¨ä»‹é¢è¨­è¨ˆ](#ç•™è¨€åˆ—è¡¨ä»‹é¢è¨­è¨ˆ)
4. [è¼‰å…¥ç‹€æ…‹èˆ‡éŒ¯èª¤è™•ç†](#è¼‰å…¥ç‹€æ…‹èˆ‡éŒ¯èª¤è™•ç†)
5. [æ•ˆèƒ½å„ªåŒ–èˆ‡å¿«å–ç­–ç•¥](#æ•ˆèƒ½å„ªåŒ–èˆ‡å¿«å–ç­–ç•¥)

---

## æ™ºèƒ½åˆç´„è³‡æ–™è®€å–

### ğŸ“– **ä½¿ç”¨ Scaffold-eth-2 è®€å–åˆç´„**

é¦–å…ˆï¼Œæˆ‘å€‘éœ€è¦å¾æ™ºèƒ½åˆç´„è®€å–æ‰€æœ‰ç•™è¨€çš„åŸºæœ¬è³‡è¨Šï¼š

```typescript
// packages/nextjs/hooks/useMessages.ts
import { useState, useEffect, useCallback } from 'react';
import { useScaffoldContractRead } from '~~/hooks/scaffold-eth';

export interface OnChainMessage {
  sender: string;
  timestamp: number;
  ipfsCid: string;
  messageId: number;
}

export interface MessageWithContent extends OnChainMessage {
  content?: {
    text: string;
    author?: string;
    title?: string;
    tags?: string[];
    createdAt: string;
    version: string;
  };
  isLoading?: boolean;
  hasError?: boolean;
  errorMessage?: string;
}

export const useMessages = () => {
  const [messages, setMessages] = useState<MessageWithContent[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // å¾æ™ºèƒ½åˆç´„è®€å–æ‰€æœ‰ç•™è¨€
  const { 
    data: onChainMessages,
    isLoading: contractLoading,
    error: contractError,
    refetch: refetchMessages
  } = useScaffoldContractRead({
    contractName: 'MessageBoard',
    functionName: 'getAllMessages',
    watch: true, // è‡ªå‹•ç›£è½åˆç´„è®ŠåŒ–
  });

  // è™•ç†åˆç´„è³‡æ–™è®ŠåŒ–
  useEffect(() => {
    if (contractLoading) {
      setIsLoading(true);
      return;
    }

    if (contractError) {
      setError('è®€å–åˆç´„è³‡æ–™å¤±æ•—: ' + contractError.message);
      setIsLoading(false);
      return;
    }

    if (onChainMessages) {
      console.log('ğŸ“‹ è®€å–åˆ°åˆç´„è³‡æ–™:', onChainMessages);
      
      // è½‰æ›æ ¼å¼ä¸¦è¨­å®šåˆå§‹ç‹€æ…‹
      const formattedMessages: MessageWithContent[] = (onChainMessages as any[])
        .map((msg, index) => ({
          sender: msg.sender,
          timestamp: Number(msg.timestamp),
          ipfsCid: msg.ipfsCid,
          messageId: Number(msg.messageId || index),
          isLoading: true, // åˆå§‹è¨­ç‚ºè¼‰å…¥ä¸­
          hasError: false,
        }))
        .reverse(); // æœ€æ–°çš„åœ¨å‰é¢

      setMessages(formattedMessages);
      setError(null);
    }

    setIsLoading(false);
  }, [onChainMessages, contractLoading, contractError]);

  // æ‰‹å‹•é‡æ–°æ•´ç†
  const refresh = useCallback(() => {
    refetchMessages();
  }, [refetchMessages]);

  return {
    messages,
    isLoading,
    error,
    refresh,
  };
};
```

### ğŸ“– **å„ªåŒ–çš„åˆç´„è®€å–ç­–ç•¥**

å°æ–¼å¤§é‡ç•™è¨€çš„æƒ…æ³ï¼Œæˆ‘å€‘å¯ä»¥å¯¦ä½œåˆ†é è®€å–ï¼š

```typescript
// packages/nextjs/hooks/usePaginatedMessages.ts
import { useState, useCallback } from 'react';
import { useScaffoldContractRead } from '~~/hooks/scaffold-eth';

interface PaginationConfig {
  pageSize: number;
  initialPage: number;
}

export const usePaginatedMessages = (config: PaginationConfig = {
  pageSize: 10,
  initialPage: 0,
}) => {
  const [currentPage, setCurrentPage] = useState(config.initialPage);

  // è®€å–ç•™è¨€ç¸½æ•¸
  const { data: totalMessages } = useScaffoldContractRead({
    contractName: 'MessageBoard',
    functionName: 'getTotalMessages',
    watch: true,
  });

  // è®€å–æœ€æ–°çš„ N å‰‡ç•™è¨€
  const { 
    data: latestMessages,
    isLoading,
    error,
    refetch
  } = useScaffoldContractRead({
    contractName: 'MessageBoard',
    functionName: 'getLatestMessages',
    args: [BigInt(config.pageSize * (currentPage + 1))],
    watch: true,
  });

  const totalPages = totalMessages ? 
    Math.ceil(Number(totalMessages) / config.pageSize) : 0;

  const nextPage = useCallback(() => {
    if (currentPage < totalPages - 1) {
      setCurrentPage(prev => prev + 1);
    }
  }, [currentPage, totalPages]);

  const prevPage = useCallback(() => {
    if (currentPage > 0) {
      setCurrentPage(prev => prev - 1);
    }
  }, [currentPage]);

  const goToPage = useCallback((page: number) => {
    if (page >= 0 && page < totalPages) {
      setCurrentPage(page);
    }
  }, [totalPages]);

  // è¨ˆç®—ç•¶å‰é é¢çš„ç•™è¨€
  const currentPageMessages = latestMessages ? 
    (latestMessages as any[]).slice(
      currentPage * config.pageSize,
      (currentPage + 1) * config.pageSize
    ) : [];

  return {
    messages: currentPageMessages,
    isLoading,
    error,
    currentPage,
    totalPages,
    totalMessages: Number(totalMessages || 0),
    nextPage,
    prevPage,
    goToPage,
    refresh: refetch,
  };
};
```

---

## IPFS å…§å®¹ç²å–èˆ‡è§£æ

### ğŸŒ **IPFS å…§å®¹ç²å– Hook**

å»ºç«‹å°ˆé–€è™•ç† IPFS å…§å®¹ç²å–çš„ Hookï¼š

```typescript
// packages/nextjs/hooks/useIPFSContent.ts
import { useState, useEffect, useCallback } from 'react';
import config from '~~/config/app';

interface IPFSContent {
  text: string;
  author?: string;
  title?: string;
  tags?: string[];
  createdAt: string;
  version: string;
}

interface UseIPFSContentResult {
  content: IPFSContent | null;
  isLoading: boolean;
  error: string | null;
  retry: () => void;
}

export const useIPFSContent = (cid: string): UseIPFSContentResult => {
  const [content, setContent] = useState<IPFSContent | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchContent = useCallback(async () => {
    if (!cid) return;

    setIsLoading(true);
    setError(null);

    try {
      // æ§‹å»º IPFS Gateway URL
      const gatewayUrl = `${config.pinata.gatewayUrl}/ipfs/${cid}`;
      
      console.log(`ğŸ“¥ å¾ IPFS ç²å–å…§å®¹: ${cid}`);
      
      const response = await fetch(gatewayUrl, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
        },
        // 5 ç§’è¶…æ™‚
        signal: AbortSignal.timeout(5000),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ç„¡æ³•ç²å– IPFS å…§å®¹`);
      }

      const contentType = response.headers.get('content-type');
      if (!contentType?.includes('application/json')) {
        throw new Error('IPFS å…§å®¹ä¸æ˜¯æœ‰æ•ˆçš„ JSON æ ¼å¼');
      }

      const data = await response.json();
      
      // é©—è­‰è³‡æ–™æ ¼å¼
      if (!data.text) {
        throw new Error('IPFS å…§å®¹ç¼ºå°‘å¿…è¦çš„ text æ¬„ä½');
      }

      console.log(`âœ… æˆåŠŸç²å– IPFS å…§å®¹: ${cid.substring(0, 10)}...`);
      setContent(data);

    } catch (err: any) {
      console.error(`âŒ ç²å– IPFS å…§å®¹å¤±æ•— (${cid}):`, err);
      
      if (err.name === 'AbortError') {
        setError('è«‹æ±‚è¶…æ™‚ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·š');
      } else if (err.message.includes('HTTP 404')) {
        setError('å…§å®¹æœªæ‰¾åˆ°ï¼Œå¯èƒ½å·²è¢«ç§»é™¤');
      } else {
        setError(err.message || 'IPFS å…§å®¹ç²å–å¤±æ•—');
      }
    } finally {
      setIsLoading(false);
    }
  }, [cid]);

  const retry = useCallback(() => {
    fetchContent();
  }, [fetchContent]);

  useEffect(() => {
    if (cid) {
      fetchContent();
    }
  }, [fetchContent, cid]);

  return {
    content,
    isLoading,
    error,
    retry,
  };
};
```

### ğŸŒ **æ‰¹æ¬¡ IPFS å…§å®¹ç²å–**

ç‚ºäº†å„ªåŒ–æ•ˆèƒ½ï¼Œæˆ‘å€‘å¯ä»¥æ‰¹æ¬¡ç²å–å¤šå€‹ IPFS å…§å®¹ï¼š

```typescript
// packages/nextjs/hooks/useBatchIPFSContent.ts
import { useState, useEffect, useCallback } from 'react';
import config from '~~/config/app';

interface BatchResult {
  [cid: string]: {
    content: any | null;
    isLoading: boolean;
    error: string | null;
  };
}

export const useBatchIPFSContent = (cids: string[]) => {
  const [results, setResults] = useState<BatchResult>({});

  const fetchContent = useCallback(async (cid: string) => {
    try {
      const gatewayUrl = `${config.pinata.gatewayUrl}/ipfs/${cid}`;
      const response = await fetch(gatewayUrl, {
        signal: AbortSignal.timeout(10000),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();
      return { content: data, error: null };
    } catch (error: any) {
      return { content: null, error: error.message };
    }
  }, []);

  const fetchBatch = useCallback(async (cidList: string[]) => {
    // è¨­å®šåˆå§‹è¼‰å…¥ç‹€æ…‹
    const initialState: BatchResult = {};
    cidList.forEach(cid => {
      initialState[cid] = {
        content: null,
        isLoading: true,
        error: null,
      };
    });
    setResults(initialState);

    // ä¸¦è¡Œç²å–æ‰€æœ‰å…§å®¹
    const promises = cidList.map(async (cid) => {
      const result = await fetchContent(cid);
      return { cid, ...result };
    });

    const batchResults = await Promise.all(promises);

    // æ›´æ–°çµæœ
    const finalResults: BatchResult = {};
    batchResults.forEach(({ cid, content, error }) => {
      finalResults[cid] = {
        content,
        isLoading: false,
        error,
      };
    });

    setResults(finalResults);
  }, [fetchContent]);

  useEffect(() => {
    if (cids.length > 0) {
      fetchBatch(cids);
    }
  }, [cids, fetchBatch]);

  return results;
};
```

---

## ç•™è¨€åˆ—è¡¨ä»‹é¢è¨­è¨ˆ

### ğŸ¨ **MessageCard å…ƒä»¶**

å»ºç«‹å–®å‰‡ç•™è¨€çš„é¡¯ç¤ºå¡ç‰‡ï¼š

```typescript
// packages/nextjs/components/MessageCard.tsx
import React from 'react';
import { MessageWithContent } from '~~/hooks/useMessages';
import { useIPFSContent } from '~~/hooks/useIPFSContent';

interface MessageCardProps {
  message: MessageWithContent;
}

export const MessageCard: React.FC<MessageCardProps> = ({ message }) => {
  const { content, isLoading, error, retry } = useIPFSContent(message.ipfsCid);

  const formatTimestamp = (timestamp: number) => {
    return new Date(timestamp * 1000).toLocaleString('zh-TW', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const formatAddress = (address: string) => {
    return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-6 mb-4 transition-all hover:shadow-lg">
      {/* æ¨™é¡Œå€åŸŸ */}
      <div className="flex justify-between items-start mb-4">
        <div>
          {content?.title && (
            <h3 className="text-lg font-semibold text-gray-900 mb-2">
              {content.title}
            </h3>
          )}
          <div className="flex items-center space-x-4 text-sm text-gray-500">
            <span className="flex items-center">
              ğŸ‘¤ {content?.author || formatAddress(message.sender)}
            </span>
            <span className="flex items-center">
              ğŸ•’ {formatTimestamp(message.timestamp)}
            </span>
            <span className="text-xs bg-gray-100 px-2 py-1 rounded">
              #{message.messageId}
            </span>
          </div>
        </div>
        
        {/* CID é¡¯ç¤º */}
        <div className="text-xs text-gray-400">
          <span className="font-mono bg-gray-50 px-2 py-1 rounded">
            {message.ipfsCid.substring(0, 10)}...
          </span>
        </div>
      </div>

      {/* å…§å®¹å€åŸŸ */}
      <div className="mb-4">
        {isLoading ? (
          <div className="animate-pulse">
            <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
            <div className="h-4 bg-gray-200 rounded w-1/2"></div>
          </div>
        ) : error ? (
          <div className="bg-red-50 border border-red-200 rounded-md p-4">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-red-700 text-sm">âš ï¸ è¼‰å…¥å…§å®¹å¤±æ•—</p>
                <p className="text-red-600 text-xs mt-1">{error}</p>
              </div>
              <button
                onClick={retry}
                className="text-red-600 hover:text-red-800 text-sm underline"
              >
                é‡è©¦
              </button>
            </div>
          </div>
        ) : content ? (
          <div>
            <p className="text-gray-800 leading-relaxed whitespace-pre-wrap">
              {content.text}
            </p>
          </div>
        ) : null}
      </div>

      {/* æ¨™ç±¤å€åŸŸ */}
      {content?.tags && content.tags.length > 0 && (
        <div className="flex flex-wrap gap-2 mb-3">
          {content.tags.map((tag, index) => (
            <span
              key={index}
              className="inline-block bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full"
            >
              #{tag}
            </span>
          ))}
        </div>
      )}

      {/* åº•éƒ¨è³‡è¨Š */}
      <div className="border-t pt-3 flex justify-between items-center text-xs text-gray-400">
        <div className="flex space-x-4">
          <span>ç™¼é€è€…: {formatAddress(message.sender)}</span>
          {content?.createdAt && (
            <span>å»ºç«‹: {new Date(content.createdAt).toLocaleDateString('zh-TW')}</span>
          )}
        </div>
        <div className="flex items-center space-x-2">
          <span>ğŸ”— IPFS</span>
          <a
            href={`https://gateway.pinata.cloud/ipfs/${message.ipfsCid}`}
            target="_blank"
            rel="noopener noreferrer"
            className="text-blue-500 hover:text-blue-700 underline"
          >
            æŸ¥çœ‹åŸå§‹å…§å®¹
          </a>
        </div>
      </div>
    </div>
  );
};
```

### ğŸ¨ **MessageList å…ƒä»¶**

å»ºç«‹ç•™è¨€åˆ—è¡¨å®¹å™¨å…ƒä»¶ï¼š

```typescript
// packages/nextjs/components/MessageList.tsx
import React, { useState } from 'react';
import { MessageCard } from './MessageCard';
import { useMessages } from '~~/hooks/useMessages';

export const MessageList: React.FC = () => {
  const { messages, isLoading, error, refresh } = useMessages();
  const [autoRefresh, setAutoRefresh] = useState(true);

  // è‡ªå‹•é‡æ–°æ•´ç† (æ¯ 30 ç§’)
  React.useEffect(() => {
    if (!autoRefresh) return;

    const interval = setInterval(() => {
      refresh();
    }, 30000);

    return () => clearInterval(interval);
  }, [autoRefresh, refresh]);

  if (isLoading && messages.length === 0) {
    return (
      <div className="space-y-4">
        {/* è¼‰å…¥éª¨æ¶ */}
        {[...Array(3)].map((_, index) => (
          <div key={index} className="bg-white rounded-lg shadow-md p-6 animate-pulse">
            <div className="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
            <div className="space-y-2">
              <div className="h-4 bg-gray-200 rounded w-3/4"></div>
              <div className="h-4 bg-gray-200 rounded w-1/2"></div>
            </div>
          </div>
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-6 text-center">
        <h3 className="text-lg font-semibold text-red-800 mb-2">è¼‰å…¥å¤±æ•—</h3>
        <p className="text-red-600 mb-4">{error}</p>
        <button
          onClick={refresh}
          className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 transition-colors"
        >
          é‡æ–°è¼‰å…¥
        </button>
      </div>
    );
  }

  if (messages.length === 0) {
    return (
      <div className="bg-gray-50 border-2 border-dashed border-gray-300 rounded-lg p-12 text-center">
        <div className="text-6xl mb-4">ğŸ’¬</div>
        <h3 className="text-lg font-semibold text-gray-700 mb-2">é‚„æ²’æœ‰ç•™è¨€</h3>
        <p className="text-gray-500 mb-4">æˆç‚ºç¬¬ä¸€å€‹åœ¨é€™å€‹å»ä¸­å¿ƒåŒ–ç•™è¨€æ¿ä¸Šç™¼è¨€çš„äººï¼</p>
        <button
          onClick={refresh}
          className="text-blue-600 hover:text-blue-800 underline"
        >
          é‡æ–°æª¢æŸ¥
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* æ§åˆ¶é¢æ¿ */}
      <div className="bg-white rounded-lg shadow-sm p-4 flex justify-between items-center">
        <div className="flex items-center space-x-4">
          <span className="text-sm text-gray-600">
            å…± {messages.length} å‰‡ç•™è¨€
          </span>
          {isLoading && (
            <span className="text-sm text-blue-600 flex items-center">
              <div className="animate-spin w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full mr-2"></div>
              æ›´æ–°ä¸­...
            </span>
          )}
        </div>
        
        <div className="flex items-center space-x-3">
          <label className="flex items-center text-sm text-gray-600">
            <input
              type="checkbox"
              checked={autoRefresh}
              onChange={(e) => setAutoRefresh(e.target.checked)}
              className="mr-2"
            />
            è‡ªå‹•é‡æ–°æ•´ç†
          </label>
          
          <button
            onClick={refresh}
            className="text-blue-600 hover:text-blue-800 text-sm px-3 py-1 border border-blue-300 rounded-md hover:bg-blue-50 transition-colors"
          >
            ğŸ”„ æ‰‹å‹•é‡æ–°æ•´ç†
          </button>
        </div>
      </div>

      {/* ç•™è¨€åˆ—è¡¨ */}
      <div className="space-y-4">
        {messages.map((message) => (
          <MessageCard key={message.messageId} message={message} />
        ))}
      </div>

      {/* è¼‰å…¥æ›´å¤š (å¦‚æœä½¿ç”¨åˆ†é ) */}
      {messages.length > 0 && (
        <div className="text-center py-8">
          <p className="text-gray-500 text-sm">
            ğŸ’¡ æç¤ºï¼šæ–°ç•™è¨€æœƒè‡ªå‹•å‡ºç¾åœ¨é ‚éƒ¨
          </p>
        </div>
      )}
    </div>
  );
};
```

---

## è¼‰å…¥ç‹€æ…‹èˆ‡éŒ¯èª¤è™•ç†

### ğŸ”„ **è¼‰å…¥ç‹€æ…‹ç®¡ç†**

å»ºç«‹çµ±ä¸€çš„è¼‰å…¥ç‹€æ…‹å…ƒä»¶ï¼š

```typescript
// packages/nextjs/components/LoadingStates.tsx
import React from 'react';

export const SkeletonCard: React.FC = () => (
  <div className="bg-white rounded-lg shadow-md p-6 animate-pulse">
    <div className="flex justify-between items-start mb-4">
      <div className="space-y-2">
        <div className="h-5 bg-gray-200 rounded w-32"></div>
        <div className="h-4 bg-gray-200 rounded w-48"></div>
      </div>
      <div className="h-4 bg-gray-200 rounded w-20"></div>
    </div>
    
    <div className="space-y-2 mb-4">
      <div className="h-4 bg-gray-200 rounded w-full"></div>
      <div className="h-4 bg-gray-200 rounded w-3/4"></div>
      <div className="h-4 bg-gray-200 rounded w-1/2"></div>
    </div>
    
    <div className="flex space-x-2 mb-3">
      <div className="h-6 bg-gray-200 rounded-full w-16"></div>
      <div className="h-6 bg-gray-200 rounded-full w-20"></div>
    </div>
    
    <div className="border-t pt-3">
      <div className="h-3 bg-gray-200 rounded w-2/3"></div>
    </div>
  </div>
);

export const LoadingSpinner: React.FC<{ size?: 'sm' | 'md' | 'lg' }> = ({ 
  size = 'md' 
}) => {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
  };

  return (
    <div className="flex justify-center items-center p-8">
      <div className={`${sizeClasses[size]} border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin`}>
      </div>
    </div>
  );
};

export const EmptyState: React.FC<{
  icon?: string;
  title: string;
  description: string;
  action?: {
    label: string;
    onClick: () => void;
  };
}> = ({ icon = 'ğŸ“­', title, description, action }) => (
  <div className="bg-gray-50 border-2 border-dashed border-gray-300 rounded-lg p-12 text-center">
    <div className="text-6xl mb-4">{icon}</div>
    <h3 className="text-lg font-semibold text-gray-700 mb-2">{title}</h3>
    <p className="text-gray-500 mb-4">{description}</p>
    {action && (
      <button
        onClick={action.onClick}
        className="text-blue-600 hover:text-blue-800 underline"
      >
        {action.label}
      </button>
    )}
  </div>
);
```

### ğŸ”„ **éŒ¯èª¤é‚Šç•Œå…ƒä»¶**

```typescript
// packages/nextjs/components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  private handleRetry = () => {
    this.setState({ hasError: false, error: undefined });
  };

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="bg-red-50 border border-red-200 rounded-lg p-6 text-center">
          <div className="text-6xl mb-4">âš ï¸</div>
          <h3 className="text-lg font-semibold text-red-800 mb-2">ç™¼ç”ŸéŒ¯èª¤</h3>
          <p className="text-red-600 mb-4">
            {this.state.error?.message || 'æ‡‰ç”¨ç¨‹å¼é‡åˆ°æœªé æœŸçš„éŒ¯èª¤'}
          </p>
          <button
            onClick={this.handleRetry}
            className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 transition-colors mr-3"
          >
            é‡è©¦
          </button>
          <button
            onClick={() => window.location.reload()}
            className="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 transition-colors"
          >
            é‡æ–°è¼‰å…¥é é¢
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

---

## æ•ˆèƒ½å„ªåŒ–èˆ‡å¿«å–ç­–ç•¥

### âš¡ **è¨˜æ†¶é«”å¿«å–å¯¦ä½œ**

```typescript
// packages/nextjs/utils/cache.ts
interface CacheItem<T> {
  data: T;
  timestamp: number;
  expiry: number;
}

class MemoryCache {
  private cache = new Map<string, CacheItem<any>>();
  private defaultTTL = 5 * 60 * 1000; // 5 åˆ†é˜

  set<T>(key: string, data: T, ttl?: number): void {
    const expiry = Date.now() + (ttl || this.defaultTTL);
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      expiry,
    });
  }

  get<T>(key: string): T | null {
    const item = this.cache.get(key);
    
    if (!item) {
      return null;
    }

    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }

    return item.data;
  }

  has(key: string): boolean {
    const item = this.cache.get(key);
    
    if (!item) {
      return false;
    }

    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }
}

export const ipfsCache = new MemoryCache();
```

### âš¡ **å„ªåŒ–çš„ IPFS Hook**

```typescript
// packages/nextjs/hooks/useIPFSContentWithCache.ts
import { useState, useEffect, useCallback } from 'react';
import { ipfsCache } from '~~/utils/cache';
import config from '~~/config/app';

export const useIPFSContentWithCache = (cid: string) => {
  const [content, setContent] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchContent = useCallback(async () => {
    if (!cid) return;

    // æª¢æŸ¥å¿«å–
    const cached = ipfsCache.get(cid);
    if (cached) {
      console.log(`ğŸ’¾ å¾å¿«å–ç²å–å…§å®¹: ${cid}`);
      setContent(cached);
      setError(null);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const gatewayUrl = `${config.pinata.gatewayUrl}/ipfs/${cid}`;
      
      const response = await fetch(gatewayUrl, {
        signal: AbortSignal.timeout(10000),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ç„¡æ³•ç²å– IPFS å…§å®¹`);
      }

      const data = await response.json();
      
      // å„²å­˜åˆ°å¿«å–
      ipfsCache.set(cid, data);
      
      console.log(`âœ… æˆåŠŸç²å–ä¸¦å¿«å– IPFS å…§å®¹: ${cid}`);
      setContent(data);

    } catch (err: any) {
      console.error(`âŒ ç²å– IPFS å…§å®¹å¤±æ•— (${cid}):`, err);
      setError(err.message || 'IPFS å…§å®¹ç²å–å¤±æ•—');
    } finally {
      setIsLoading(false);
    }
  }, [cid]);

  useEffect(() => {
    fetchContent();
  }, [fetchContent]);

  return {
    content,
    isLoading,
    error,
    retry: fetchContent,
  };
};
```

---

## ğŸ“ æœ¬èª²ç¸½çµ

### **å·²å®Œæˆçš„åŠŸèƒ½**

1. âœ… **æ™ºèƒ½åˆç´„è³‡æ–™è®€å–**ï¼šä½¿ç”¨ Scaffold-eth-2 Hooks è®€å–ç•™è¨€è³‡æ–™
2. âœ… **IPFS å…§å®¹è§£æ**ï¼šå¾ IPFS Gateway ç²å–ä¸¦è§£æ JSON å…§å®¹
3. âœ… **éŸ¿æ‡‰å¼ UI ä»‹é¢**ï¼šç¾è§€çš„ç•™è¨€å¡ç‰‡å’Œåˆ—è¡¨è¨­è¨ˆ
4. âœ… **è¼‰å…¥ç‹€æ…‹ç®¡ç†**ï¼šéª¨æ¶è¼‰å…¥ã€éŒ¯èª¤é‚Šç•Œã€ç©ºç‹€æ…‹è™•ç†
5. âœ… **æ•ˆèƒ½å„ªåŒ–**ï¼šè¨˜æ†¶é«”å¿«å–ã€æ‰¹æ¬¡ç²å–ã€è‡ªå‹•é‡æ–°æ•´ç†

### **é—œéµå­¸ç¿’é»**

1. **è³‡æ–™æµæ•´åˆ**ï¼šå€å¡Šéˆ â†” IPFS â†” å‰ç«¯çš„å®Œæ•´è³‡æ–™æµ
2. **ä½¿ç”¨è€…é«”é©—**ï¼šè¼‰å…¥ç‹€æ…‹ã€éŒ¯èª¤è™•ç†ã€è‡ªå‹•æ›´æ–°
3. **æ•ˆèƒ½å„ªåŒ–**ï¼šå¿«å–ç­–ç•¥ã€æ‰¹æ¬¡è™•ç†ã€è¨˜æ†¶é«”ç®¡ç†
4. **éŒ¯èª¤è™•ç†**ï¼šå„ªé›…çš„éŒ¯èª¤é¡¯ç¤ºå’Œé‡è©¦æ©Ÿåˆ¶

### **ä¸‹ä¸€æ­¥è¦åŠƒ**

æ‚¨ç¾åœ¨å·²ç¶“å®Œæˆäº†ä¸€å€‹åŠŸèƒ½å®Œæ•´çš„å»ä¸­å¿ƒåŒ–ç•™è¨€æ¿ï¼æ¥ä¸‹ä¾†å¯ä»¥è€ƒæ…®ï¼š

1. **éƒ¨ç½²åˆ°æ¸¬è©¦ç¶²**ï¼šå°‡ DApp éƒ¨ç½²åˆ°å…¬é–‹çš„æ¸¬è©¦ç¶²è·¯
2. **æ–°å¢åŠŸèƒ½**ï¼šç•™è¨€å›è¦†ã€æŒ‰è®šã€ä½¿ç”¨è€…è³‡æ–™ç­‰
3. **UI/UX æ”¹é€²**ï¼šæ›´å¥½çš„éŸ¿æ‡‰å¼è¨­è¨ˆã€æš—è‰²æ¨¡å¼ç­‰
4. **æ•ˆèƒ½å„ªåŒ–**ï¼šè™›æ“¬æ»¾å‹•ã€ç„¡é™è¼‰å…¥ç­‰

---

## ğŸ”— å»¶ä¼¸é–±è®€

- [React æ•ˆèƒ½å„ªåŒ–æŒ‡å—](https://react.dev/learn/render-and-commit)
- [IPFS Gateway æœ€ä½³å¯¦è¸](https://docs.ipfs.io/concepts/ipfs-gateway/)
- [Web3 å‰ç«¯æ¶æ§‹è¨­è¨ˆ](https://web3.storage/docs/how-tos/work-with-car-files/)

**æ­å–œæ‚¨å®Œæˆäº†æ•´å€‹ IPFS åˆ° DApp çš„é–‹ç™¼èª²ç¨‹ï¼** ğŸ‰
