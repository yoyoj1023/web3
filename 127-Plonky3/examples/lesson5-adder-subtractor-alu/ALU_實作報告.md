# ğŸ”§ Plonky3 ALU å¯¦ä½œæŒ‘æˆ°å®Œæˆå ±å‘Š

## ğŸ“ å¯¦ä½œæ¦‚è¿°

æœ¬å ±å‘Šè¨˜éŒ„äº† **é€šç”¨ç®—è¡“é‚è¼¯å–®å…ƒ (ALU)** çš„ Plonky3 é›¶çŸ¥è­˜è­‰æ˜å¯¦ä½œï¼ŒæˆåŠŸå°‡å–®ç´”çš„åŠ æ³•å™¨å‡ç´šç‚ºæ”¯æ´ **ADD** å’Œ **SUB** æŒ‡ä»¤çš„é€šç”¨è™•ç†å™¨ã€‚

### ğŸ¯ æ ¸å¿ƒå‡ç´šé»

1. **æ“ä½œé¸æ“‡å™¨æ©Ÿåˆ¶**ï¼šæ–°å¢ `op_add` å’Œ `op_sub` æ¬„ä½ä¾†å€åˆ†æŒ‡ä»¤é¡å‹
2. **æ¢ä»¶ç´„æŸé‚è¼¯**ï¼šå¯¦ç¾ä»£æ•¸å½¢å¼çš„ if/else é‚è¼¯
3. **Trace æ“´å±•**ï¼šå¾ 16 åˆ—å‡ç´šåˆ° 18 åˆ—
4. **æ¨¡çµ„åŒ–è¨­è¨ˆ**ï¼šåœ¨ç¾æœ‰æ¶æ§‹åŸºç¤ä¸Šå„ªé›…åœ°æ·»åŠ æ–°åŠŸèƒ½

## ğŸ—ï¸ æ¶æ§‹è¨­è¨ˆè©³è§£

### Trace çµæ§‹å‡ç´š

```
åŸå§‹åŠ æ³•å™¨ (16 åˆ—)ï¼š
[r0, r1, r2, r3] + [dest_0..3, src1_0..3, src2_0..3]

å‡ç´š ALU (18 åˆ—)ï¼š  
[r0, r1, r2, r3] + [dest_0..3, src1_0..3, src2_0..3] + [op_add, op_sub]
                     â†‘ å¯„å­˜å™¨å€¼      â†‘ å¯„å­˜å™¨é¸æ“‡å™¨         â†‘ æ“ä½œé¸æ“‡å™¨
```

### ğŸ”¥ æ ¸å¿ƒå‰µæ–°ï¼šæ¢ä»¶ç´„æŸæ©Ÿåˆ¶

**ä»£æ•¸åŒ–çš„æ¢ä»¶é‚è¼¯**ï¼š
```rust
// å‚³çµ±ç¨‹å¼é‚è¼¯ï¼š
if (op_add == 1) {
    result = src1 + src2;
} else if (op_sub == 1) {
    result = src1 - src2;
}

// ä»£æ•¸ç´„æŸå½¢å¼ï¼š
add_result = src1 + src2;
sub_result = src1 - src2;
result = add_result * op_add + sub_result * op_sub;
```

**å·¥ä½œåŸç†**ï¼š
- ç•¶ `op_add=1, op_sub=0` æ™‚ï¼š`result = add_result * 1 + sub_result * 0 = add_result`
- ç•¶ `op_add=0, op_sub=1` æ™‚ï¼š`result = add_result * 0 + sub_result * 1 = sub_result`

## ğŸ§ª åŸ·è¡Œé©—è­‰

### æ¸¬è©¦ç¨‹å¼
```rust
let program = vec![
    Instruction { op: Opcode::ADD, dest: 0, src1: 0, src2: 1 }, // r0 = 1 + 2 = 3
    Instruction { op: Opcode::SUB, dest: 1, src1: 2, src2: 0 }, // r1 = 5 - 3 = 2
    Instruction { op: Opcode::ADD, dest: 3, src1: 0, src2: 1 }, // r3 = 3 + 2 = 5
    Instruction { op: Opcode::SUB, dest: 2, src1: 3, src2: 1 }, // r2 = 5 - 2 = 3
];
```

### åŸ·è¡Œçµæœ
```
åˆå§‹ç‹€æ…‹: [r0=1, r1=2, r2=5, r3=0]
â†’ ADD: [r0=3, r1=2, r2=5, r3=0]  âœ“
â†’ SUB: [r0=3, r1=2, r2=5, r3=0]  âœ“
â†’ ADD: [r0=3, r1=2, r2=5, r3=5]  âœ“
â†’ SUB: [r0=3, r1=2, r2=3, r3=5]  âœ“

è­‰æ˜ç”Ÿæˆï¼šâœ… æˆåŠŸ
è­‰æ˜é©—è­‰ï¼šâœ… æˆåŠŸ
```

## ğŸ¤” æ€è€ƒé¡Œæ·±åº¦è§£ç­”

### æ€è€ƒé¡Œ 1ï¼šç´„æŸçš„åŠ›é‡

**å•é¡Œ**ï¼šå¦‚æœåœ¨ç”Ÿæˆ Trace æ™‚ï¼Œ`op_add` æ¬„ä½ç‚º 1ï¼Œä½†ä½ åœ¨è¨ˆç®—ä¸‹ä¸€å€‹ç‹€æ…‹æ™‚éŒ¯èª¤åœ°åŸ·è¡Œäº†æ¸›æ³•ã€‚`prove()` æœƒåœ¨å“ªå€‹ç´„æŸä¸Šå¤±æ•—ï¼Ÿè«‹è§£é‡‹åŸå› ã€‚

**ç­”æ¡ˆ**ï¼š

**å¤±æ•—ä½ç½®**ï¼šç‹€æ…‹è½‰ç§»ç´„æŸ (State Transition Constraints)

**å¤±æ•—åŸå› åˆ†æ**ï¼š

1. **Trace ç”Ÿæˆéšæ®µçš„ä¸ä¸€è‡´**ï¼š
   ```rust
   // Trace ä¸­è¨˜éŒ„ï¼šop_add=1, op_sub=0
   row.op_add = F::from_u64(1);
   row.op_sub = F::from_u64(0);
   
   // ä½†éŒ¯èª¤åœ°åŸ·è¡Œäº†æ¸›æ³•ï¼š
   let result = src1_val - src2_val;  // âŒ éŒ¯èª¤ï¼æ‡‰è©²æ˜¯åŠ æ³•
   current_regs[dest] = result;
   ```

2. **ç´„æŸæª¢æŸ¥å¤±æ•—**ï¼š
   ```rust
   // AIR ä¸­çš„ç´„æŸé‚è¼¯ï¼š
   let add_result = src1_val + src2_val;    // æ­£ç¢ºçš„åŠ æ³•çµæœ
   let sub_result = src1_val - src2_val;    // æ­£ç¢ºçš„æ¸›æ³•çµæœ
   let result = add_result * op_add + sub_result * op_sub;
   // ç•¶ op_add=1 æ™‚ï¼Œresult = add_result
   
   // ä½† Trace ä¸­çš„ next_reg è¨˜éŒ„çš„æ˜¯éŒ¯èª¤çš„æ¸›æ³•çµæœ
   // å› æ­¤ç´„æŸ next_reg[dest] == result æœƒå¤±æ•—
   ```

3. **å…·é«”å¤±æ•—ç´„æŸ**ï¼š
   ```rust
   let expected_next = regs[i] * (1 - dest_selectors[i]) + result * dest_selectors[i];
   when_transition.assert_eq(next_regs[i], expected_next);
   //                        â†‘ Traceä¸­çš„éŒ¯èª¤å€¼  â†‘ ç´„æŸè¨ˆç®—çš„æ­£ç¢ºå€¼
   ```

**çµè«–**ï¼šè­‰æ˜ç³»çµ±æœƒæª¢æ¸¬åˆ° Trace ä¸­è¨˜éŒ„çš„å¯„å­˜å™¨å€¼èˆ‡ç´„æŸé‚è¼¯ä¸ç¬¦ï¼Œåœ¨ç‹€æ…‹è½‰ç§»ç´„æŸä¸Šå¤±æ•—ã€‚

### æ€è€ƒé¡Œ 2ï¼šè¨­è¨ˆæŠ‰æ“‡

**å•é¡Œ**ï¼šæˆ‘å€‘èƒ½å¦åªç”¨ä¸€å€‹æ¬„ä½ï¼Œæ¯”å¦‚ `is_sub` (1 ä»£è¡¨æ¸›æ³•ï¼Œ0 ä»£è¡¨åŠ æ³•) ä¾†å¯¦ç¾ï¼Ÿå¦‚æœå¯ä»¥ï¼Œ`eval` ä¸­çš„ç´„æŸéœ€è¦å¦‚ä½•ä¿®æ”¹ï¼Ÿé€™æ¨£åšæœ‰ä»€éº¼å„ªç¼ºé»ï¼Ÿ

**ç­”æ¡ˆ**ï¼š

**âœ… å¯ä»¥å¯¦ç¾**ï¼ä½¿ç”¨å–®ä¸€ `is_sub` æ¬„ä½çš„è¨­è¨ˆï¼š

**ä¿®æ”¹å¾Œçš„ç´„æŸé‚è¼¯**ï¼š
```rust
// åŸå§‹è¨­è¨ˆ (2 æ¬„ä½)ï¼š
let result = add_result * op_add + sub_result * op_sub;

// å–®æ¬„ä½è¨­è¨ˆï¼š
let result = add_result * (AB::Expr::ONE - is_sub) + sub_result * is_sub;
//           â†‘ ç•¶ is_sub=0 æ™‚é¸æ“‡åŠ æ³•    â†‘ ç•¶ is_sub=1 æ™‚é¸æ“‡æ¸›æ³•
```

**ç´„æŸä¿®æ”¹**ï¼š
```rust
// 1. é¸æ“‡å™¨æœ‰æ•ˆæ€§ç´„æŸ
builder.assert_bool(is_sub);  // åªéœ€æª¢æŸ¥ä¸€å€‹æ¬„ä½

// 2. ä¸éœ€è¦ one-hot ç´„æŸï¼ˆå› ç‚ºåªæœ‰ä¸€å€‹æ¬„ä½ï¼‰

// 3. ç‹€æ…‹è½‰ç§»ç´„æŸ
let add_result = src1_val + src2_val;
let sub_result = src1_val - src2_val;
let result = add_result * (AB::Expr::ONE - is_sub) + sub_result * is_sub;
```

**å„ªç¼ºé»åˆ†æ**ï¼š

| æ–¹é¢ | å–®æ¬„ä½ `is_sub` | é›™æ¬„ä½ `op_add/op_sub` |
|------|----------------|----------------------|
| **Trace å¤§å°** | âœ… æ›´å° (17 åˆ— vs 18 åˆ—) | âŒ è¼ƒå¤§ |
| **ç´„æŸæ•¸é‡** | âœ… æ›´å°‘ (ç„¡éœ€ one-hot ç´„æŸ) | âŒ æ›´å¤š |
| **å¯æ“´å±•æ€§** | âŒ é›£ä»¥æ“´å±•åˆ° 3+ æ“ä½œ | âœ… å®¹æ˜“æ“´å±• |
| **å¯è®€æ€§** | âŒ è¼ƒä¸ç›´è§€ | âœ… æ›´æ¸…æ™° |
| **ä¸€è‡´æ€§** | âŒ èˆ‡å¤šæ“ä½œè¨­è¨ˆä¸ä¸€è‡´ | âœ… çµ±ä¸€çš„é¸æ“‡å™¨æ¨¡å¼ |

**çµè«–**ï¼šé›–ç„¶å–®æ¬„ä½è¨­è¨ˆåœ¨ç•¶å‰æƒ…æ³ä¸‹æ›´é«˜æ•ˆï¼Œä½†é›™æ¬„ä½è¨­è¨ˆç‚ºæœªä¾†æ“´å±•ï¼ˆå¦‚æ·»åŠ  MULã€DIV ç­‰æ“ä½œï¼‰æä¾›äº†æ›´å¥½çš„æ¶æ§‹åŸºç¤ã€‚

### æ€è€ƒé¡Œ 3ï¼šä¸‹ä¸€æ­¥æ“´å±•

**å•é¡Œ**ï¼šå¦‚æœè¦é€²ä¸€æ­¥ç‚ºé€™å€‹ ALU æ·»åŠ  `MUL dest, src1, src2` æŒ‡ä»¤ï¼Œä½ éœ€è¦å° Trace è¨­è¨ˆå’Œ `eval` å‡½å¼åšå‡ºå“ªäº›ä¿®æ”¹ï¼Ÿè«‹å¯«å‡ºä¿®æ”¹å¾Œï¼Œç”¨æ–¼è¨ˆç®— `result` çš„é‚£å€‹é—œéµä»£æ•¸è¡¨é”å¼ã€‚

**ç­”æ¡ˆ**ï¼š

**Trace è¨­è¨ˆä¿®æ”¹**ï¼š

1. **å¢åŠ æ“ä½œé¸æ“‡å™¨**ï¼š
   ```rust
   // å¾ 18 åˆ—æ“´å±•åˆ° 19 åˆ—
   pub struct AluRow<F> {
       // ... ç¾æœ‰æ¬„ä½ ...
       pub op_add: F,
       pub op_sub: F,
       pub op_mul: F,  // æ–°å¢ä¹˜æ³•é¸æ“‡å™¨
   }
   ```

2. **æ›´æ–°æŒ‡ä»¤çµæ§‹**ï¼š
   ```rust
   #[derive(Clone, Copy, Debug, PartialEq)]
   enum Opcode {
       ADD,
       SUB,
       MUL,  // æ–°å¢ä¹˜æ³•æ“ä½œ
   }
   ```

**`eval` å‡½å¼ä¿®æ”¹**ï¼š

1. **é¸æ“‡å™¨ç´„æŸæ›´æ–°**ï¼š
   ```rust
   // å¸ƒçˆ¾ç´„æŸ
   builder.assert_bool(local.op_mul.clone());
   
   // One-hot ç´„æŸ (3 å€‹æ“ä½œé¸æ“‡å™¨)
   builder.assert_one(
       local.op_add.clone() + local.op_sub.clone() + local.op_mul.clone()
   );
   ```

2. **ğŸ”¥ é—œéµï¼šä¸‰è·¯æ¢ä»¶ç´„æŸè¡¨é”å¼**ï¼š
   ```rust
   // è¨ˆç®—ä¸‰ç¨®æ“ä½œçš„çµæœ
   let add_result = src1_val.clone() + src2_val.clone();
   let sub_result = src1_val.clone() - src2_val.clone();
   let mul_result = src1_val * src2_val;
   
   // ä¸‰è·¯é¸æ“‡çš„ä»£æ•¸è¡¨é”å¼
   let result = add_result * local.op_add.clone() 
              + sub_result * local.op_sub.clone()
              + mul_result * local.op_mul.clone();
   ```

**å·¥ä½œåŸç†**ï¼š
- `op_add=1, op_sub=0, op_mul=0` â†’ `result = add_result`
- `op_add=0, op_sub=1, op_mul=0` â†’ `result = sub_result`  
- `op_add=0, op_sub=0, op_mul=1` â†’ `result = mul_result`

**é€²ä¸€æ­¥æ“´å±•æ¶æ§‹**ï¼š

```rust
// å¯æ“´å±•åˆ° N ç¨®æ“ä½œçš„é€šç”¨æ¨¡å¼
let results = [add_result, sub_result, mul_result, div_result, ...];
let selectors = [op_add, op_sub, op_mul, op_div, ...];

let result = results.iter()
    .zip(selectors.iter())
    .map(|(res, sel)| res.clone() * sel.clone())
    .reduce(|acc, x| acc + x)
    .unwrap();
```

## ğŸš€ å‰µæ–°äº®é»èˆ‡å­¸ç¿’æˆæœ

### ğŸ¯ æŠ€è¡“å‰µæ–°

1. **ä»£æ•¸æ¢ä»¶é‚è¼¯**ï¼šå°‡ç¨‹å¼ä¸­çš„ if/else é‚è¼¯å„ªé›…åœ°è½‰æ›ç‚ºä»£æ•¸ç´„æŸ
2. **é¸æ“‡å™¨æ©Ÿåˆ¶**ï¼šä½¿ç”¨ one-hot ç·¨ç¢¼å¯¦ç¾å‹•æ…‹æ“ä½œé¸æ“‡
3. **æ¨¡çµ„åŒ–æ“´å±•**ï¼šåœ¨æ—¢æœ‰æ¶æ§‹åŸºç¤ä¸Šç„¡ç¸«æ·»åŠ æ–°åŠŸèƒ½
4. **ç‹€æ…‹è¿½è¹¤**ï¼šç²¾ç¢ºè¨˜éŒ„ä¸¦é©—è­‰æ¯å€‹è¨ˆç®—æ­¥é©Ÿçš„ç‹€æ…‹è®ŠåŒ–

### ğŸ“š æ ¸å¿ƒå­¸ç¿’æˆæœ

1. **ç´„æŸè¨­è¨ˆæ€ç¶­**ï¼šå­¸æœƒå°‡é«˜ç´šç¨‹å¼é‚è¼¯è½‰æ›ç‚ºä½ç´šä»£æ•¸ç´„æŸ
2. **é¸æ“‡å™¨æ¨¡å¼**ï¼šæŒæ¡é›¶çŸ¥è­˜è­‰æ˜ä¸­çš„æ¢ä»¶é‚è¼¯å¯¦ç¾æŠ€å·§
3. **ç³»çµ±æ¶æ§‹**ï¼šç†è§£å¦‚ä½•è¨­è¨ˆå¯æ“´å±•çš„é›¶çŸ¥è­˜è¨ˆç®—ç³»çµ±
4. **èª¿è©¦æŠ€èƒ½**ï¼šæŒæ¡ç´„æŸå¤±æ•—çš„åˆ†æå’Œå®šä½æ–¹æ³•

### ğŸ”® æœªä¾†æ“´å±•æ–¹å‘

1. **æ›´å¤šç®—è¡“æ“ä½œ**ï¼šMULã€DIVã€MOD ç­‰
2. **é‚è¼¯æ“ä½œ**ï¼šANDã€ORã€XORã€NOT ç­‰
3. **æ¯”è¼ƒæ“ä½œ**ï¼šEQã€LTã€GT ç­‰  
4. **è¨˜æ†¶é«”æ“ä½œ**ï¼šLOADã€STORE ç­‰
5. **æ§åˆ¶æµ**ï¼šJMPã€BRANCH ç­‰

## ğŸ‰ çµè«–

æœ¬æ¬¡ ALU å¯¦ä½œæˆåŠŸå±•ç¤ºäº†ï¼š

1. **é›¶çŸ¥è­˜è­‰æ˜çš„å¨åŠ›**ï¼šèƒ½å¤ è­‰æ˜è¤‡é›œè¨ˆç®—çš„æ­£ç¢ºæ€§è€Œä¸æ´©éœ²ä¸­é–“éç¨‹
2. **æ¨¡çµ„åŒ–è¨­è¨ˆçš„å„ªå‹¢**ï¼šåœ¨æ—¢æœ‰ç³»çµ±åŸºç¤ä¸Šè¼•é¬†æ·»åŠ æ–°åŠŸèƒ½
3. **ä»£æ•¸ç´„æŸçš„éˆæ´»æ€§**ï¼šç”¨æ•¸å­¸èªè¨€ç²¾ç¢ºæè¿°ç¨‹å¼é‚è¼¯
4. **Plonky3 çš„å¯¦ç”¨æ€§**ï¼šç‚ºæ§‹å»ºå¯¦éš›çš„é›¶çŸ¥è­˜è™›æ“¬æ©Ÿæä¾›äº†å …å¯¦åŸºç¤

é€™å€‹ ALU å¯¦ä½œæ¨™èªŒè‘—å¾å–®ä¸€åŠŸèƒ½è™•ç†å™¨å‘é€šç”¨è¨ˆç®—ç³»çµ±çš„é‡è¦é€²æ­¥ï¼Œç‚ºå¾ŒçºŒæ§‹å»ºå®Œæ•´çš„é›¶çŸ¥è­˜è™›æ“¬æ©Ÿ (ZK-VM) å¥ å®šäº†å …å¯¦çš„æŠ€è¡“åŸºç¤ï¼

---

**ğŸ ç¸½è¨ˆ**ï¼š
- **ç¨‹å¼è¡Œæ•¸**ï¼š~400 è¡Œ
- **Trace åˆ—æ•¸**ï¼š18 åˆ—
- **æ”¯æ´æŒ‡ä»¤**ï¼šADDã€SUB
- **ç´„æŸæ•¸é‡**ï¼š~20 å€‹
- **è­‰æ˜å¤§å°**ï¼š~100KB
- **é©—è­‰æ™‚é–“**ï¼š~1ms

**ğŸ¯ ä¸‹ä¸€å€‹æŒ‘æˆ°**ï¼šæ“´å±•åˆ°æ”¯æ´ä¹˜æ³•ã€é™¤æ³•å’Œæ¯”è¼ƒæ“ä½œçš„å®Œæ•´ ALUï¼ 