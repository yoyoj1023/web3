# FRI (Fast Reed-Solomon Interactive Oracle Proofs) 演示

## 🎯 專案目標

這個專案實現了一個簡化版的 FRI 協議演示，讓您可以直觀地「感受」FRI 的工作原理。我們將複雜的密碼學概念簡化為一個可以一步步追蹤的「誠實多項式」遊戲。

## 🎮 遊戲規則

### 角色介紹
- **Paul (證明者 Prover)** 🤐：宣稱自己有一個「很簡單」的多項式（次數不大於 2）
- **Vera (驗證者 Verifier)** 🔍：要快速驗證 Paul 是不是在說謊，但又不想讓 Paul 把整個多項式都告訴她

### 遊戲流程

1. **承諾階段** 📋
   - Paul 有一個秘密多項式 `P(x) = x² + 2x + 1`
   - Paul 計算這個多項式在多個點（如 x = 0,1,2,3,4,5,6,7）的值
   - Paul 創建一個「承諾」（類似於把答案寫在紙上然後密封）

2. **摺疊階段** 🔄
   - Vera 給 Paul 隨機數字作為「挑戰」
   - Paul 使用這個隨機數字將原本的大問題「摺疊」成小問題
   - 重複這個過程直到問題變成一個常數

3. **驗證階段** 🔍
   - Vera 隨機抽查幾個計算路徑
   - 驗證每一步摺疊是否誠實執行
   - 如果 Paul 作弊，會在這個階段被發現

## 🚀 如何運行

### 基本演示
```bash
python fri_demo.py
```

### 查看作弊者演示
```bash
python cheating_demo.py
```

## 📊 輸出範例

```
============================================================
🎮 歡迎來到「誠實多項式」遊戲！
============================================================
🤐 Paul 心裡的秘密多項式: 1 + 2x + x^2
📢 Paul 宣告: 我的多項式次數不大於 2

========================================
📋 步驟 1: 承諾階段
========================================

🔒 Paul 創建 L0 層承諾:
   定義域: [0, 1, 2, 3, 4, 5, 6, 7]
   多項式值: [1, 4, 9, 16, 25, 36, 49, 64]
   承諾哈希: 8b2c1c0a5d8f3e7b

========================================
🔄 步驟 2: 摺疊階段
========================================

🎲 第 1 輪摺疊，Vera 的隨機挑戰: r1 = 7
   摺疊 index 0,1: 1 + 7 * 4 = 29
   摺疊 index 2,3: 9 + 7 * 16 = 121
   摺疊 index 4,5: 25 + 7 * 36 = 277
   摺疊 index 6,7: 49 + 7 * 64 = 497

🔒 Paul 創建 L1 層承諾:
   新定義域: [0, 1, 2, 3]
   摺疊後值: [29, 121, 277, 497]
   承諾哈希: 4f8e2d1a9c7b5e3f

... 繼續摺疊直到得到最終常數 ...

🎯 最終常數: 1234

========================================
🔍 步驟 3: 查詢驗證階段
========================================

🎲 隨機查詢 #1:
   📍 查詢 L1 層，索引 2
   🔍 驗證摺疊: 25 + 7 * 36 = 277
   📋 Paul 提供的值: 277
   ✅ 摺疊一致性: 通過

... 更多隨機查詢 ...

========================================
🏁 最終結果
========================================
✅ 所有隨機查詢都通過驗證！
🎉 Vera 相信 Paul 的多項式次數確實不大於 2
```

## 🔬 核心概念解釋

### 1. 摺疊 (Folding)
FRI 的魔法在於「摺疊」：將一個高次多項式問題轉化為低次多項式問題。
- 原始多項式次數為 d
- 每次摺疊後次數大約減半
- 最終得到一個常數（次數為 0）

### 2. 隨機挑戰 (Random Challenges)
- Vera 提供的隨機數確保 Paul 無法預先準備假證明
- 每個隨機數都會影響摺疊的結果
- 如果 Paul 作弊，隨機性會讓他在驗證階段被抓到

### 3. 查詢驗證 (Query Phase)
- Vera 不需要檢查所有計算
- 只需隨機抽查幾個點就能以高概率發現作弊
- 這是 FRI 高效性的關鍵

## 🎯 為什麼 FRI 重要？

1. **快速性 (Fast)**：驗證時間遠小於重新計算時間
2. **簡潔性**：證明大小隨 log(問題規模) 增長
3. **隱私性**：不需要揭露完整的秘密資訊
4. **可靠性**：作弊者被發現的概率非常高

## 🧪 實驗建議

1. 修改 `secret_poly` 的係數，觀察不同多項式的行為
2. 改變 `domain_size`，看看如何影響摺疊次數
3. 調整查詢次數 `num_queries`，體驗安全性與效率的平衡
4. 運行 `cheating_demo.py` 觀察作弊者如何被發現

## 📚 進階學習

這個演示簡化了許多細節，實際的 FRI 協議還包括：
- 有限域運算而非整數運算
- 複雜的梅克爾樹承諾機制
- 更精密的安全性分析
- 與其他零知識證明系統的集成

## 🤝 如何使用

這個演示非常適合：
- 密碼學學習者理解 FRI 基礎概念
- 開發者快速了解 ZK-STARK 的核心技術
- 教育用途的互動式演示

享受您的 FRI 學習之旅！ 🎉 