# 模組一：奠基時刻 - Plonky2 的設計起點
## The Foundation - Plonky2's Design Origins

**課程目標：** 複習 PLONK 的核心思想，為理解 Plonky2 的演進和差異化設計鋪平道路。

**心智模型：** 在研究一輛 F1 賽車前，先確保我們對標準家用車的引擎和傳動系統有清晰的認識。

---

## 1. PLONK 前景提要

### 1.1 核心約束系統

PLONK 的魅力在於其**通用門約束 (Universal Gate Constraints)**：

```
q_L · w_a + q_R · w_b + q_O · w_c + q_M · w_a · w_b + q_C = 0
```

這個看似簡單的方程式是「可配置邏輯單元」的體現：

#### 加法門 (Addition Gate)
```
q_L = 1, q_R = 1, q_O = -1, q_M = 0, q_C = 0
=> w_a + w_b - w_c = 0
=> w_c = w_a + w_b
```

#### 乘法門 (Multiplication Gate)  
```
q_L = 0, q_R = 0, q_O = -1, q_M = 1, q_C = 0
=> w_a · w_b - w_c = 0
=> w_c = w_a · w_b
```

#### 常數門 (Constant Gate)
```
q_L = 0, q_R = 0, q_O = -1, q_M = 0, q_C = k
=> -w_c + k = 0
=> w_c = k
```

### 1.2 置換參數：通用「黏合劑」

**核心概念：** 置換參數 (Permutation Arguments) 是 PLONK 的創新核心，它解決了一個根本問題：**如何證明不同位置的值相等？**

#### 問題場景
假設我們有一個電路：
- 第 1 行：`w_c = w_a + w_b` 
- 第 2 行：`w_c = w_a × w_b`
- 我們需要第 1 行的 `w_c` 等於第 2 行的 `w_a`

#### PLONK 的解決方案：複製約束 (Copy Constraints)

PLONK 使用置換參數來編碼「線路連接」：

```
σ(i,j) = (k,l) 表示位置 (i,j) 的值等於位置 (k,l) 的值
```

**數學原理：** 如果兩個集合 A 和 B 相等，那麼它們的任何多項式插值也相等：
```
∏(x + βσ(i) + γ) = ∏(x + βπ(i) + γ)
```

### 1.3 PLONK 的架構特色：電路為中心

**設計哲學：** PLONK 是「電路為中心 (Circuit-centric)」的系統。

- **優勢：** 極度靈活，像自由的電路板，可以將任何導線連接到任何地方
- **代價：** 對於結構化計算（如虛擬機執行），這種靈活性可能是過度設計

**圖形化理解：**
```
Gate 1: [w_a] + [w_b] = [w_c]
         |       |       |
         |       |    複製約束
         |       |       ↓
Gate 2: [w_a] × [w_b] = [w_c]
```

---

## 2. 為什麼需要 Plonky2？

### 2.1 PLONK 的限制

1. **可信設置依賴：** KZG 承諾需要可信設置，存在中心化風險
2. **遞迴效率：** 橢圓曲線配對運算在電路中模擬成本很高
3. **結構化計算：** 對於重複、規律的計算，PLONK 的靈活性變成了負擔

### 2.2 Plonky2 的設計目標

1. **透明性：** 完全消除可信設置
2. **高效遞迴：** 使驗證器在電路中的模擬成本極低
3. **混合架構：** 保持 PLONK 的靈活性，同時支援 AIR 風格的結構化約束

---

## 3. 核心概念對比

### 3.1 信任模型

| 特性 | PLONK | Plonky2 |
|------|-------|---------|
| 可信設置 | 需要 | 不需要 |
| 承諾方案 | KZG | FRI |
| 透明性 | 部分 | 完全 |

### 3.2 效率對比

| 特性 | PLONK | Plonky2 |
|------|-------|---------|
| 證明大小 | 小 (~400B) | 中等 (~45KB) |
| 驗證時間 | 快 | 快 |
| 遞迴效率 | 低 | 極高 |
| 生成速度 | 中等 | 快 |

---

## 4. 實戰練習

### 練習 1：PLONK 門約束設計

設計一個門約束來實現：`w_c = w_a² + 2w_b + 3`

<details>
<summary>解答</summary>

需要兩個門：
1. 乘法門：`w_d = w_a × w_a`
2. 線性組合門：`w_d + 2w_b + 3 - w_c = 0`

設置參數：
- 門1：`q_M = 1, q_O = -1, 其他 = 0`
- 門2：`q_L = 1, q_R = 2, q_O = -1, q_C = 3`

</details>

### 練習 2：複製約束場景

在一個 3 行的電路中：
- 第 1 行：`a + b = c`
- 第 2 行：`c × d = e` 
- 第 3 行：`e + f = g`

請設計複製約束來連接這些計算。

<details>
<summary>解答</summary>

複製約束：
- `σ(1,c) = (2,c)` // 第1行的c連接到第2行的c
- `σ(2,e) = (3,e)` // 第2行的e連接到第3行的e

</details>

---

## 5. 深入思考

### 思考題 1
為什麼說 PLONK 的靈活性對於 zkEVM 這樣的應用可能是「過度設計」？

### 思考題 2  
如果我們要設計一個專門用於矩陣乘法的零知識證明系統，PLONK 的哪些特性是必要的，哪些是多餘的？

---

## 6. 下一步預習

在下一個模組中，我們將探索：
- **執行軌跡 (Execution Trace)** 如何改變算術化的思維方式
- **AIR (Algebraic Intermediate Representation)** 如何更自然地表達結構化計算
- **Plonky2 的混合模型** 如何集兩者之所長

---

**關鍵要點回顧：**
1. PLONK 以其通用門約束和置換參數提供了極致的靈活性
2. 這種靈活性是有代價的：可信設置、遞迴效率、結構化計算的複雜性
3. Plonky2 的誕生是為了在保持核心優勢的同時，解決這些根本性問題
4. 理解 PLONK 是掌握 Plonky2 革新之處的必要基礎