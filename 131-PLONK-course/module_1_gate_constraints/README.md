# 第一模組：最小元件 - 單一門的奧秘 (The Gate Constraint)

## 模組目標
深度剖析 PLONK 的核心約束公式，理解其如何成為一個可配置的「算術元件」。

## 心智模型
將公式理解為一塊可程式化的樂高積木。

---

## 第一課：剖析 PLONK 算術化公式

### 1.1 PLONK 的核心公式

```
q_L * w_a + q_R * w_b + q_O * w_c + q_M * (w_a * w_b) + q_C = 0
```

這個看似簡單的公式，實際上是 PLONK 協議的心臟。讓我們逐一解析每個組件：

### 1.2 線路 (Wires) - 數據的載體

**w_a, w_b, w_c** 代表三條「線路」：
- **w_a**：左輸入線 (Left wire)
- **w_b**：右輸入線 (Right wire)  
- **w_c**：輸出線 (Output wire)

**直觀理解**：
想像一個有兩個輸入端和一個輸出端的電子元件，w_a 和 w_b 是輸入的數值，w_c 是輸出的數值。

### 1.3 選擇子 (Selectors) - 電路的配置開關

**q_L, q_R, q_O, q_M, q_C** 是五個「選擇子」：
- **q_L**：左輸入選擇子 (Left selector)
- **q_R**：右輸入選擇子 (Right selector)
- **q_O**：輸出選擇子 (Output selector)
- **q_M**：乘法選擇子 (Multiplication selector)
- **q_C**：常數選擇子 (Constant selector)

**關鍵洞察**：選擇子是「配置參數」，由電路設計者預先設定，而線路值是運行時的「變數」。

---

## 第二課：成為電路設計師

### 2.1 設計加法門 (Addition Gate)

**目標**：實現 a + b = c

**配置選擇子**：
- q_L = 1 (啟用左輸入)
- q_R = 1 (啟用右輸入)  
- q_O = -1 (輸出取負號)
- q_M = 0 (關閉乘法)
- q_C = 0 (無常數項)

**驗證**：
```
1 * w_a + 1 * w_b + (-1) * w_c + 0 * (w_a * w_b) + 0 = 0
=> w_a + w_b - w_c = 0
=> w_a + w_b = w_c ✓
```

**練習 2.1**
如果 w_a = 5, w_b = 3，那麼 w_c 應該等於多少才能滿足約束？

<details>
<summary>答案</summary>

w_c = 8，因為 5 + 3 = 8

</details>

### 2.2 設計乘法門 (Multiplication Gate)

**目標**：實現 a × b = c

**配置選擇子**：
- q_L = 0
- q_R = 0
- q_O = -1
- q_M = 1 (啟用乘法項)
- q_C = 0

**驗證**：
```
0 * w_a + 0 * w_b + (-1) * w_c + 1 * (w_a * w_b) + 0 = 0
=> -w_c + w_a * w_b = 0
=> w_a * w_b = w_c ✓
```

### 2.3 設計常數門 (Constant Gate)

**目標**：實現 a = 5

**配置選擇子**：
- q_L = 1
- q_R = 0
- q_O = 0
- q_M = 0
- q_C = -5 (常數值取負號)

**驗證**：
```
1 * w_a + 0 * w_b + 0 * w_c + 0 * (w_a * w_b) + (-5) = 0
=> w_a - 5 = 0
=> w_a = 5 ✓
```

### 2.4 設計自定義門

**目標**：實現 a × b + a = c

**配置選擇子**：
- q_L = 1 (包含 a 的線性項)
- q_R = 0
- q_O = -1
- q_M = 1 (包含 a × b 項)
- q_C = 0

**驗證**：
```
1 * w_a + 0 * w_b + (-1) * w_c + 1 * (w_a * w_b) + 0 = 0
=> w_a - w_c + w_a * w_b = 0
=> w_a * w_b + w_a = w_c ✓
```

**練習 2.2**
設計一個門來實現：2a + 3b = c

<details>
<summary>提示</summary>

需要使用 q_L = 2, q_R = 3, q_O = -1

</details>

---

## 第三課：R1CS vs PLONK Gate

### 3.1 R1CS 的限制

在 R1CS (Rank-1 Constraint System) 中，每個約束都是：
```
(A₁w₁ + A₂w₂ + ... + Aₙwₙ) * (B₁w₁ + B₂w₂ + ... + Bₙwₙ) = C₁w₁ + C₂w₂ + ... + Cₙwₙ
```

簡化形式：**A · B = C**

### 3.2 R1CS 的問題

**表達能力有限**：
- 只能表達雙線性關係
- 需要多個約束來表達簡單運算

**例子**：計算 a + b + c
- R1CS 需要引入中間變數：
  - temp = a + b
  - result = temp + c
- 需要 2 個約束和 1 個額外變數

### 3.3 PLONK Gate 的優勢

**更豐富的表達能力**：
- 一個門可以同時包含加法和乘法
- 更少的約束數量
- 更直觀的電路設計

**對比表**：

| 運算 | R1CS 約束數 | PLONK 門數 |
|------|-------------|------------|
| a + b | 1 | 1 |
| a × b | 1 | 1 |
| a + b + c | 2 | 1 |
| a × b + c | 2 | 1 |
| a × b + a | 2 | 1 |

### 3.4 靈活性體現

PLONK 門可以在一個約束中表達：
- 線性組合：q_L·a + q_R·b + q_O·c
- 雙線性項：q_M·(a×b)
- 常數項：q_C

這使得電路設計更加靈活和高效。

---

## 第四課：實戰演練

### 4.1 設計平方門

**目標**：實現 a² = c

**思路**：令 w_a = w_b = a，使用乘法門

**配置**：
- q_L = 0
- q_R = 0  
- q_O = -1
- q_M = 1
- q_C = 0

**約束**：w_a × w_a = w_c

### 4.2 設計多項式求值

**目標**：實現 f(x) = x² + 2x + 1 在某點的求值

這需要多個門的組合：
1. 門1：計算 x² 
2. 門2：計算 2x
3. 門3：計算 x² + 2x + 1

**練習 4.1**
為上述多項式求值設計具體的門配置。

### 4.3 布爾約束

**目標**：約束 a 必須是 0 或 1

**思路**：使用 a × (a - 1) = 0

這意味著 a = 0 或 a = 1

**配置**：
- q_L = -1
- q_R = 0
- q_O = 0  
- q_M = 1
- q_C = 0

約束：w_a × w_a - w_a = 0

---

## 模組總結

通過本模組，我們深入理解了：

1. **PLONK 核心公式**的每個組件及其作用
2. **選擇子配置**如何決定門的行為
3. **電路設計**的基本技巧和模式
4. **PLONK vs R1CS** 的優勢對比

### 核心洞察

- PLONK 門是一個**可程式化的約束模板**
- 通過調整選擇子，可以實現各種算術運算
- 單個 PLONK 門比 R1CS 約束更具表達力

## 自我檢驗

在進入下一模組前，請確認您能夠：
- [ ] 解釋 PLONK 核心公式中每個項的含義
- [ ] 設計基本的算術門（加法、乘法、常數）
- [ ] 理解選擇子如何控制門的行為
- [ ] 對比 PLONK 和 R1CS 的差異

## 下一步

掌握了單個門的設計後，我們需要學習如何將多個門「連接」起來形成完整的電路。讓我們進入[第二模組：連接電路 - 置換參數的魔法](../module_2_permutation/)！