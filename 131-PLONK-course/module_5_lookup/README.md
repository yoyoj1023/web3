# 第五模組：效能渦輪 - 使用查找表 (Lookup Arguments)

## 模組目標
學習 PLONK 的一項關鍵優化，以極低成本處理複雜運算。

## 心智模型
與其在電路裡費力計算 `sin(x)`，不如直接查一本預先計算好的「三角函數表」。

---

## 第一課：SNARK-unfriendly 運算的挑戰

### 1.1 什麼是 SNARK-unfriendly？

某些運算在傳統電路中極其昂貴：

**範圍檢查 (Range Check)**：
- 問題：驗證 x 是否在 [0, 2^16) 範圍內
- 天真方法：分解為 16 個二進制位，需要 16 個布爾約束
- 成本：每個範圍檢查需要 16 個門

**位元運算 (Bitwise Operations)**：
- 問題：計算 a AND b, a XOR b 等
- 天真方法：分解為位元級運算
- 成本：32位操作需要 32 個門

**除法運算**：
- 問題：計算 a / b（整數除法）
- 天真方法：使用乘法和範圍檢查
- 成本：非常高，需要多輪交互

### 1.2 成本分析

假設一個簡單的範圍檢查：

```
傳統方法：
- 分解 x = b₀ + 2b₁ + 4b₂ + ... + 2^15·b₁₅
- 每個 bᵢ 需要布爾約束：bᵢ(bᵢ-1) = 0
- 總計：16 個門 + 額外的加法門
```

**問題**：對於複雜應用（如 zkEVM），這樣的成本無法承受。

### 1.3 查找表的直觀想法

**新思路**：預先計算一張「有效值表」，證明用到的值都在表中。

```
範圍表 T = [0, 1, 2, 3, ..., 65535]
查找值 L = [x₁, x₂, x₃, ...]

證明：L 中的每個值都出現在 T 中
```

---

## 第二課：Plookup 協議的直覺

### 2.1 核心想法

**Plookup 聲明**：「我在計算中用到的這些值，都可以在預先定義的表格中找到」

**數學表述**：
- 表格 T = [t₁, t₂, ..., tₙ]
- 查找值 L = [l₁, l₂, ..., lₘ]  
- 目標：證明 L ⊆ T（L 是 T 的子集）

### 2.2 子集檢查的挑戰

**天真方法**：為每個 lᵢ，找到對應的 tⱼ 使得 lᵢ = tⱼ
- 問題：需要 m×n 次比較
- 複雜度：O(mn)

**更好的方法**：使用置換參數的技巧！

### 2.3 置換參數的推廣

**核心洞察**：子集關係可以轉化為置換關係

如果 L ⊆ T，那麼存在一個「擴展的 L」，使得它是 T 的置換。

**構造方法**：
```
T = [1, 2, 3, 4, 5]
L = [2, 4, 2]
擴展的 L' = [2, 4, 2, 1, 3, 5] （添加 T 中未被查找的元素）
```

現在 L' 是 T 的置換！

---

## 第三課：Plookup 的工作原理

### 3.1 算法步驟

**步驟1**：排序
- 對 T 和 L 分別排序：T_sorted, L_sorted
- 如果 L ⊆ T，那麼 L_sorted 可以「合併」進 T_sorted

**步驟2**：合併檢查
- 構造合併序列 F
- F 應該包含 T_sorted 的所有元素，加上 L_sorted 的所有元素
- F 的長度 = |T| + |L|

**步驟3**：一致性驗證
- 驗證 F 是 T_sorted 和 L_sorted 的正確合併
- 使用置換參數技術

### 3.2 詳細例子

**表格**：T = [5, 1, 3, 2, 4]
**查找**：L = [2, 5, 1]

**排序**：
- T_sorted = [1, 2, 3, 4, 5]  
- L_sorted = [1, 2, 5]

**合併**：
- F = [1, 1, 2, 2, 3, 4, 5, 5]
- 每個表格元素出現一次，每個查找元素額外出現一次

### 3.3 合併的驗證

**一致性檢查**：
1. F 的前 |L| 個元素應該是 L_sorted 的置換
2. F 的後 |T| 個元素應該是 T_sorted 的置換  
3. F 是非遞減序列

這可以用多項式約束來表達！

---

## 第四課：多項式實現

### 4.1 多項式表示

將序列轉化為多項式：
- F(X)：插值合併序列
- T_sorted(X)：插值排序表格
- L_sorted(X)：插值排序查找值

### 4.2 差分約束

**非遞減檢查**：
對於相鄰元素，F(ωⁱ⁺¹) - F(ωⁱ) ≥ 0

**多項式約束**：
```
(F(ωX) - F(X)) × (F(ωX) - F(X) - 1) = 0
```

這確保了差值要麼是 0（相等），要麼是 1（遞增 1）。

### 4.3 置換約束

使用類似 PLONK 的置換參數：
- 驗證 F 的前半部分是 L_sorted 的置換
- 驗證 F 的後半部分是 T_sorted 的置換

### 4.4 隨機線性組合

使用隨機挑戰 γ：
```
F'(X) = F(X) + γ
T'(X) = T_sorted(X) + γ  
L'(X) = L_sorted(X) + γ
```

然後檢查積的相等性。

---

## 第五課：高效的表格設計

### 5.1 預計算表格

**範圍表格**：
```
T_range = [0, 1, 2, ..., 2^k - 1]
```

**位元運算表格**：
```
T_and = [(a, b, a AND b) for a, b in [0, 2^k)]
T_xor = [(a, b, a XOR b) for a, b in [0, 2^k)]
```

**算術表格**：
```
T_sqrt = [(x, √x) for x in perfect_squares]
T_log = [(x, log₂(x)) for x in powers_of_2]
```

### 5.2 多維表格

對於複雜運算，可以使用多列表格：

```
ADD_table = [
    (a, b, a+b) for a, b in [0, 2^8) 
    if a + b < 2^8
]
```

查找 (a, b, c) 證明 c = a + b。

### 5.3 表格壓縮技巧

**稀疏表格**：只包含「有趣」的值
**分層表格**：大表格分解為小表格的組合
**共享表格**：多個電路共用相同的表格

---

## 第六課：實際應用場景

### 6.1 zkEVM 中的應用

**EVM 操作碼**：
- ADD, SUB, MUL：使用算術表格
- AND, OR, XOR：使用位元運算表格  
- LT, GT：使用比較表格

**內存訪問**：
- 地址範圍檢查
- 值的有效性檢查

### 6.2 隱私計算

**範圍證明**：
- 年齡在 [18, 65] 之間
- 收入在合理範圍內

**格式驗證**：
- 電子郵件格式
- 身份證號格式

### 6.3 DeFi 應用

**價格預言機**：
- 價格在合理範圍內
- 時間戳的有效性

**風險模型**：
- 抵押率計算
- 清算閾值檢查

---

## 第七課：性能分析

### 7.1 成本對比

**傳統方法 vs Lookup**：

| 運算 | 傳統門數 | Lookup 成本 | 改進倍數 |
|------|----------|-------------|----------|
| 16位範圍檢查 | 16 | 1 | 16x |
| 32位 AND | 32 | 1 | 32x |
| 除法 | ~100 | 1 | 100x |

### 7.2 表格大小的權衡

**表格越大**：
- 支持更多運算
- 可信設置成本增加
- 內存需求增加

**表格越小**：
- 運算範圍受限
- 可能需要多次查找

### 7.3 實際性能數據

在現代硬件上：
- 表格預計算：一次性成本
- 查找證明生成：亞線性增長
- 驗證時間：常數級

---

## 模組總結

通過本模組，我們學習了：

1. **SNARK-unfriendly 運算**的性能瓶頸
2. **Plookup 協議**的核心思想和實現
3. **表格設計**的策略和技巧
4. **實際應用**場景和性能優勢

### 核心洞察

- 查找表將複雜運算的成本從 O(k) 降至 O(1)
- 預計算的表格可以在多個證明間重用
- 正確的表格設計是系統性能的關鍵

## 自我檢驗

在進入下一模組前，請確認您能夠：
- [ ] 解釋什麼運算是 SNARK-unfriendly 的
- [ ] 理解 Plookup 的核心思想
- [ ] 設計簡單的查找表格
- [ ] 分析查找表帶來的性能提升

## 下一步

PLONK 的模塊化設計讓我們可以替換不同的組件。讓我們學習如何將 PLONK 與不同的多項式承諾方案結合：[第六模組：零件互換 - PLONK + FRI 的組合藝術](../module_6_modularity/)！