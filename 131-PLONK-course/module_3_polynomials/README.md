# 第三模組：語言轉換 - 從電路到多項式 (From Circuits to Polynomials)

## 模組目標
理解 PLONK 如何將整個電路的約束「打包」進幾個多項式恆等式中。

## 心智模型
將離散的、一個個的門約束，轉化為連續的、光滑的多項式曲線。

---

## 第一課：視角提升

### 1.1 從離散到連續

在前兩個模組中，我們思考的是「第i個門」的約束。現在我們要提升視角：

**舊視角**：
- 第1門：q_L[1] * w_a[1] + ... = 0
- 第2門：q_L[2] * w_a[2] + ... = 0
- ...

**新視角**：
- w_a 不再是數組，而是一個**多項式** w_a(X)
- q_L 也是一個多項式 q_L(X)
- 在特定點 ω^i 上，w_a(ω^i) = w_a[i]

### 1.2 域的根 (Roots of Unity)

**關鍵工具**：使用 n 次單位根 ω

性質：
- ω^n = 1
- ω^0, ω^1, ω^2, ..., ω^(n-1) 是 n 個不同的值
- 這些值形成一個循環群

**直觀理解**：
想像一個有 n 個刻度的圓形表盤，ω 是從0點到第一個刻度的旋轉角度。

### 1.3 多項式插值的應用

給定門的數據：
- w_a[0], w_a[1], ..., w_a[n-1]

可以構造唯一的多項式 w_a(X)，使得：
- w_a(ω^0) = w_a[0]
- w_a(ω^1) = w_a[1]
- ...
- w_a(ω^(n-1)) = w_a[n-1]

**練習 3.1**
如果有3個門，w_a 的值分別是 [2, 5, 8]，且 ω³ = 1，那麼 w_a(X) 在 ω² 處的值是什麼？

<details>
<summary>答案</summary>

w_a(ω²) = 8，因為這對應第3個門（索引2）的值。

</details>

---

## 第二課：整合門約束

### 2.1 約束多項式的定義

定義**約束多項式** P(X)：

```
P(X) = q_L(X) * w_a(X) + q_R(X) * w_b(X) + q_O(X) * w_c(X) + q_M(X) * w_a(X) * w_b(X) + q_C(X)
```

### 2.2 關鍵性質

如果所有門約束都滿足，那麼：
- P(ω^0) = 0 （第1門的約束）
- P(ω^1) = 0 （第2門的約束）
- ...
- P(ω^(n-1)) = 0 （第n門的約束）

**核心洞察**：一個多項式 P(X) 編碼了所有門的約束！

### 2.3 實例演示

**電路**：
- 門1：a + b = c （加法門）
- 門2：c × d = e （乘法門）

**多項式**：
- w_a(X)：插值 [a, c]
- w_b(X)：插值 [b, d]  
- w_c(X)：插值 [c, e]
- q_L(X)：插值 [1, 0] （門1啟用左輸入，門2不用）
- q_R(X)：插值 [1, 0] （門1啟用右輸入，門2不用）
- ...

**驗證**：
- P(ω^0) = 1·a + 1·b + (-1)·c + 0·(a×b) + 0 = a + b - c = 0 ✓
- P(ω^1) = 0·c + 0·d + (-1)·e + 1·(c×d) + 0 = cd - e = 0 ✓

---

## 第三課：零化多項式 (Vanishing Polynomial)

### 3.1 零化多項式的定義

**零化多項式** Z_H(X) 是在所有門的座標上都為0的多項式：

```
Z_H(X) = (X - ω^0)(X - ω^1)...(X - ω^(n-1)) = X^n - 1
```

### 3.2 為什麼叫「零化」？

- 在每個門的位置 ω^i 上，Z_H(ω^i) = 0
- 「零化」了所有我們關心的點

### 3.3 整除性的關鍵洞察

**核心定理**：如果多項式 f(X) 在點 a 處的值為0，那麼 f(X) 可以被 (X-a) 整除。

**推廣**：如果 P(X) 在 ω^0, ω^1, ..., ω^(n-1) 處都為0，那麼 P(X) 可以被 Z_H(X) 整除。

### 3.4 商多項式的引入

如果所有約束都滿足，存在多項式 t(X) 使得：

```
P(X) = t(X) * Z_H(X)
```

這個 t(X) 就是**商多項式 (Quotient Polynomial)**。

---

## 第四課：商多項式 (Quotient Polynomial)

### 4.1 商多項式的意義

**數學意義**：t(X) = P(X) / Z_H(X)

**實際意義**：
- 如果能計算出 t(X)，說明 P(X) 確實被 Z_H(X) 整除
- 這證明了所有門約束都被滿足

### 4.2 次數分析

假設電路有 n 個門：
- P(X) 的次數最多是 2n-1（因為有 w_a(X) × w_b(X) 項）
- Z_H(X) 的次數是 n
- 所以 t(X) 的次數最多是 n-1

### 4.3 Prover 的任務

Prover 需要：
1. 計算所有線路多項式 w_a(X), w_b(X), w_c(X)
2. 構造約束多項式 P(X)
3. 計算商多項式 t(X) = P(X) / Z_H(X)
4. 證明 P(X) = t(X) × Z_H(X)

### 4.4 高效計算技巧

**多項式長除法**：
- 直接計算會很慢
- 使用 FFT 可以加速到 O(n log n)

**分段計算**：
- 將 t(X) 分成幾個低次多項式
- 分別對每部分進行承諾

---

## 第五課：整合置換約束

### 5.1 置換約束的多項式表示

類似地，第二模組的置換約束也需要轉化為多項式形式。

**置換多項式** Z_perm(X) 滿足：

```
L_1(X) * (Z_perm(X) - 1) = 0
```

其中 L_1(X) 是拉格朗日基多項式，在 ω^0 處為1，其他地方為0。

### 5.2 置換的遞推關係

對於 i = 0, 1, ..., n-2：

```
Z_perm(ω^(i+1)) * denominator(ω^i) = Z_perm(ω^i) * numerator(ω^i)
```

這個關係也需要在多項式層面表達。

### 5.3 統一的約束系統

最終，PLONK 系統有兩大類約束：
1. **門約束**：P_gate(X) = t_gate(X) × Z_H(X)
2. **置換約束**：P_perm(X) = t_perm(X) × Z_H(X)

---

## 第六課：完整的多項式恆等式

### 6.1 約束的線性組合

使用隨機挑戰 α，將所有約束組合：

```
P_total(X) = P_gate(X) + α * P_perm(X)
```

相應地：

```
t_total(X) = t_gate(X) + α * t_perm(X)
```

### 6.2 最終的恆等式

PLONK 的核心恆等式：

```
P_total(X) = t_total(X) * Z_H(X)
```

### 6.3 驗證的策略

Verifier 只需要：
1. 在隨機點 z 處評估兩邊
2. 檢查 P_total(z) = t_total(z) × Z_H(z)
3. 使用多項式承諾來確保評估的正確性

---

## 第七課：多項式次數的管理

### 7.1 次數爆炸問題

當電路複雜時，多項式的次數會很高：
- 存儲和計算成本急劇增加
- 需要更大的可信設置

### 7.2 分割技巧

將高次的 t(X) 分割成多個低次多項式：

```
t(X) = t_lo(X) + X^n * t_mid(X) + X^(2n) * t_hi(X)
```

每個部分的次數都小於 n。

### 7.3 分別承諾

對 t_lo, t_mid, t_hi 分別進行多項式承諾，降低整體複雜度。

---

## 模組總結

通過本模組，我們實現了重要的「語言轉換」：

1. **視角提升**：從離散數組到連續多項式
2. **約束整合**：所有門約束被編碼進一個多項式
3. **零化多項式**：提供整除性檢查的數學工具
4. **商多項式**：證明約束滿足的核心對象

### 核心洞察

- 多項式是編碼複雜信息的強大工具
- 整除性檢查將約束驗證轉化為代數問題
- 隨機線性組合讓我們能同時處理多種約束

## 自我檢驗

在進入下一模組前，請確認您能夠：
- [ ] 解釋從離散約束到多項式約束的轉換
- [ ] 理解零化多項式的作用和性質
- [ ] 描述商多項式的計算和意義
- [ ] 分析多項式次數對系統性能的影響

## 下一步

現在我們有了完整的數學框架，是時候看看 PLONK 協議是如何實際運行的。讓我們進入[第四模組：系統整合 - 完整的證明與驗證流程](../module_4_protocol/)！