# æœ€çµ‚æ¨¡çµ„ï¼šå‹•æ‰‹å¯¦ä½œ - ç†è«–èˆ‡å¯¦è¸ (Hands-on Lab)

## æ¨¡çµ„ç›®æ¨™
å°‡ç†è«–çŸ¥è­˜è½‰åŒ–ç‚ºå¯¦éš›æŠ€èƒ½ã€‚

## å¿ƒæ™ºæ¨¡å‹
å¾ã€Œç´™ä¸Šè«‡å…µã€åˆ°ã€Œå¯¦æˆ°æ¼”ç·´ã€ï¼ŒçœŸæ­£æŒæ¡ PLONK çš„ç²¾é«“ã€‚

---

## ç¬¬ä¸€èª²ï¼šé›»è·¯è¨­è¨ˆç·´ç¿’

### 1.1 ç°¡å–®é›»è·¯ï¼šå¹³æ–¹æ ¹æª¢æŸ¥

**å•é¡Œ**ï¼šè­‰æ˜ä½ çŸ¥é“ x ä½¿å¾— xÂ² = yï¼Œä½†ä¸é€éœ² x çš„å€¼

**é›»è·¯è¨­è¨ˆ**ï¼š
```
é–€1: x Ã— x = y
```

**PLONK é…ç½®**ï¼š
- q_L = 0
- q_R = 0  
- q_O = -1
- q_M = 1
- q_C = 0

**ç·šè·¯å€¼**ï¼ˆå‡è¨­ x = 5, y = 25ï¼‰ï¼š
- w_a = 5
- w_b = 5
- w_c = 25

**ç·´ç¿’ 1.1**ï¼šç‚º x = 7, y = 49 å¡«å¯«ç·šè·¯å€¼ã€‚

### 1.2 ä¸­ç­‰é›»è·¯ï¼šMiMC å“ˆå¸Œå‡½æ•¸

**MiMC ç®—æ³•**ï¼š
```
for i in range(rounds):
    x = (x + key + constants[i])^3
return x
```

**é›»è·¯åˆ†è§£**ï¼ˆå–®è¼ªï¼‰ï¼š
```
é–€1: temp1 = x + key + c_i
é–€2: temp2 = temp1 Ã— temp1  
é–€3: result = temp2 Ã— temp1
```

**è¤‡è£½ç´„æŸ**ï¼š
- é–€1çš„è¼¸å‡º = é–€2çš„å·¦è¼¸å…¥
- é–€1çš„è¼¸å‡º = é–€3çš„å³è¼¸å…¥
- é–€2çš„è¼¸å‡º = é–€3çš„å·¦è¼¸å…¥

**ç·´ç¿’ 1.2**ï¼šç‚º 3 è¼ª MiMC è¨­è¨ˆå®Œæ•´é›»è·¯ã€‚

### 1.3 è¤‡é›œé›»è·¯ï¼šFibonacci æ•¸åˆ—

**å•é¡Œ**ï¼šè­‰æ˜ç¬¬ n å€‹ Fibonacci æ•¸æ˜¯ F_n

**é›»è·¯è¨­è¨ˆ**ï¼š
```
F_0 = 0
F_1 = 1
for i from 2 to n:
    F_i = F_{i-1} + F_{i-2}
```

**é–€çš„è¨­è¨ˆ**ï¼š
```
é–€i: w_a[i] + w_b[i] = w_c[i]
```

å…¶ä¸­ï¼š
- w_a[i] = F_{i-2}
- w_b[i] = F_{i-1}  
- w_c[i] = F_i

**è¤‡è£½ç´„æŸ**ï¼š
- w_c[i] = w_b[i+1]
- w_b[i] = w_a[i+1]

**ç·´ç¿’ 1.3**ï¼šç‚ºè¨ˆç®— F_10 è¨­è¨ˆå®Œæ•´é›»è·¯ï¼Œä¸¦åˆ—å‡ºæ‰€æœ‰è¤‡è£½ç´„æŸã€‚

---

## ç¬¬äºŒèª²ï¼šå¤šé …å¼æ§‹é€ å¯¦æˆ°

### 2.1 æ‰‹ç®—ç·šè·¯å¤šé …å¼

**é›»è·¯**ï¼š
```
é–€1: 2 + 3 = 5
é–€2: 5 Ã— 4 = 20
```

**åŸŸè¨­ç½®**ï¼šä½¿ç”¨ F_17ï¼ŒÏ‰ = 3ï¼ˆå› ç‚º 3Â² = 9 â‰  1, 3â´ = 81 â‰¡ 13 â‰  1, ä½† 3^8 â‰¡ 1ï¼‰

ç­‰ä¸€ä¸‹ï¼Œè®“æˆ‘å€‘ç”¨æ›´ç°¡å–®çš„è¨­ç½®ï¼šF_5, Ï‰ = 2ï¼ˆå› ç‚º 2â´ = 16 â‰¡ 1 (mod 5)ï¼‰

**ç·šè·¯å€¼**ï¼š
- w_a = [2, 5]  
- w_b = [3, 4]
- w_c = [5, 20] â‰¡ [5, 0] (mod 5)

**å¤šé …å¼æ’å€¼**ï¼š
ç›®æ¨™ï¼šæ‰¾åˆ° w_a(X) ä½¿å¾— w_a(Ï‰â°) = w_a(1) = 2, w_a(Ï‰Â¹) = w_a(2) = 5

ä½¿ç”¨æ‹‰æ ¼æœ—æ—¥æ’å€¼ï¼š
```
w_a(X) = 2 Ã— (X-2)/(1-2) + 5 Ã— (X-1)/(2-1)
       = 2 Ã— (X-2)/(-1) + 5 Ã— (X-1)/1
       = -2(X-2) + 5(X-1)
       = -2X + 4 + 5X - 5
       = 3X - 1
```

**é©—è­‰**ï¼š
- w_a(1) = 3Ã—1 - 1 = 2 âœ“
- w_a(2) = 3Ã—2 - 1 = 5 âœ“

**ç·´ç¿’ 2.1**ï¼šè¨ˆç®— w_b(X) å’Œ w_c(X)ã€‚

### 2.2 ç´„æŸå¤šé …å¼æ§‹é€ 

**é¸æ“‡å­è¨­ç½®**ï¼š
- é–€1ï¼ˆåŠ æ³•ï¼‰ï¼šq_L=1, q_R=1, q_O=-1, q_M=0, q_C=0
- é–€2ï¼ˆä¹˜æ³•ï¼‰ï¼šq_L=0, q_R=0, q_O=-1, q_M=1, q_C=0

**é¸æ“‡å­å¤šé …å¼**ï¼š
```
q_L(X) = 1 Ã— (X-2)/(1-2) + 0 Ã— (X-1)/(2-1) = -(X-2) = -X+2
q_M(X) = 0 Ã— (X-2)/(1-2) + 1 Ã— (X-1)/(2-1) = X-1
```

**ç´„æŸå¤šé …å¼**ï¼š
```
P(X) = q_L(X)w_a(X) + q_R(X)w_b(X) + q_O(X)w_c(X) + q_M(X)w_a(X)w_b(X) + q_C(X)
```

**ç·´ç¿’ 2.2**ï¼šè¨ˆç®— P(1) å’Œ P(2)ï¼Œé©—è­‰å®ƒå€‘éƒ½ç­‰æ–¼ 0ã€‚

### 2.3 å•†å¤šé …å¼è¨ˆç®—

**é›¶åŒ–å¤šé …å¼**ï¼š
```
Z_H(X) = (X-1)(X-2) = XÂ² - 3X + 2
```

**å•†å¤šé …å¼**ï¼š
```
t(X) = P(X) / Z_H(X)
```

ç”±æ–¼ P(1) = P(2) = 0ï¼ŒP(X) å¿…å®šèƒ½è¢« Z_H(X) æ•´é™¤ã€‚

**ç·´ç¿’ 2.3**ï¼šåŸ·è¡Œå¤šé …å¼é•·é™¤æ³•ï¼Œè¨ˆç®— t(X)ã€‚

---

## ç¬¬ä¸‰èª²ï¼šç¨‹å¼ç¢¼åº«æ¢ç´¢

### 3.1 Plonky2 åŸå§‹ç¢¼çµæ§‹

**æ ¸å¿ƒæ¨¡å¡Š**ï¼š
```
plonky2/
â”œâ”€â”€ field/           # æœ‰é™é«”å¯¦ç¾
â”œâ”€â”€ fri/             # FRI æ‰¿è«¾æ–¹æ¡ˆ
â”œâ”€â”€ gates/           # å„ç¨®é–€çš„å¯¦ç¾
â”œâ”€â”€ hash/            # å“ˆå¸Œå‡½æ•¸
â”œâ”€â”€ iop/             # IOP (Interactive Oracle Proof)
â”œâ”€â”€ plonk/           # PLONK å”è­°æ ¸å¿ƒ
â”œâ”€â”€ poly/            # å¤šé …å¼é‹ç®—
â””â”€â”€ util/            # å·¥å…·å‡½æ•¸
```

### 3.2 é–€çš„å¯¦ç¾åˆ†æ

**æ‰¾åˆ°åŠ æ³•é–€**ï¼š
```rust
// plonky2/src/gates/arithmetic_gate.rs
pub struct ArithmeticGate {
    pub num_ops: usize,
}

impl Gate for ArithmeticGate {
    fn eval_unfiltered(&self, vars: EvaluationVars) -> Vec<F> {
        // å¯¦ç¾ q_L * w_a + q_R * w_b + q_O * w_c + q_M * (w_a * w_b) + q_C
    }
}
```

**ç·´ç¿’ 3.1**ï¼šé–±è®€ `arithmetic_gate.rs`ï¼Œæ‰¾åˆ°å°æ‡‰æˆ‘å€‘å­¸ç¿’çš„ PLONK å…¬å¼çš„ç¨‹å¼ç¢¼ã€‚

### 3.3 å¤šé …å¼æ‰¿è«¾çš„å¯¦ç¾

**FRI å¯¦ç¾**ï¼š
```rust
// plonky2/src/fri/prover.rs
pub fn prove(&self, polynomial: &Polynomial) -> FriProof {
    // FRI è­‰æ˜ç”Ÿæˆ
}

// plonky2/src/fri/verifier.rs  
pub fn verify(&self, proof: &FriProof) -> bool {
    // FRI è­‰æ˜é©—è­‰
}
```

**ç·´ç¿’ 3.2**ï¼šè¿½è¹¤ä¸€å€‹å¤šé …å¼å¾æ‰¿è«¾åˆ°æ‰“é–‹çš„å®Œæ•´æµç¨‹ã€‚

### 3.4 ç½®æ›åƒæ•¸çš„å¯¦ç¾

**ç½®æ›å¤šé …å¼**ï¼š
```rust
// plonky2/src/plonk/permutation_argument.rs
pub fn compute_permutation_z_polys(
    gate_constraints: &[GateConstraint],
    permutation: &Permutation,
) -> Vec<Polynomial> {
    // è¨ˆç®—ç½®æ›å¤šé …å¼ Z(X)
}
```

**ç·´ç¿’ 3.3**ï¼šç†è§£ç½®æ›å¤šé …å¼çš„å…·é«”è¨ˆç®—éç¨‹ã€‚

---

## ç¬¬å››èª²ï¼šä½¿ç”¨é«˜éšèªè¨€

### 4.1 Circom å¯¦ç¾

**å®‰è£ Circom**ï¼š
```bash
npm install -g circom
npm install -g snarkjs
```

**ç°¡å–®é›»è·¯**ï¼š
```javascript
// square.circom
pragma circom 2.0.0;

template Square() {
    signal input x;
    signal output y;
    
    y <== x * x;
}

component main = Square();
```

**ç·¨è­¯å’Œæ¸¬è©¦**ï¼š
```bash
circom square.circom --r1cs --wasm --sym
echo '{"x": "5"}' > input.json
node square_js/generate_witness.js square_js/square.wasm input.json witness.wtns
```

**ç·´ç¿’ 4.1**ï¼šå¯¦ç¾ MiMC å“ˆå¸Œçš„ Circom ç‰ˆæœ¬ã€‚

### 4.2 Noir å¯¦ç¾

**å®‰è£ Noir**ï¼š
```bash
curl -L noirup.dev | bash
noirup
```

**ç°¡å–®é›»è·¯**ï¼š
```rust
// main.nr
fn main(x: Field, y: pub Field) {
    assert(x * x == y);
}
```

**æ¸¬è©¦**ï¼š
```bash
nargo check
nargo test
nargo prove
nargo verify
```

**ç·´ç¿’ 4.2**ï¼šç”¨ Noir å¯¦ç¾ Fibonacci æ•¸åˆ—é©—è­‰ã€‚

### 4.3 Plonky2 ç›´æ¥ä½¿ç”¨

**Rust é …ç›®è¨­ç½®**ï¼š
```toml
[dependencies]
plonky2 = "0.1"
```

**ç°¡å–®é›»è·¯**ï¼š
```rust
use plonky2::plonk::circuit_builder::CircuitBuilder;
use plonky2::field::goldilocks_field::GoldilocksField;

fn main() {
    let mut builder = CircuitBuilder::<GoldilocksField, 2>::new();
    
    // æ·»åŠ è¼¸å…¥
    let x = builder.add_virtual_target();
    let y = builder.add_virtual_target();
    
    // æ·»åŠ ç´„æŸï¼šx * x = y
    let x_squared = builder.mul(x, x);
    builder.connect(x_squared, y);
    
    // è¨­ç‚ºå…¬é–‹è¼¸å…¥
    builder.register_public_input(y);
    
    // æ§‹å»ºé›»è·¯
    let data = builder.build::<C>();
}
```

**ç·´ç¿’ 4.3**ï¼šå¯¦ç¾ä¸€å€‹ç°¡å–®çš„ç¯„åœæª¢æŸ¥é›»è·¯ã€‚

---

## ç¬¬äº”èª²ï¼šæ€§èƒ½åˆ†æèˆ‡å„ªåŒ–

### 5.1 åŸºæº–æ¸¬è©¦

**æ¸¬è©¦é›»è·¯**ï¼š
- å°å‹ï¼š100 å€‹é–€
- ä¸­å‹ï¼š10,000 å€‹é–€  
- å¤§å‹ï¼š1,000,000 å€‹é–€

**æŒ‡æ¨™æ¸¬é‡**ï¼š
```rust
use std::time::Instant;

let start = Instant::now();
let proof = prover.prove(witness);
let prove_time = start.elapsed();

let start = Instant::now();
let is_valid = verifier.verify(proof);
let verify_time = start.elapsed();

println!("Prove time: {:?}", prove_time);
println!("Verify time: {:?}", verify_time);
println!("Proof size: {} bytes", proof.len());
```

**ç·´ç¿’ 5.1**ï¼šæ¸¬è©¦ä¸åŒé›»è·¯å¤§å°çš„æ€§èƒ½è¡¨ç¾ã€‚

### 5.2 ç“¶é ¸è­˜åˆ¥

**å¸¸è¦‹ç“¶é ¸**ï¼š
1. **FFT è¨ˆç®—**ï¼šå¤šé …å¼é‹ç®—çš„ä¸»è¦æˆæœ¬
2. **å“ˆå¸Œè¨ˆç®—**ï¼šMerkle tree æ§‹å»º
3. **è¨˜æ†¶é«”è¨ªå•**ï¼šå¤§å‹å¤šé …å¼çš„å­˜å–

**åˆ†æå·¥å…·**ï¼š
```bash
# CPU åˆ†æ
perf record ./your_program
perf report

# è¨˜æ†¶é«”åˆ†æ  
valgrind --tool=massif ./your_program
```

**ç·´ç¿’ 5.2**ï¼šåˆ†æä½ çš„é›»è·¯çš„æ€§èƒ½ç“¶é ¸ã€‚

### 5.3 å„ªåŒ–ç­–ç•¥

**ä¸¦è¡ŒåŒ–**ï¼š
```rust
use rayon::prelude::*;

// ä¸¦è¡Œ FFT
let coeffs: Vec<_> = (0..n).into_par_iter()
    .map(|i| compute_coeff(i))
    .collect();
```

**è¨˜æ†¶é«”å„ªåŒ–**ï¼š
```rust
// æµå¼è™•ç†å¤§å‹å¤šé …å¼
for chunk in polynomial.chunks(CHUNK_SIZE) {
    process_chunk(chunk);
}
```

**ç·´ç¿’ 5.3**ï¼šå¯¦ç¾ä¸€å€‹å„ªåŒ–ç‰ˆæœ¬çš„é›»è·¯ï¼Œä¸¦æ¯”è¼ƒæ€§èƒ½ã€‚

---

## ç¬¬å…­èª²ï¼šå¯¦éš›æ‡‰ç”¨é–‹ç™¼

### 6.1 é›¶çŸ¥è­˜æŠ•ç¥¨ç³»çµ±

**éœ€æ±‚**ï¼š
- ç”¨æˆ¶å¯ä»¥ç§˜å¯†æŠ•ç¥¨
- ä»»ä½•äººå¯ä»¥é©—è­‰æŠ•ç¥¨ç¸½æ•¸
- ç„¡æ³•è¿½è¹¤å€‹äººæŠ•ç¥¨

**é›»è·¯è¨­è¨ˆ**ï¼š
```
// æ¯å€‹æŠ•ç¥¨
è¼¸å…¥ï¼švoter_id (private), vote (private), nullifier (public)
ç´„æŸï¼š
1. vote âˆˆ {0, 1}  // ç¯„åœæª¢æŸ¥
2. nullifier = hash(voter_id, election_id)  // é˜²é‡æŠ•
3. å…¬é–‹ vote çš„æ‰¿è«¾
```

**ç·´ç¿’ 6.1**ï¼šå¯¦ç¾å®Œæ•´çš„æŠ•ç¥¨é›»è·¯ã€‚

### 6.2 éš±ç§ä¿è­·çš„èº«ä»½é©—è­‰

**éœ€æ±‚**ï¼š
- è­‰æ˜å¹´é½¡ â‰¥ 18
- ä¸é€éœ²å…·é«”å¹´é½¡
- é˜²æ­¢é‡æ”¾æ”»æ“Š

**é›»è·¯è¨­è¨ˆ**ï¼š
```
è¼¸å…¥ï¼šage (private), threshold=18 (public), nonce (public)
ç´„æŸï¼š
1. age â‰¥ threshold
2. è¼¸å‡º hash(age, nonce)
```

**ç·´ç¿’ 6.2**ï¼šæ·»åŠ é¡å¤–ç´„æŸï¼ˆå¦‚å¹´é½¡ â‰¤ 120ï¼‰ã€‚

### 6.3 é›¶çŸ¥è­˜æ©Ÿå™¨å­¸ç¿’

**éœ€æ±‚**ï¼š
- è­‰æ˜ ML æ¨¡å‹çš„é æ¸¬çµæœ
- ä¸é€éœ²æ¨¡å‹åƒæ•¸
- ä¿è­·è¼¸å…¥æ•¸æ“šéš±ç§

**é›»è·¯è¨­è¨ˆ**ï¼š
```
è¼¸å…¥ï¼šfeatures (private), weights (private), prediction (public)
ç´„æŸï¼š
1. prediction = model(features, weights)
2. æ¨¡å‹è¨ˆç®—çš„æ­£ç¢ºæ€§
```

**ç·´ç¿’ 6.3**ï¼šå¯¦ç¾ä¸€å€‹ç°¡å–®çš„ç·šæ€§å›æ­¸è­‰æ˜ã€‚

---

## ç¬¬ä¸ƒèª²ï¼šç”Ÿç”¢ç’°å¢ƒè€ƒæ…®

### 7.1 å®‰å…¨æ€§æª¢æŸ¥æ¸…å–®

**å¯ä¿¡è¨­ç½®**ï¼š
- [ ] ä½¿ç”¨ç¶“éå¯©è¨ˆçš„å¯ä¿¡è¨­ç½®
- [ ] é©—è­‰è¨­ç½®åƒæ•¸çš„æ­£ç¢ºæ€§
- [ ] ç¢ºä¿è¨­ç½®éç¨‹çš„é€æ˜æ€§

**å¯¦ç¾å®‰å…¨**ï¼š
- [ ] ä½¿ç”¨ç¶“éå¯©è¨ˆçš„åº«
- [ ] é˜²æ­¢æ—é“æ”»æ“Š
- [ ] å®‰å…¨çš„éš¨æ©Ÿæ•¸ç”Ÿæˆ

**å”è­°å®‰å…¨**ï¼š
- [ ] æ­£ç¢ºçš„åŸŸåƒæ•¸é¸æ“‡
- [ ] é©ç•¶çš„å®‰å…¨åƒæ•¸
- [ ] é˜²æ­¢å¸¸è¦‹æ”»æ“Šå‘é‡

### 7.2 å¯æ“´å±•æ€§è¨­è¨ˆ

**æ‰¹é‡è™•ç†**ï¼š
```rust
// æ‰¹é‡é©—è­‰å¤šå€‹è­‰æ˜
fn batch_verify(proofs: &[Proof]) -> bool {
    let combined = combine_proofs(proofs);
    verify_single(combined)
}
```

**éæ­¸è­‰æ˜**ï¼š
```rust
// è­‰æ˜å…¶ä»–è­‰æ˜çš„æœ‰æ•ˆæ€§
fn recursive_verify(inner_proof: Proof) -> Proof {
    // æ§‹å»ºé©—è­‰é›»è·¯
    // ç”ŸæˆåŒ…è£è­‰æ˜
}
```

**ç·´ç¿’ 7.1**ï¼šå¯¦ç¾ä¸€å€‹æ”¯æŒæ‰¹é‡é©—è­‰çš„ç³»çµ±ã€‚

### 7.3 éƒ¨ç½²å’Œç›£æ§

**éƒ¨ç½²æª¢æŸ¥**ï¼š
- æ€§èƒ½åŸºæº–æ¸¬è©¦
- è¨˜æ†¶é«”ä½¿ç”¨ç›£æ§
- éŒ¯èª¤è™•ç†æ©Ÿåˆ¶

**ç›£æ§æŒ‡æ¨™**ï¼š
```rust
struct Metrics {
    prove_time_avg: Duration,
    verify_time_avg: Duration,
    proof_size_avg: usize,
    success_rate: f64,
}
```

**ç·´ç¿’ 7.2**ï¼šè¨­è¨ˆä¸€å€‹å®Œæ•´çš„ç›£æ§ç³»çµ±ã€‚

---

## æ¨¡çµ„ç¸½çµ

é€šéæœ¬æ¨¡çµ„çš„å¯¦è¸ï¼Œæ‚¨å·²ç¶“ï¼š

1. **è¦ªæ‰‹è¨­è¨ˆ**äº†å„ç¨®è¤‡é›œåº¦çš„ PLONK é›»è·¯
2. **æ·±å…¥æ¢ç´¢**äº†å¯¦éš›çš„ ZK ç³»çµ±å¯¦ç¾
3. **ä½¿ç”¨é«˜éšèªè¨€**å¿«é€Ÿæ§‹å»º ZK æ‡‰ç”¨
4. **åˆ†æå’Œå„ªåŒ–**äº†ç³»çµ±æ€§èƒ½
5. **é–‹ç™¼å¯¦éš›æ‡‰ç”¨**ä¸¦è€ƒæ…®ç”Ÿç”¢ç’°å¢ƒéœ€æ±‚

### æ ¸å¿ƒæŠ€èƒ½

- é›»è·¯è¨­è¨ˆå’Œç´„æŸåˆ†æ
- å¤šé …å¼æ“ä½œå’Œæ€§èƒ½å„ªåŒ–  
- å¯¦éš›ç³»çµ±çš„å¯¦ç¾å’Œéƒ¨ç½²
- å®‰å…¨æ€§è€ƒæ…®å’Œæœ€ä½³å¯¦è¸

## æœ€çµ‚æª¢é©—

ç¢ºèªæ‚¨ç¾åœ¨èƒ½å¤ ï¼š
- [ ] ç¨ç«‹è¨­è¨ˆä¸­ç­‰è¤‡é›œåº¦çš„ ZK é›»è·¯
- [ ] é–±è®€å’Œç†è§£ ZK ç³»çµ±çš„åŸå§‹ç¢¼
- [ ] ä½¿ç”¨ä¸»æµå·¥å…·é–‹ç™¼ ZK æ‡‰ç”¨
- [ ] åˆ†æå’Œå„ªåŒ– ZK ç³»çµ±çš„æ€§èƒ½
- [ ] è€ƒæ…®ç”Ÿç”¢ç’°å¢ƒçš„å„ç¨®éœ€æ±‚

## æ­å–œç•¢æ¥­ï¼

æ‚¨ç¾åœ¨å·²ç¶“å®Œå…¨æŒæ¡äº† PLONK å”è­°çš„ç²¾é«“ï¼Œå…·å‚™äº†ï¼š
- æ·±å…¥çš„ç†è«–ç†è§£
- æ‰å¯¦çš„å¯¦è¸æŠ€èƒ½
- ç³»çµ±æ€§çš„æ€ç¶­æ–¹å¼
- è§£æ±ºå¯¦éš›å•é¡Œçš„èƒ½åŠ›

æº–å‚™å¥½æ¢ç´¢æ›´å»£é—Šçš„é›¶çŸ¥è­˜è­‰æ˜ä¸–ç•Œäº†ï¼ä¸‹ä¸€æ­¥ï¼Œæ‚¨å¯ä»¥ï¼š
- æ·±å…¥ç ”ç©¶ Plonky3 å’Œæœ€æ–°ç™¼å±•
- æ¢ç´¢å…¶ä»– ZK ç³»çµ±ï¼ˆSTARKs, Nova ç­‰ï¼‰
- é–‹ç™¼è‡ªå·±çš„ ZK æ‡‰ç”¨
- ç‚ºé–‹æº ZK é …ç›®åšå‡ºè²¢ç»

**é›¶çŸ¥è­˜è­‰æ˜çš„æœªä¾†åœ¨æ‚¨æ‰‹ä¸­ï¼** ğŸš€