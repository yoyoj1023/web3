PS C:\VScode\web3\150-EIP712-course> npx ts-node 01-fundamentals/comparison-demo.ts
==========================================
🔐 EIP712 vs 傳統簽名對比演示
==========================================

簽名者地址: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266

📝 方式 1: 傳統簽名 (eth_sign / personal_sign)
─────────────────────────────────────────

簽名內容（使用者看到的）:
  "Transfer 100 tokens to 0x70997970C51812dc3A010C7d01b50e0d17dc79C8"

實際簽名的數據（十六進制）:
  0x5472616e736665722031303020746f6b656e7320746f20307837303939373937304335313831326463334130313043376430316235306530643137646337394338

簽名結果:
  0x29c9d21f48ffca2376386c562e0add89b4f9c9e1bbfc1d9ceb3eae0a8af0323d07174806337addbab727c2ff208b6012906ff8745e4ee33f8f5993324cdd98c11b

❌ 傳統簽名的問題:
  1. 格式不固定：可以用任意字串拼接方式
  2. 無類型信息：不知道 '100' 是字串還是數字
  3. 缺乏結構：解析困難，容易出錯
  4. 無域隔離：同樣的簽名可能被其他 DApp 重放
  5. 盲簽風險：使用者看到的和實際簽的可能不一致



✅ 方式 2: EIP712 結構化簽名
─────────────────────────────────────────

Domain（應用身份）:
{
  "name": "MyToken",
  "version": "1",
  "chainId": 1,
  "verifyingContract": "0x1111111111111111111111111111111111111111"
}

Types（數據結構定義）:
{
  "Transfer": [
    {
      "name": "to",
      "type": "address"
    },
    {
      "name": "amount",
      "type": "uint256"
    },
    {
      "name": "deadline",
      "type": "uint256"
    }
  ]
}

Value（實際數據）:
{
  "to": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
  "amount": "100",
  "deadline": "1234567890"
}

簽名結果:
  0xe4e8132069eb36f167cd37e70b92b5edc162f8792715e1dfdd46e4f1430dfaa43b14bac0c653a2ea9f29d7ca32689abe454991f888b4c206524c2292683b18221b

編碼細節:
  Domain TypeHash: 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f
  Domain Separator: 0x98a000c59add584118697238deb65a508461c73c65bc49956fb97bfc568c30c8

  Transfer TypeHash: 0x466c37c885513f4102dc151497d0ad1179f9e5f07ea8826019462d67d18d3dd4
  Struct Hash: 0xea2af74a5295402b8547ac21f49dd0beb870b481b70702acb31740b3341452d2

  Final Digest: 0x85dd4d813e06eaabde133dc2152b7f922dd1555e7d018f02ed0ef844029b742b

✅ EIP712 的優勢:
  1. 結構明確：有清楚的類型定義
  2. 類型安全：amount 是 uint256，不是字串
  3. 可讀性強：錢包能清楚顯示每個字段
  4. 域隔離：綁定到特定應用和鏈
  5. 標準化：所有實現使用相同的編碼方式



🔍 簽名驗證對比
─────────────────────────────────────────

傳統簽名驗證:
  恢復的地址: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
  匹配原地址: ✅

EIP712 簽名驗證:
  恢復的地址: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
  匹配原地址: ✅



🛡️  重放攻擊防護演示
─────────────────────────────────────────

場景: 攻擊者試圖在不同環境重放簽名

傳統簽名:
  ❌ 缺乏應用標識 → 可以在任何 DApp 重放
  ❌ 缺乏鏈 ID → 可以在不同鏈上重放
  ❌ 缺乏合約綁定 → 可以提交到任何合約

EIP712 簽名:
  ✅ Domain name → 只能在 'MyToken' 應用使用
  ✅ chainId: 1 → 只能在以太坊主網使用
  ✅ verifyingContract → 只能在指定合約驗證
  ✅ 三重防護，徹底防止重放攻擊



👁️  錢包顯示對比
─────────────────────────────────────────

傳統簽名在錢包中的顯示:
┌─────────────────────────────────────┐
│ 簽名請求                             │
├─────────────────────────────────────┤
│ 訊息:                                │
│ Transfer 100 tokens to 0x742d...    │
│                                     │
│ ⚠️  你真的知道這代表什麼嗎？        │
└─────────────────────────────────────┘

EIP712 在錢包中的顯示:
┌─────────────────────────────────────┐
│ 簽名請求 - MyToken                   │
├─────────────────────────────────────┤
│ Domain:                             │
│   name: MyToken                     │
│   version: 1                        │
│   chainId: 1 (Ethereum)             │
│                                     │
│ Transfer:                           │
│   to: 0x742d35Cc... (address)       │
│   amount: 100 (uint256)             │
│   deadline: 1234567890 (uint256)    │
│                                     │
│ ✅ 每個字段都清晰明確                │
└─────────────────────────────────────┘

==========================================
🎓 總結
==========================================

EIP712 通過以下方式提升安全性和用戶體驗:
  1. 結構化數據 - 明確的類型定義
  2. 域隔離 - 防止跨應用/跨鏈重放
  3. 標準化編碼 - 一致的實現方式
  4. 更好的 UX - 錢包能清楚展示簽名內容
  5. 更高的安全性 - 減少盲簽和釣魚風險

下一步: 學習 EIP712 的詳細編碼流程
查看: ../02-encoding-flow/

PS C:\VScode\web3\150-EIP712-course>