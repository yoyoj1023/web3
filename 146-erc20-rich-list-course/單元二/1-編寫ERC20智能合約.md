# å–®å…ƒäºŒï¼šERC20 æ™ºèƒ½åˆç´„çš„éƒ¨ç½²

## ç¬¬ä¸€èª²ï¼šç·¨å¯«ä½ çš„ç¬¬ä¸€å€‹ ERC20 ä»£å¹£

### ğŸ¯ å­¸ç¿’ç›®æ¨™

åœ¨é€™ä¸€èª²ä¸­ï¼Œæˆ‘å€‘å°‡ï¼š
- äº†è§£ ERC20 æ¨™æº–çš„æ ¸å¿ƒæ¦‚å¿µ
- ä½¿ç”¨ OpenZeppelin åº«å¿«é€Ÿå»ºç«‹ä»£å¹£åˆç´„
- å®¢è£½åŒ–ä»£å¹£çš„åç¨±ã€ç¬¦è™Ÿå’Œåˆå§‹ä¾›æ‡‰é‡
- äº†è§£æ™ºèƒ½åˆç´„çš„å®‰å…¨æœ€ä½³å¯¦è¸

### ğŸ“š ERC20 æ¨™æº–ç°¡ä»‹

ERC20 æ˜¯ä»¥å¤ªåŠä¸Šæœ€å»£æ³›ä½¿ç”¨çš„ä»£å¹£æ¨™æº–ï¼Œå®šç¾©äº†å¯äº’æ›ä»£å¹£çš„åŸºæœ¬åŠŸèƒ½ï¼š

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
- `totalSupply()` - ç¸½ä¾›æ‡‰é‡
- `balanceOf(address)` - æŸ¥è©¢é¤˜é¡
- `transfer(address, uint256)` - è½‰å¸³
- `approve(address, uint256)` - æˆæ¬Šé¡åº¦
- `transferFrom(address, address, uint256)` - ä»£ç†è½‰å¸³

**æ ¸å¿ƒäº‹ä»¶ï¼š**
- `Transfer` - è½‰å¸³äº‹ä»¶
- `Approval` - æˆæ¬Šäº‹ä»¶

### ğŸ› ï¸ å¯¦ä½œæ­¥é©Ÿ

#### æ­¥é©Ÿ 1ï¼šåˆªé™¤ç¯„ä¾‹åˆç´„

é¦–å…ˆï¼Œè®“æˆ‘å€‘æ¸…ç†å°ˆæ¡ˆä¸­çš„ç¯„ä¾‹åˆç´„ï¼š

```bash
# é€²å…¥ hardhat ç›®éŒ„
cd packages/hardhat

# åˆªé™¤ç¯„ä¾‹åˆç´„
rm contracts/Counter.sol
rm deploy/00_deploy_counter.ts
rm test/Counter.ts
```

#### æ­¥é©Ÿ 2ï¼šå®‰è£ OpenZeppelin åˆç´„åº«

```bash
# å®‰è£ OpenZeppelin åˆç´„åº«
yarn add @openzeppelin/contracts

# ç¢ºèªå®‰è£æˆåŠŸ
yarn list @openzeppelin/contracts
```

#### æ­¥é©Ÿ 3ï¼šå»ºç«‹ ERC20 ä»£å¹£åˆç´„

å»ºç«‹æ–°æª”æ¡ˆ `contracts/RichListToken.sol`ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title RichListToken
 * @dev ä¸€å€‹ç”¨æ–¼å±•ç¤ºå¯Œè±ªæ¦œåŠŸèƒ½çš„ ERC20 ä»£å¹£
 * 
 * ç‰¹è‰²åŠŸèƒ½ï¼š
 * - æ¨™æº– ERC20 åŠŸèƒ½ï¼ˆè½‰å¸³ã€æˆæ¬Šç­‰ï¼‰
 * - å¯ç‡ƒç‡’ä»£å¹£ (Burnable)
 * - æ“æœ‰è€…æ¬Šé™ç®¡ç† (Ownable)
 * - é‘„é€ åŠŸèƒ½ï¼ˆåƒ…é™æ“æœ‰è€…ï¼‰
 * - æ‰¹é‡è½‰å¸³åŠŸèƒ½ï¼ˆç”¨æ–¼æ¸¬è©¦å¯Œè±ªæ¦œï¼‰
 */
contract RichListToken is ERC20, ERC20Burnable, Ownable {
    
    /// @dev æœ€å¤§ä¾›æ‡‰é‡é™åˆ¶ (1å„„ä»£å¹£)
    uint256 public constant MAX_SUPPLY = 100_000_000 * 10**18;
    
    /// @dev é‘„é€ äº‹ä»¶
    event Mint(address indexed to, uint256 amount);
    
    /// @dev æ‰¹é‡è½‰å¸³äº‹ä»¶
    event BatchTransfer(address indexed from, uint256 recipientCount, uint256 totalAmount);

    /**
     * @dev å»ºæ§‹å­
     * @param _name ä»£å¹£åç¨±
     * @param _symbol ä»£å¹£ç¬¦è™Ÿ
     * @param _initialSupply åˆå§‹ä¾›æ‡‰é‡ï¼ˆä»¥ ether ç‚ºå–®ä½ï¼‰
     * @param _owner åˆç´„æ“æœ‰è€…åœ°å€
     */
    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _initialSupply,
        address _owner
    ) ERC20(_name, _symbol) Ownable(_owner) {
        require(_initialSupply <= MAX_SUPPLY / 10**18, "Initial supply exceeds maximum");
        require(_owner != address(0), "Owner cannot be zero address");
        
        // å°‡åˆå§‹ä¾›æ‡‰é‡é‘„é€ çµ¦æ“æœ‰è€…
        if (_initialSupply > 0) {
            _mint(_owner, _initialSupply * 10**18);
        }
    }

    /**
     * @dev é‘„é€ æ–°ä»£å¹£ï¼ˆåƒ…é™æ“æœ‰è€…ï¼‰
     * @param to æ¥æ”¶è€…åœ°å€
     * @param amount é‘„é€ æ•¸é‡ï¼ˆä»¥ wei ç‚ºå–®ä½ï¼‰
     */
    function mint(address to, uint256 amount) public onlyOwner {
        require(to != address(0), "Cannot mint to zero address");
        require(totalSupply() + amount <= MAX_SUPPLY, "Would exceed maximum supply");
        
        _mint(to, amount);
        emit Mint(to, amount);
    }

    /**
     * @dev æ‰¹é‡é‘„é€ ï¼ˆç”¨æ–¼å¿«é€Ÿå»ºç«‹æ¸¬è©¦æ•¸æ“šï¼‰
     * @param recipients æ¥æ”¶è€…åœ°å€é™£åˆ—
     * @param amounts å°æ‡‰çš„é‘„é€ æ•¸é‡é™£åˆ—
     */
    function batchMint(address[] memory recipients, uint256[] memory amounts) public onlyOwner {
        require(recipients.length == amounts.length, "Arrays length mismatch");
        require(recipients.length <= 100, "Too many recipients");
        
        uint256 totalAmount = 0;
        for (uint256 i = 0; i < amounts.length; i++) {
            totalAmount += amounts[i];
        }
        
        require(totalSupply() + totalAmount <= MAX_SUPPLY, "Would exceed maximum supply");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            require(recipients[i] != address(0), "Cannot mint to zero address");
            _mint(recipients[i], amounts[i]);
            emit Mint(recipients[i], amounts[i]);
        }
    }

    /**
     * @dev æ‰¹é‡è½‰å¸³ï¼ˆç”¨æ–¼åˆ†ç™¼ä»£å¹£ï¼‰
     * @param recipients æ¥æ”¶è€…åœ°å€é™£åˆ—
     * @param amounts å°æ‡‰çš„è½‰å¸³æ•¸é‡é™£åˆ—
     */
    function batchTransfer(address[] memory recipients, uint256[] memory amounts) public {
        require(recipients.length == amounts.length, "Arrays length mismatch");
        require(recipients.length <= 50, "Too many recipients");
        
        uint256 totalAmount = 0;
        for (uint256 i = 0; i < amounts.length; i++) {
            totalAmount += amounts[i];
        }
        
        require(balanceOf(msg.sender) >= totalAmount, "Insufficient balance");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            require(recipients[i] != address(0), "Cannot transfer to zero address");
            _transfer(msg.sender, recipients[i], amounts[i]);
        }
        
        emit BatchTransfer(msg.sender, recipients.length, totalAmount);
    }

    /**
     * @dev ç²å–ä»£å¹£åŸºæœ¬è³‡è¨Š
     * @return name_ ä»£å¹£åç¨±
     * @return symbol_ ä»£å¹£ç¬¦è™Ÿ
     * @return decimals_ å°æ•¸é»ä½æ•¸
     * @return totalSupply_ ç¸½ä¾›æ‡‰é‡
     * @return maxSupply_ æœ€å¤§ä¾›æ‡‰é‡
     */
    function getTokenInfo() public view returns (
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 totalSupply_,
        uint256 maxSupply_
    ) {
        return (
            name(),
            symbol(),
            decimals(),
            totalSupply(),
            MAX_SUPPLY
        );
    }

    /**
     * @dev æª¢æŸ¥æ˜¯å¦å¯ä»¥é‘„é€ æŒ‡å®šæ•¸é‡çš„ä»£å¹£
     * @param amount è¦é‘„é€ çš„æ•¸é‡
     * @return æ˜¯å¦å¯ä»¥é‘„é€ 
     */
    function canMint(uint256 amount) public view returns (bool) {
        return totalSupply() + amount <= MAX_SUPPLY;
    }

    /**
     * @dev ç²å–å‰©é¤˜å¯é‘„é€ æ•¸é‡
     * @return å‰©é¤˜å¯é‘„é€ çš„ä»£å¹£æ•¸é‡
     */
    function remainingMintable() public view returns (uint256) {
        return MAX_SUPPLY - totalSupply();
    }
}
```

### ğŸ” åˆç´„åŠŸèƒ½è©³è§£

#### åŸºç¤åŠŸèƒ½

**1. æ¨™æº– ERC20 åŠŸèƒ½**
```solidity
// ç¹¼æ‰¿è‡ª OpenZeppelin çš„ ERC20 åˆç´„
contract RichListToken is ERC20, ERC20Burnable, Ownable
```

**2. ä¾›æ‡‰é‡ç®¡ç†**
```solidity
uint256 public constant MAX_SUPPLY = 100_000_000 * 10**18;  // 1å„„ä»£å¹£ä¸Šé™

function mint(address to, uint256 amount) public onlyOwner {
    require(totalSupply() + amount <= MAX_SUPPLY, "Would exceed maximum supply");
    _mint(to, amount);
}
```

#### é€²éšåŠŸèƒ½

**1. æ‰¹é‡æ“ä½œ**
```solidity
// æ‰¹é‡é‘„é€  - å¿«é€Ÿå»ºç«‹æ¸¬è©¦æ•¸æ“š
function batchMint(address[] memory recipients, uint256[] memory amounts) public onlyOwner

// æ‰¹é‡è½‰å¸³ - ä¸€æ¬¡æ€§åˆ†ç™¼çµ¦å¤šå€‹åœ°å€
function batchTransfer(address[] memory recipients, uint256[] memory amounts) public
```

**2. æŸ¥è©¢åŠŸèƒ½**
```solidity
// ç²å–å®Œæ•´ä»£å¹£è³‡è¨Š
function getTokenInfo() public view returns (...)

// æª¢æŸ¥æ˜¯å¦å¯ä»¥é‘„é€ 
function canMint(uint256 amount) public view returns (bool)

// æŸ¥çœ‹å‰©é¤˜å¯é‘„é€ æ•¸é‡
function remainingMintable() public view returns (uint256)
```

### ğŸ”’ å®‰å…¨ç‰¹æ€§

#### 1. å­˜å–æ§åˆ¶
```solidity
import "@openzeppelin/contracts/access/Ownable.sol";

// åªæœ‰æ“æœ‰è€…å¯ä»¥é‘„é€ ä»£å¹£
modifier onlyOwner()
```

#### 2. è¼¸å…¥é©—è­‰
```solidity
require(to != address(0), "Cannot mint to zero address");
require(totalSupply() + amount <= MAX_SUPPLY, "Would exceed maximum supply");
require(recipients.length <= 100, "Too many recipients");
```

#### 3. æ•´æ•¸æº¢å‡ºä¿è­·
```solidity
// ä½¿ç”¨ Solidity 0.8+ å…§å»ºçš„æº¢å‡ºæª¢æŸ¥
uint256 totalAmount = 0;
for (uint256 i = 0; i < amounts.length; i++) {
    totalAmount += amounts[i];  // è‡ªå‹•æª¢æŸ¥æº¢å‡º
}
```

### ğŸ§ª æ¸¬è©¦åˆç´„

å»ºç«‹æ¸¬è©¦æª”æ¡ˆ `test/RichListToken.ts`ï¼š

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { RichListToken } from "../typechain-types";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";

describe("RichListToken", function () {
  let token: RichListToken;
  let owner: HardhatEthersSigner;
  let addr1: HardhatEthersSigner;
  let addr2: HardhatEthersSigner;
  let addrs: HardhatEthersSigner[];

  const TOKEN_NAME = "RichList Token";
  const TOKEN_SYMBOL = "RLT";
  const INITIAL_SUPPLY = 1000000; // 1 million tokens
  const MAX_SUPPLY = ethers.parseEther("100000000"); // 100 million tokens

  beforeEach(async function () {
    [owner, addr1, addr2, ...addrs] = await ethers.getSigners();

    const RichListTokenFactory = await ethers.getContractFactory("RichListToken");
    token = await RichListTokenFactory.deploy(
      TOKEN_NAME,
      TOKEN_SYMBOL,
      INITIAL_SUPPLY,
      owner.address
    );
  });

  describe("Deployment", function () {
    it("Should set the right name and symbol", async function () {
      expect(await token.name()).to.equal(TOKEN_NAME);
      expect(await token.symbol()).to.equal(TOKEN_SYMBOL);
    });

    it("Should set the right decimals", async function () {
      expect(await token.decimals()).to.equal(18);
    });

    it("Should mint initial supply to owner", async function () {
      const ownerBalance = await token.balanceOf(owner.address);
      expect(ownerBalance).to.equal(ethers.parseEther(INITIAL_SUPPLY.toString()));
    });

    it("Should set the right owner", async function () {
      expect(await token.owner()).to.equal(owner.address);
    });

    it("Should set the right max supply", async function () {
      expect(await token.MAX_SUPPLY()).to.equal(MAX_SUPPLY);
    });
  });

  describe("Minting", function () {
    it("Should allow owner to mint tokens", async function () {
      const mintAmount = ethers.parseEther("1000");
      await token.mint(addr1.address, mintAmount);
      
      const balance = await token.balanceOf(addr1.address);
      expect(balance).to.equal(mintAmount);
    });

    it("Should not allow non-owner to mint tokens", async function () {
      const mintAmount = ethers.parseEther("1000");
      await expect(
        token.connect(addr1).mint(addr2.address, mintAmount)
      ).to.be.revertedWithCustomError(token, "OwnableUnauthorizedAccount");
    });

    it("Should not allow minting beyond max supply", async function () {
      const excessiveAmount = MAX_SUPPLY;
      await expect(
        token.mint(addr1.address, excessiveAmount)
      ).to.be.revertedWith("Would exceed maximum supply");
    });
  });

  describe("Batch Operations", function () {
    it("Should allow batch minting", async function () {
      const recipients = [addr1.address, addr2.address];
      const amounts = [ethers.parseEther("1000"), ethers.parseEther("2000")];

      await token.batchMint(recipients, amounts);

      expect(await token.balanceOf(addr1.address)).to.equal(amounts[0]);
      expect(await token.balanceOf(addr2.address)).to.equal(amounts[1]);
    });

    it("Should allow batch transfer", async function () {
      // First mint some tokens to owner
      const initialAmount = ethers.parseEther("10000");
      
      const recipients = [addr1.address, addr2.address];
      const amounts = [ethers.parseEther("1000"), ethers.parseEther("2000")];

      await token.batchTransfer(recipients, amounts);

      expect(await token.balanceOf(addr1.address)).to.equal(amounts[0]);
      expect(await token.balanceOf(addr2.address)).to.equal(amounts[1]);
    });
  });

  describe("Token Info", function () {
    it("Should return correct token info", async function () {
      const [name, symbol, decimals, totalSupply, maxSupply] = await token.getTokenInfo();
      
      expect(name).to.equal(TOKEN_NAME);
      expect(symbol).to.equal(TOKEN_SYMBOL);
      expect(decimals).to.equal(18);
      expect(totalSupply).to.equal(ethers.parseEther(INITIAL_SUPPLY.toString()));
      expect(maxSupply).to.equal(MAX_SUPPLY);
    });

    it("Should return correct remaining mintable amount", async function () {
      const remaining = await token.remainingMintable();
      const expected = MAX_SUPPLY - ethers.parseEther(INITIAL_SUPPLY.toString());
      expect(remaining).to.equal(expected);
    });
  });
});
```

### ğŸš€ åŸ·è¡Œæ¸¬è©¦

```bash
# ç·¨è­¯åˆç´„
yarn compile

# åŸ·è¡Œæ¸¬è©¦
yarn test

# åŸ·è¡Œç‰¹å®šæ¸¬è©¦æª”æ¡ˆ
yarn test test/RichListToken.ts

# æª¢æŸ¥æ¸¬è©¦è¦†è“‹ç‡
yarn test --coverage
```

### ğŸ“Š é æœŸæ¸¬è©¦çµæœ

```
RichListToken
  Deployment
    âœ“ Should set the right name and symbol
    âœ“ Should set the right decimals
    âœ“ Should mint initial supply to owner
    âœ“ Should set the right owner
    âœ“ Should set the right max supply
  Minting
    âœ“ Should allow owner to mint tokens
    âœ“ Should not allow non-owner to mint tokens
    âœ“ Should not allow minting beyond max supply
  Batch Operations
    âœ“ Should allow batch minting
    âœ“ Should allow batch transfer
  Token Info
    âœ“ Should return correct token info
    âœ“ Should return correct remaining mintable amount

11 passing (2s)
```

### ğŸ¨ è‡ªå®šç¾©ä½ çš„ä»£å¹£

ä½ å¯ä»¥è¼•é¬†å®¢è£½åŒ–ä»£å¹£çš„å±¬æ€§ï¼š

```solidity
// åœ¨éƒ¨ç½²è…³æœ¬ä¸­ä¿®æ”¹é€™äº›åƒæ•¸
const TOKEN_NAME = "My Awesome Token";      // ä½ çš„ä»£å¹£åç¨±
const TOKEN_SYMBOL = "MAT";                 // ä½ çš„ä»£å¹£ç¬¦è™Ÿ
const INITIAL_SUPPLY = 5000000;             // åˆå§‹ä¾›æ‡‰é‡ (5ç™¾è¬)
const OWNER_ADDRESS = "0x...";              // æ“æœ‰è€…åœ°å€
```

### ğŸ’¡ é€²éšå®¢è£½åŒ–é¸é …

**1. æ·»åŠ ä»£å¹£åœ–æ¨™å’Œæè¿°**
```solidity
string public constant DESCRIPTION = "A token for demonstrating rich list functionality";
string public constant IMAGE_URL = "https://your-domain.com/token-icon.png";
```

**2. å¯¦ä½œä»£å¹£ç¶“æ¿Ÿæ¨¡å‹**
```solidity
// æ·»åŠ äº¤æ˜“æ‰‹çºŒè²»
uint256 public transferFeePercent = 1; // 1%

function _transfer(address from, address to, uint256 amount) internal override {
    uint256 fee = (amount * transferFeePercent) / 100;
    uint256 transferAmount = amount - fee;
    
    super._transfer(from, to, transferAmount);
    if (fee > 0) {
        super._transfer(from, owner(), fee);
    }
}
```

### âœ… å°çµ

åœ¨é€™ä¸€èª²ä¸­ï¼Œæˆ‘å€‘æˆåŠŸï¼š

âœ… **å»ºç«‹äº†åŠŸèƒ½å®Œæ•´çš„ ERC20 ä»£å¹£**
- æ¨™æº– ERC20 åŠŸèƒ½
- å¯ç‡ƒç‡’å’Œå¯é‘„é€ 
- æ‰¹é‡æ“ä½œæ”¯æŒ

âœ… **å¯¦ä½œäº†å®‰å…¨æ©Ÿåˆ¶**
- å­˜å–æ§åˆ¶
- ä¾›æ‡‰é‡é™åˆ¶
- è¼¸å…¥é©—è­‰

âœ… **ç·¨å¯«äº†å®Œæ•´çš„æ¸¬è©¦**
- å–®å…ƒæ¸¬è©¦è¦†è“‹ä¸»è¦åŠŸèƒ½
- é‚Šç•Œæ¢ä»¶æ¸¬è©¦
- éŒ¯èª¤æƒ…æ³è™•ç†

âœ… **æä¾›äº†å®¢è£½åŒ–é¸é …**
- éˆæ´»çš„åƒæ•¸è¨­å®š
- å¯æ“´å±•çš„åŠŸèƒ½æ¶æ§‹

åœ¨ä¸‹ä¸€èª²ä¸­ï¼Œæˆ‘å€‘å°‡å­¸ç¿’å¦‚ä½•è¨­å®š Hardhat éƒ¨ç½²è…³æœ¬ï¼Œå°‡é€™å€‹åˆç´„éƒ¨ç½²åˆ° Optimism Sepolia æ¸¬è©¦ç¶²ï¼

---

**æº–å‚™å¥½å°‡ä½ çš„ä»£å¹£ç™¼ä½ˆåˆ°å€å¡Šéˆä¸Šäº†å—ï¼Ÿ** ğŸš€
