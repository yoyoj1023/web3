# 單元二：ERC20 智能合約的部署

## 第一課：編寫你的第一個 ERC20 代幣

### 🎯 學習目標

在這一課中，我們將：
- 了解 ERC20 標準的核心概念
- 使用 OpenZeppelin 庫快速建立代幣合約
- 客製化代幣的名稱、符號和初始供應量
- 了解智能合約的安全最佳實踐

### 📚 ERC20 標準簡介

ERC20 是以太坊上最廣泛使用的代幣標準，定義了可互換代幣的基本功能：

**核心功能：**
- `totalSupply()` - 總供應量
- `balanceOf(address)` - 查詢餘額
- `transfer(address, uint256)` - 轉帳
- `approve(address, uint256)` - 授權額度
- `transferFrom(address, address, uint256)` - 代理轉帳

**核心事件：**
- `Transfer` - 轉帳事件
- `Approval` - 授權事件

### 🛠️ 實作步驟

#### 步驟 1：刪除範例合約

首先，讓我們清理專案中的範例合約：

```bash
# 進入 hardhat 目錄
cd packages/hardhat

# 刪除範例合約
rm contracts/Counter.sol
rm deploy/00_deploy_counter.ts
rm test/Counter.ts
```

#### 步驟 2：安裝 OpenZeppelin 合約庫

```bash
# 安裝 OpenZeppelin 合約庫
yarn add @openzeppelin/contracts

# 確認安裝成功
yarn list @openzeppelin/contracts
```

#### 步驟 3：建立 ERC20 代幣合約

建立新檔案 `contracts/RichListToken.sol`：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title RichListToken
 * @dev 一個用於展示富豪榜功能的 ERC20 代幣
 * 
 * 特色功能：
 * - 標準 ERC20 功能（轉帳、授權等）
 * - 可燃燒代幣 (Burnable)
 * - 擁有者權限管理 (Ownable)
 * - 鑄造功能（僅限擁有者）
 * - 批量轉帳功能（用於測試富豪榜）
 */
contract RichListToken is ERC20, ERC20Burnable, Ownable {
    
    /// @dev 最大供應量限制 (1億代幣)
    uint256 public constant MAX_SUPPLY = 100_000_000 * 10**18;
    
    /// @dev 鑄造事件
    event Mint(address indexed to, uint256 amount);
    
    /// @dev 批量轉帳事件
    event BatchTransfer(address indexed from, uint256 recipientCount, uint256 totalAmount);

    /**
     * @dev 建構子
     * @param _name 代幣名稱
     * @param _symbol 代幣符號
     * @param _initialSupply 初始供應量（以 ether 為單位）
     * @param _owner 合約擁有者地址
     */
    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _initialSupply,
        address _owner
    ) ERC20(_name, _symbol) Ownable(_owner) {
        require(_initialSupply <= MAX_SUPPLY / 10**18, "Initial supply exceeds maximum");
        require(_owner != address(0), "Owner cannot be zero address");
        
        // 將初始供應量鑄造給擁有者
        if (_initialSupply > 0) {
            _mint(_owner, _initialSupply * 10**18);
        }
    }

    /**
     * @dev 鑄造新代幣（僅限擁有者）
     * @param to 接收者地址
     * @param amount 鑄造數量（以 wei 為單位）
     */
    function mint(address to, uint256 amount) public onlyOwner {
        require(to != address(0), "Cannot mint to zero address");
        require(totalSupply() + amount <= MAX_SUPPLY, "Would exceed maximum supply");
        
        _mint(to, amount);
        emit Mint(to, amount);
    }

    /**
     * @dev 批量鑄造（用於快速建立測試數據）
     * @param recipients 接收者地址陣列
     * @param amounts 對應的鑄造數量陣列
     */
    function batchMint(address[] memory recipients, uint256[] memory amounts) public onlyOwner {
        require(recipients.length == amounts.length, "Arrays length mismatch");
        require(recipients.length <= 100, "Too many recipients");
        
        uint256 totalAmount = 0;
        for (uint256 i = 0; i < amounts.length; i++) {
            totalAmount += amounts[i];
        }
        
        require(totalSupply() + totalAmount <= MAX_SUPPLY, "Would exceed maximum supply");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            require(recipients[i] != address(0), "Cannot mint to zero address");
            _mint(recipients[i], amounts[i]);
            emit Mint(recipients[i], amounts[i]);
        }
    }

    /**
     * @dev 批量轉帳（用於分發代幣）
     * @param recipients 接收者地址陣列
     * @param amounts 對應的轉帳數量陣列
     */
    function batchTransfer(address[] memory recipients, uint256[] memory amounts) public {
        require(recipients.length == amounts.length, "Arrays length mismatch");
        require(recipients.length <= 50, "Too many recipients");
        
        uint256 totalAmount = 0;
        for (uint256 i = 0; i < amounts.length; i++) {
            totalAmount += amounts[i];
        }
        
        require(balanceOf(msg.sender) >= totalAmount, "Insufficient balance");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            require(recipients[i] != address(0), "Cannot transfer to zero address");
            _transfer(msg.sender, recipients[i], amounts[i]);
        }
        
        emit BatchTransfer(msg.sender, recipients.length, totalAmount);
    }

    /**
     * @dev 獲取代幣基本資訊
     * @return name_ 代幣名稱
     * @return symbol_ 代幣符號
     * @return decimals_ 小數點位數
     * @return totalSupply_ 總供應量
     * @return maxSupply_ 最大供應量
     */
    function getTokenInfo() public view returns (
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 totalSupply_,
        uint256 maxSupply_
    ) {
        return (
            name(),
            symbol(),
            decimals(),
            totalSupply(),
            MAX_SUPPLY
        );
    }

    /**
     * @dev 檢查是否可以鑄造指定數量的代幣
     * @param amount 要鑄造的數量
     * @return 是否可以鑄造
     */
    function canMint(uint256 amount) public view returns (bool) {
        return totalSupply() + amount <= MAX_SUPPLY;
    }

    /**
     * @dev 獲取剩餘可鑄造數量
     * @return 剩餘可鑄造的代幣數量
     */
    function remainingMintable() public view returns (uint256) {
        return MAX_SUPPLY - totalSupply();
    }
}
```

### 🔍 合約功能詳解

#### 基礎功能

**1. 標準 ERC20 功能**
```solidity
// 繼承自 OpenZeppelin 的 ERC20 合約
contract RichListToken is ERC20, ERC20Burnable, Ownable
```

**2. 供應量管理**
```solidity
uint256 public constant MAX_SUPPLY = 100_000_000 * 10**18;  // 1億代幣上限

function mint(address to, uint256 amount) public onlyOwner {
    require(totalSupply() + amount <= MAX_SUPPLY, "Would exceed maximum supply");
    _mint(to, amount);
}
```

#### 進階功能

**1. 批量操作**
```solidity
// 批量鑄造 - 快速建立測試數據
function batchMint(address[] memory recipients, uint256[] memory amounts) public onlyOwner

// 批量轉帳 - 一次性分發給多個地址
function batchTransfer(address[] memory recipients, uint256[] memory amounts) public
```

**2. 查詢功能**
```solidity
// 獲取完整代幣資訊
function getTokenInfo() public view returns (...)

// 檢查是否可以鑄造
function canMint(uint256 amount) public view returns (bool)

// 查看剩餘可鑄造數量
function remainingMintable() public view returns (uint256)
```

### 🔒 安全特性

#### 1. 存取控制
```solidity
import "@openzeppelin/contracts/access/Ownable.sol";

// 只有擁有者可以鑄造代幣
modifier onlyOwner()
```

#### 2. 輸入驗證
```solidity
require(to != address(0), "Cannot mint to zero address");
require(totalSupply() + amount <= MAX_SUPPLY, "Would exceed maximum supply");
require(recipients.length <= 100, "Too many recipients");
```

#### 3. 整數溢出保護
```solidity
// 使用 Solidity 0.8+ 內建的溢出檢查
uint256 totalAmount = 0;
for (uint256 i = 0; i < amounts.length; i++) {
    totalAmount += amounts[i];  // 自動檢查溢出
}
```

### 🧪 測試合約

建立測試檔案 `test/RichListToken.ts`：

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { RichListToken } from "../typechain-types";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";

describe("RichListToken", function () {
  let token: RichListToken;
  let owner: HardhatEthersSigner;
  let addr1: HardhatEthersSigner;
  let addr2: HardhatEthersSigner;
  let addrs: HardhatEthersSigner[];

  const TOKEN_NAME = "RichList Token";
  const TOKEN_SYMBOL = "RLT";
  const INITIAL_SUPPLY = 1000000; // 1 million tokens
  const MAX_SUPPLY = ethers.parseEther("100000000"); // 100 million tokens

  beforeEach(async function () {
    [owner, addr1, addr2, ...addrs] = await ethers.getSigners();

    const RichListTokenFactory = await ethers.getContractFactory("RichListToken");
    token = await RichListTokenFactory.deploy(
      TOKEN_NAME,
      TOKEN_SYMBOL,
      INITIAL_SUPPLY,
      owner.address
    );
  });

  describe("Deployment", function () {
    it("Should set the right name and symbol", async function () {
      expect(await token.name()).to.equal(TOKEN_NAME);
      expect(await token.symbol()).to.equal(TOKEN_SYMBOL);
    });

    it("Should set the right decimals", async function () {
      expect(await token.decimals()).to.equal(18);
    });

    it("Should mint initial supply to owner", async function () {
      const ownerBalance = await token.balanceOf(owner.address);
      expect(ownerBalance).to.equal(ethers.parseEther(INITIAL_SUPPLY.toString()));
    });

    it("Should set the right owner", async function () {
      expect(await token.owner()).to.equal(owner.address);
    });

    it("Should set the right max supply", async function () {
      expect(await token.MAX_SUPPLY()).to.equal(MAX_SUPPLY);
    });
  });

  describe("Minting", function () {
    it("Should allow owner to mint tokens", async function () {
      const mintAmount = ethers.parseEther("1000");
      await token.mint(addr1.address, mintAmount);
      
      const balance = await token.balanceOf(addr1.address);
      expect(balance).to.equal(mintAmount);
    });

    it("Should not allow non-owner to mint tokens", async function () {
      const mintAmount = ethers.parseEther("1000");
      await expect(
        token.connect(addr1).mint(addr2.address, mintAmount)
      ).to.be.revertedWithCustomError(token, "OwnableUnauthorizedAccount");
    });

    it("Should not allow minting beyond max supply", async function () {
      const excessiveAmount = MAX_SUPPLY;
      await expect(
        token.mint(addr1.address, excessiveAmount)
      ).to.be.revertedWith("Would exceed maximum supply");
    });
  });

  describe("Batch Operations", function () {
    it("Should allow batch minting", async function () {
      const recipients = [addr1.address, addr2.address];
      const amounts = [ethers.parseEther("1000"), ethers.parseEther("2000")];

      await token.batchMint(recipients, amounts);

      expect(await token.balanceOf(addr1.address)).to.equal(amounts[0]);
      expect(await token.balanceOf(addr2.address)).to.equal(amounts[1]);
    });

    it("Should allow batch transfer", async function () {
      // First mint some tokens to owner
      const initialAmount = ethers.parseEther("10000");
      
      const recipients = [addr1.address, addr2.address];
      const amounts = [ethers.parseEther("1000"), ethers.parseEther("2000")];

      await token.batchTransfer(recipients, amounts);

      expect(await token.balanceOf(addr1.address)).to.equal(amounts[0]);
      expect(await token.balanceOf(addr2.address)).to.equal(amounts[1]);
    });
  });

  describe("Token Info", function () {
    it("Should return correct token info", async function () {
      const [name, symbol, decimals, totalSupply, maxSupply] = await token.getTokenInfo();
      
      expect(name).to.equal(TOKEN_NAME);
      expect(symbol).to.equal(TOKEN_SYMBOL);
      expect(decimals).to.equal(18);
      expect(totalSupply).to.equal(ethers.parseEther(INITIAL_SUPPLY.toString()));
      expect(maxSupply).to.equal(MAX_SUPPLY);
    });

    it("Should return correct remaining mintable amount", async function () {
      const remaining = await token.remainingMintable();
      const expected = MAX_SUPPLY - ethers.parseEther(INITIAL_SUPPLY.toString());
      expect(remaining).to.equal(expected);
    });
  });
});
```

### 🚀 執行測試

```bash
# 編譯合約
yarn compile

# 執行測試
yarn test

# 執行特定測試檔案
yarn test test/RichListToken.ts

# 檢查測試覆蓋率
yarn test --coverage
```

### 📊 預期測試結果

```
RichListToken
  Deployment
    ✓ Should set the right name and symbol
    ✓ Should set the right decimals
    ✓ Should mint initial supply to owner
    ✓ Should set the right owner
    ✓ Should set the right max supply
  Minting
    ✓ Should allow owner to mint tokens
    ✓ Should not allow non-owner to mint tokens
    ✓ Should not allow minting beyond max supply
  Batch Operations
    ✓ Should allow batch minting
    ✓ Should allow batch transfer
  Token Info
    ✓ Should return correct token info
    ✓ Should return correct remaining mintable amount

11 passing (2s)
```

### 🎨 自定義你的代幣

你可以輕鬆客製化代幣的屬性：

```solidity
// 在部署腳本中修改這些參數
const TOKEN_NAME = "My Awesome Token";      // 你的代幣名稱
const TOKEN_SYMBOL = "MAT";                 // 你的代幣符號
const INITIAL_SUPPLY = 5000000;             // 初始供應量 (5百萬)
const OWNER_ADDRESS = "0x...";              // 擁有者地址
```

### 💡 進階客製化選項

**1. 添加代幣圖標和描述**
```solidity
string public constant DESCRIPTION = "A token for demonstrating rich list functionality";
string public constant IMAGE_URL = "https://your-domain.com/token-icon.png";
```

**2. 實作代幣經濟模型**
```solidity
// 添加交易手續費
uint256 public transferFeePercent = 1; // 1%

function _transfer(address from, address to, uint256 amount) internal override {
    uint256 fee = (amount * transferFeePercent) / 100;
    uint256 transferAmount = amount - fee;
    
    super._transfer(from, to, transferAmount);
    if (fee > 0) {
        super._transfer(from, owner(), fee);
    }
}
```

### ✅ 小結

在這一課中，我們成功：

✅ **建立了功能完整的 ERC20 代幣**
- 標準 ERC20 功能
- 可燃燒和可鑄造
- 批量操作支持

✅ **實作了安全機制**
- 存取控制
- 供應量限制
- 輸入驗證

✅ **編寫了完整的測試**
- 單元測試覆蓋主要功能
- 邊界條件測試
- 錯誤情況處理

✅ **提供了客製化選項**
- 靈活的參數設定
- 可擴展的功能架構

在下一課中，我們將學習如何設定 Hardhat 部署腳本，將這個合約部署到 Optimism Sepolia 測試網！

---

**準備好將你的代幣發佈到區塊鏈上了嗎？** 🚀
