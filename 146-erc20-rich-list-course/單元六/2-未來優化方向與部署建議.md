# ç¬¬äºŒèª²ï¼šæœªä¾†å„ªåŒ–æ–¹å‘èˆ‡éƒ¨ç½²å»ºè­°

### ğŸ¯ å­¸ç¿’ç›®æ¨™

åœ¨é€™ä¸€èª²ä¸­ï¼Œæˆ‘å€‘å°‡ï¼š
- æ¢è¨å°ˆæ¡ˆçš„æœªä¾†å„ªåŒ–æ–¹å‘
- å­¸ç¿’ç”Ÿç”¢ç’°å¢ƒéƒ¨ç½²ç­–ç•¥
- äº†è§£æ“´å±•æ€§å’Œç¶­è­·æ€§è€ƒé‡
- è¦åŠƒå•†æ¥­åŒ–å’Œç›ˆåˆ©æ¨¡å¼
- å»ºç«‹æŒçºŒæ”¹é€²çš„æ¡†æ¶

### ğŸš€ æŠ€è¡“å„ªåŒ–æ–¹å‘

#### 1. æ•ˆèƒ½å„ªåŒ–ç­–ç•¥

##### ä¼ºæœå™¨ç«¯æ¸²æŸ“ (SSR) å„ªåŒ–

**ç•¶å‰ç‹€æ³ï¼š** å®¢æˆ¶ç«¯æ¸²æŸ“ (CSR)
**å„ªåŒ–ç›®æ¨™ï¼š** æ··åˆæ¸²æŸ“ç­–ç•¥

```typescript
// next.config.js å„ªåŒ–é…ç½®
const nextConfig = {
  // éœæ…‹ç”Ÿæˆå„ªåŒ–
  experimental: {
    appDir: true,
    serverComponentsExternalPackages: ['viem'],
  },
  
  // åœ–ç‰‡å„ªåŒ–
  images: {
    domains: ['alchemy.com', 'etherscan.io'],
    formats: ['image/webp', 'image/avif'],
  },
  
  // å£“ç¸®å’Œå¿«å–
  compress: true,
  poweredByHeader: false,
  
  // é‡å®šå‘å„ªåŒ–
  async redirects() {
    return [
      {
        source: '/rich-list/:path*',
        destination: '/token/:path*',
        permanent: true,
      },
    ];
  },
};
```

**å¯¦ä½œå»ºè­°ï¼š**
```typescript
// app/token/[address]/page.tsx - éœæ…‹ç”Ÿæˆç‰ˆæœ¬
export async function generateStaticParams() {
  // é ç”Ÿæˆç†±é–€ä»£å¹£é é¢
  const popularTokens = [
    '0x1234567890123456789012345678901234567890',
    // ... æ›´å¤šç†±é–€ä»£å¹£
  ];
  
  return popularTokens.map(address => ({ address }));
}

export default async function TokenPage({ params }: { params: { address: string } }) {
  // ä¼ºæœå™¨ç«¯æ•¸æ“šé å–
  const tokenData = await getTokenMetadata(params.address);
  
  return (
    <TokenPageClient 
      initialTokenData={tokenData}
      tokenAddress={params.address}
    />
  );
}
```

##### æ•¸æ“šå¿«å–ç­–ç•¥å‡ç´š

**ç•¶å‰ç‹€æ³ï¼š** å®¢æˆ¶ç«¯è¨˜æ†¶é«”å¿«å–
**å„ªåŒ–ç›®æ¨™ï¼š** å¤šå±¤æ¬¡å¿«å–ç³»çµ±

```typescript
// utils/cacheManager.ts - é€²éšå¿«å–ç®¡ç†
export class AdvancedCacheManager {
  private memoryCache = new Map();
  private localStorageCache = new LocalStorageCache();
  private redisCache = new RedisCache(); // ç”Ÿç”¢ç’°å¢ƒ

  async get(key: string): Promise<any> {
    // 1. è¨˜æ†¶é«”å¿«å– (æœ€å¿«)
    if (this.memoryCache.has(key)) {
      return this.memoryCache.get(key);
    }
    
    // 2. æœ¬åœ°å„²å­˜å¿«å–
    const localData = await this.localStorageCache.get(key);
    if (localData) {
      this.memoryCache.set(key, localData);
      return localData;
    }
    
    // 3. Redis å¿«å– (ç”Ÿç”¢ç’°å¢ƒ)
    if (process.env.NODE_ENV === 'production') {
      const redisData = await this.redisCache.get(key);
      if (redisData) {
        this.localStorageCache.set(key, redisData);
        this.memoryCache.set(key, redisData);
        return redisData;
      }
    }
    
    return null;
  }

  async set(key: string, data: any, ttl?: number): Promise<void> {
    // åŒæ™‚æ›´æ–°æ‰€æœ‰å¿«å–å±¤
    this.memoryCache.set(key, data);
    await this.localStorageCache.set(key, data, ttl);
    
    if (process.env.NODE_ENV === 'production') {
      await this.redisCache.set(key, data, ttl);
    }
  }
}
```

##### è™›æ“¬æ»¾å‹•å¯¦ä½œ

**ç•¶å‰ç‹€æ³ï¼š** å‚³çµ±åˆ†é 
**å„ªåŒ–ç›®æ¨™ï¼š** ç„¡é™æ»¾å‹• + è™›æ“¬åŒ–

```typescript
// components/VirtualizedRichList.tsx
import { FixedSizeList as List } from 'react-window';
import { useMemo, useState, useCallback } from 'react';

interface VirtualizedRichListProps {
  holders: TokenHolder[];
  itemHeight: number;
  containerHeight: number;
  onLoadMore?: () => void;
}

export function VirtualizedRichList({
  holders,
  itemHeight = 80,
  containerHeight = 600,
  onLoadMore,
}: VirtualizedRichListProps) {
  const [loadingMore, setLoadingMore] = useState(false);

  const handleScroll = useCallback(async ({ scrollOffset, scrollUpdateWasRequested }: any) => {
    const threshold = holders.length * itemHeight * 0.8; // 80% ä½ç½®é–‹å§‹é è¼‰
    
    if (scrollOffset > threshold && !loadingMore && onLoadMore) {
      setLoadingMore(true);
      await onLoadMore();
      setLoadingMore(false);
    }
  }, [holders.length, itemHeight, loadingMore, onLoadMore]);

  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {
    const holder = holders[index];
    if (!holder) return null;

    return (
      <div style={style} className="flex items-center p-4 border-b">
        <RichListItem holder={holder} rank={index + 1} />
      </div>
    );
  };

  return (
    <List
      height={containerHeight}
      itemCount={holders.length}
      itemSize={itemHeight}
      onScroll={handleScroll}
      overscanCount={5} // é æ¸²æŸ“é …ç›®æ•¸
    >
      {Row}
    </List>
  );
}
```

#### 2. æ•¸æ“šè™•ç†å„ªåŒ–

##### Web Workers èƒŒæ™¯è™•ç†

```typescript
// workers/dataProcessor.worker.ts
import { TokenDataProcessor } from '../utils/tokenDataProcessor';

self.onmessage = function(e) {
  const { type, data } = e.data;
  
  switch (type) {
    case 'PROCESS_HOLDERS':
      const processedHolders = TokenDataProcessor.processTokenHolders(
        data.rawOwners,
        data.tokenData
      );
      self.postMessage({
        type: 'PROCESS_HOLDERS_COMPLETE',
        data: processedHolders
      });
      break;
      
    case 'CALCULATE_STATS':
      const stats = TokenDataProcessor.calculateStats(data.holders);
      self.postMessage({
        type: 'CALCULATE_STATS_COMPLETE',
        data: stats
      });
      break;
  }
};
```

```typescript
// hooks/useWorkerDataProcessor.ts
import { useCallback, useRef, useEffect } from 'react';

export function useWorkerDataProcessor() {
  const workerRef = useRef<Worker>();

  useEffect(() => {
    workerRef.current = new Worker('/workers/dataProcessor.worker.js');
    
    return () => {
      workerRef.current?.terminate();
    };
  }, []);

  const processHoldersAsync = useCallback((rawOwners: any[], tokenData: any): Promise<TokenHolder[]> => {
    return new Promise((resolve) => {
      if (!workerRef.current) return;
      
      const handleMessage = (e: MessageEvent) => {
        if (e.data.type === 'PROCESS_HOLDERS_COMPLETE') {
          resolve(e.data.data);
          workerRef.current?.removeEventListener('message', handleMessage);
        }
      };
      
      workerRef.current.addEventListener('message', handleMessage);
      workerRef.current.postMessage({
        type: 'PROCESS_HOLDERS',
        data: { rawOwners, tokenData }
      });
    });
  }, []);

  return { processHoldersAsync };
}
```

#### 3. å®‰å…¨æ€§å¼·åŒ–

##### API å®‰å…¨å‡ç´š

```typescript
// middleware.ts - Next.js ä¸­é–“ä»¶
import { NextRequest, NextResponse } from 'next/server';
import rateLimit from './utils/rateLimit';

export async function middleware(request: NextRequest) {
  // é€Ÿç‡é™åˆ¶
  const rateLimitResult = await rateLimit(request.ip);
  if (!rateLimitResult.success) {
    return NextResponse.json(
      { error: 'è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦' },
      { status: 429 }
    );
  }

  // API Key é©—è­‰
  if (request.nextUrl.pathname.startsWith('/api/')) {
    const apiKey = request.headers.get('x-api-key');
    if (!apiKey || !isValidApiKey(apiKey)) {
      return NextResponse.json(
        { error: 'ç„¡æ•ˆçš„ API Key' },
        { status: 401 }
      );
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: '/api/:path*',
};
```

##### è¼¸å…¥é©—è­‰å’Œæ¸…ç†

```typescript
// utils/validation.ts
import { z } from 'zod';
import DOMPurify from 'isomorphic-dompurify';

// ä½¿ç”¨ Zod é€²è¡Œå‹åˆ¥å®‰å…¨çš„é©—è­‰
export const TokenAddressSchema = z.string()
  .regex(/^0x[a-fA-F0-9]{40}$/, 'ç„¡æ•ˆçš„ä»¥å¤ªåŠåœ°å€æ ¼å¼')
  .transform(addr => addr.toLowerCase());

export const PaginationSchema = z.object({
  page: z.number().min(1).max(10000),
  limit: z.number().min(1).max(100),
});

export const SearchQuerySchema = z.string()
  .max(100, 'æœå°‹æŸ¥è©¢éé•·')
  .transform(query => DOMPurify.sanitize(query));

// ä½¿ç”¨ç¯„ä¾‹
export function validateTokenRequest(input: unknown) {
  try {
    return TokenAddressSchema.parse(input);
  } catch (error) {
    throw new ValidationError('ç„¡æ•ˆçš„ä»£å¹£åœ°å€');
  }
}
```

### ğŸŒŸ åŠŸèƒ½æ“´å±•æ–¹å‘

#### 1. åœ–è¡¨è¦–è¦ºåŒ–åŠŸèƒ½

##### æŒæœ‰è€…åˆ†å¸ƒåœ–è¡¨

```typescript
// components/HoldersDistributionChart.tsx
import { Chart as ChartJS, ArcElement, Tooltip, Legend } from 'chart.js';
import { Doughnut } from 'react-chartjs-2';

ChartJS.register(ArcElement, Tooltip, Legend);

interface HoldersDistributionChartProps {
  holders: TokenHolder[];
  className?: string;
}

export function HoldersDistributionChart({ 
  holders, 
  className = "" 
}: HoldersDistributionChartProps) {
  const distributionData = useMemo(() => {
    const ranges = [
      { label: 'é¯¨é­š (>1M)', min: 1000000, color: '#FF6B6B' },
      { label: 'å¤§æˆ¶ (100K-1M)', min: 100000, max: 1000000, color: '#4ECDC4' },
      { label: 'ä¸­æˆ¶ (10K-100K)', min: 10000, max: 100000, color: '#45B7D1' },
      { label: 'å°æˆ¶ (1K-10K)', min: 1000, max: 10000, color: '#96CEB4' },
      { label: 'æ•£æˆ¶ (<1K)', max: 1000, color: '#FFEAA7' },
    ];

    const distribution = ranges.map(range => {
      const count = holders.filter(holder => {
        const balance = holder.balanceNumber;
        return balance >= (range.min || 0) && balance < (range.max || Infinity);
      }).length;
      
      return { ...range, count };
    });

    return {
      labels: distribution.map(d => `${d.label} (${d.count})`),
      datasets: [{
        data: distribution.map(d => d.count),
        backgroundColor: distribution.map(d => d.color),
        borderWidth: 2,
        borderColor: '#ffffff',
      }],
    };
  }, [holders]);

  const options = {
    responsive: true,
    plugins: {
      legend: {
        position: 'right' as const,
      },
      tooltip: {
        callbacks: {
          label: (context: any) => {
            const percentage = ((context.parsed / holders.length) * 100).toFixed(1);
            return `${context.label}: ${percentage}%`;
          },
        },
      },
    },
  };

  return (
    <div className={`bg-white rounded-xl shadow-lg p-6 ${className}`}>
      <h3 className="text-lg font-semibold text-gray-900 mb-4">
        ğŸ“Š æŒæœ‰è€…åˆ†å¸ƒåˆ†æ
      </h3>
      <Doughnut data={distributionData} options={options} />
    </div>
  );
}
```

##### æ­·å²è¶¨å‹¢åœ–è¡¨

```typescript
// components/HistoricalTrendsChart.tsx
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';

ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

export function HistoricalTrendsChart({ tokenAddress }: { tokenAddress: string }) {
  const { data: historicalData, isLoading } = useHistoricalData(tokenAddress);

  const chartData = useMemo(() => {
    if (!historicalData) return null;

    return {
      labels: historicalData.dates,
      datasets: [
        {
          label: 'æŒæœ‰è€…æ•¸é‡',
          data: historicalData.holderCounts,
          borderColor: 'rgb(75, 192, 192)',
          backgroundColor: 'rgba(75, 192, 192, 0.2)',
          yAxisID: 'y',
        },
        {
          label: 'å‰10åä½”æ¯” (%)',
          data: historicalData.top10Percentages,
          borderColor: 'rgb(255, 99, 132)',
          backgroundColor: 'rgba(255, 99, 132, 0.2)',
          yAxisID: 'y1',
        },
      ],
    };
  }, [historicalData]);

  if (isLoading) return <div>è¼‰å…¥ä¸­...</div>;
  if (!chartData) return <div>ç„¡æ­·å²æ•¸æ“š</div>;

  return (
    <div className="bg-white rounded-xl shadow-lg p-6">
      <h3 className="text-lg font-semibold text-gray-900 mb-4">
        ğŸ“ˆ æ­·å²è¶¨å‹¢åˆ†æ
      </h3>
      <Line data={chartData} options={{
        responsive: true,
        interaction: {
          mode: 'index' as const,
          intersect: false,
        },
        scales: {
          x: {
            display: true,
            title: {
              display: true,
              text: 'æ™‚é–“'
            }
          },
          y: {
            type: 'linear' as const,
            display: true,
            position: 'left' as const,
            title: {
              display: true,
              text: 'æŒæœ‰è€…æ•¸é‡'
            },
          },
          y1: {
            type: 'linear' as const,
            display: true,
            position: 'right' as const,
            title: {
              display: true,
              text: 'å‰10åä½”æ¯” (%)'
            },
            grid: {
              drawOnChartArea: false,
            },
          },
        },
      }} />
    </div>
  );
}
```

#### 2. å¤šéˆæ”¯æ´æ“´å±•

```typescript
// utils/multiChainSupport.ts
export enum SupportedChains {
  ETHEREUM = 1,
  POLYGON = 137,
  BSC = 56,
  ARBITRUM = 42161,
  OPTIMISM = 10,
  AVALANCHE = 43114,
}

export const CHAIN_CONFIG = {
  [SupportedChains.ETHEREUM]: {
    name: 'Ethereum',
    symbol: 'ETH',
    rpcUrl: 'https://eth-mainnet.g.alchemy.com/v2/',
    explorerUrl: 'https://etherscan.io',
    icon: 'ğŸ”·',
  },
  [SupportedChains.POLYGON]: {
    name: 'Polygon',
    symbol: 'MATIC',
    rpcUrl: 'https://polygon-mainnet.g.alchemy.com/v2/',
    explorerUrl: 'https://polygonscan.com',
    icon: 'ğŸŸ£',
  },
  // ... å…¶ä»–éˆé…ç½®
};

export class MultiChainTokenAnalyzer {
  async getTokenHolders(tokenAddress: string, chainId: SupportedChains) {
    const config = CHAIN_CONFIG[chainId];
    const apiUrl = `${config.rpcUrl}${process.env.ALCHEMY_API_KEY}`;
    
    // æ ¹æ“šä¸åŒéˆèª¿ç”¨ç›¸æ‡‰çš„ API
    return this.fetchHoldersFromChain(tokenAddress, apiUrl, chainId);
  }

  async compareAcrossChains(tokenAddress: string) {
    const supportedChains = Object.keys(CHAIN_CONFIG).map(Number);
    
    const results = await Promise.allSettled(
      supportedChains.map(chainId => 
        this.getTokenHolders(tokenAddress, chainId)
      )
    );

    return this.aggregateResults(results, supportedChains);
  }
}
```

#### 3. AI é©…å‹•çš„åˆ†æåŠŸèƒ½

```typescript
// utils/aiAnalytics.ts
export class AITokenAnalyzer {
  private openaiClient: OpenAI;

  constructor() {
    this.openaiClient = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
  }

  async analyzeHolderPatterns(holders: TokenHolder[]): Promise<string> {
    const prompt = `
      åˆ†æä»¥ä¸‹ ERC20 ä»£å¹£æŒæœ‰è€…æ•¸æ“šï¼Œæä¾›æ´å¯Ÿï¼š
      
      ç¸½æŒæœ‰è€…æ•¸é‡: ${holders.length}
      å‰10åæŒæœ‰æ¯”ä¾‹: ${this.calculateTop10Percentage(holders)}%
      æŒæœ‰è€…åˆ†å¸ƒ: ${this.getDistributionSummary(holders)}
      
      è«‹æä¾›ï¼š
      1. å»ä¸­å¿ƒåŒ–ç¨‹åº¦è©•ä¼°
      2. é¢¨éšªåˆ†æ
      3. æŠ•è³‡å»ºè­°
      4. å¸‚å ´è¶¨å‹¢é æ¸¬
    `;

    const response = await this.openaiClient.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 500,
    });

    return response.choices[0]?.message?.content || '';
  }

  async detectAnomalies(holders: TokenHolder[]): Promise<{
    anomalies: string[];
    riskLevel: 'low' | 'medium' | 'high';
    recommendations: string[];
  }> {
    // ç•°å¸¸æª¢æ¸¬é‚è¼¯
    const anomalies = [];
    let riskLevel: 'low' | 'medium' | 'high' = 'low';

    // æª¢æŸ¥æ˜¯å¦æœ‰å–®ä¸€æŒæœ‰è€…ä½”æ¯”éé«˜
    const topHolderPercentage = holders[0]?.percentage || 0;
    if (topHolderPercentage > 50) {
      anomalies.push('å–®ä¸€æŒæœ‰è€…ä½”æ¯”è¶…é50%ï¼Œå­˜åœ¨ä¸­å¿ƒåŒ–é¢¨éšª');
      riskLevel = 'high';
    }

    // æª¢æŸ¥å‰10åé›†ä¸­åº¦
    const top10Percentage = this.calculateTop10Percentage(holders);
    if (top10Percentage > 80) {
      anomalies.push('å‰10åæŒæœ‰è€…ä½”æ¯”è¶…é80%ï¼Œæµå‹•æ€§å¯èƒ½ä¸è¶³');
      riskLevel = riskLevel === 'high' ? 'high' : 'medium';
    }

    return {
      anomalies,
      riskLevel,
      recommendations: this.generateRecommendations(anomalies, riskLevel),
    };
  }
}
```

### ğŸš€ éƒ¨ç½²ç­–ç•¥

#### 1. Vercel éƒ¨ç½² (æ¨è–¦)

##### åŸºæœ¬éƒ¨ç½²é…ç½®

```json
// vercel.json
{
  "buildCommand": "yarn build",
  "devCommand": "yarn dev",
  "installCommand": "yarn install",
  "framework": "nextjs",
  "regions": ["hnd1", "sfo1"],
  "functions": {
    "app/api/**": {
      "maxDuration": 30
    }
  },
  "env": {
    "NEXT_PUBLIC_ALCHEMY_API_KEY": "@alchemy_api_key",
    "ALCHEMY_API_KEY": "@alchemy_api_key_server",
    "DATABASE_URL": "@database_url"
  },
  "build": {
    "env": {
      "NEXT_TELEMETRY_DISABLED": "1"
    }
  }
}
```

##### ç’°å¢ƒè®Šæ•¸è¨­å®š

```bash
# Vercel CLI è¨­å®šç’°å¢ƒè®Šæ•¸
vercel env add ALCHEMY_API_KEY production
vercel env add NEXT_PUBLIC_ALCHEMY_API_KEY production
vercel env add DATABASE_URL production

# æˆ–ä½¿ç”¨ Vercel Dashboard è¨­å®š
```

##### è‡ªå‹•éƒ¨ç½² GitHub Action

```yaml
# .github/workflows/deploy.yml
name: Deploy to Vercel

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
          cache: 'yarn'
      
      - name: Install dependencies
        run: yarn install --frozen-lockfile
      
      - name: Run tests
        run: yarn test
      
      - name: Build project
        run: yarn build
        
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID }}
          vercel-project-id: ${{ secrets.PROJECT_ID }}
          vercel-args: '--prod'
```

#### 2. è‡ªå»ºä¼ºæœå™¨éƒ¨ç½²

##### Docker é…ç½®

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json yarn.lock* ./
RUN yarn --frozen-lockfile

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

ENV NEXT_TELEMETRY_DISABLED 1

RUN yarn build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000

CMD ["node", "server.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - ALCHEMY_API_KEY=${ALCHEMY_API_KEY}
      - DATABASE_URL=${DATABASE_URL}
    depends_on:
      - redis
      - postgres

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=richlist
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - web

volumes:
  redis_data:
  postgres_data:
```

#### 3. CDN å’Œæ•ˆèƒ½å„ªåŒ–

##### Cloudflare è¨­å®š

```javascript
// cloudflare-workers/api-cache.js
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // åªå¿«å– API è«‹æ±‚
    if (!url.pathname.startsWith('/api/')) {
      return fetch(request);
    }

    // ç”Ÿæˆå¿«å–éµ
    const cacheKey = new Request(url.toString(), request);
    const cache = caches.default;

    // å˜—è©¦å¾å¿«å–ç²å–
    let response = await cache.match(cacheKey);

    if (!response) {
      // å¿«å–æœªå‘½ä¸­ï¼Œç™¼é€è«‹æ±‚åˆ°æºä¼ºæœå™¨
      response = await fetch(request);

      // åªå¿«å–æˆåŠŸçš„å›æ‡‰
      if (response.status === 200) {
        const headers = new Headers(response.headers);
        headers.set('Cache-Control', 'public, max-age=300'); // 5åˆ†é˜å¿«å–
        
        response = new Response(response.body, {
          status: response.status,
          statusText: response.statusText,
          headers: headers,
        });

        // å„²å­˜åˆ°å¿«å–
        ctx.waitUntil(cache.put(cacheKey, response.clone()));
      }
    }

    return response;
  },
};
```

### ğŸ’° å•†æ¥­åŒ–ç­–ç•¥

#### 1. ç›ˆåˆ©æ¨¡å¼è¨­è¨ˆ

##### å…è²»å¢å€¼æ¨¡å¼ (Freemium)

```typescript
// utils/subscriptionTiers.ts
export enum SubscriptionTier {
  FREE = 'free',
  PRO = 'pro',
  ENTERPRISE = 'enterprise',
}

export const SUBSCRIPTION_LIMITS = {
  [SubscriptionTier.FREE]: {
    maxQueries: 100, // æ¯æœˆæŸ¥è©¢æ¬¡æ•¸
    maxTokens: 10,   // åŒæ™‚è¿½è¹¤ä»£å¹£æ•¸
    features: ['basic-search', 'export-csv'],
    support: 'community',
  },
  [SubscriptionTier.PRO]: {
    maxQueries: 10000,
    maxTokens: 100,
    features: ['advanced-analytics', 'historical-data', 'api-access', 'alerts'],
    support: 'email',
    price: 29, // USD/month
  },
  [SubscriptionTier.ENTERPRISE]: {
    maxQueries: -1, // ç„¡é™åˆ¶
    maxTokens: -1,
    features: ['white-label', 'custom-integration', 'dedicated-support'],
    support: 'dedicated',
    price: 299, // USD/month
  },
};

export class SubscriptionManager {
  async checkUsageLimit(userId: string, feature: string): Promise<boolean> {
    const user = await this.getUserSubscription(userId);
    const limits = SUBSCRIPTION_LIMITS[user.tier];
    
    switch (feature) {
      case 'query':
        return user.monthlyQueries < limits.maxQueries || limits.maxQueries === -1;
      case 'token-tracking':
        return user.trackedTokens.length < limits.maxTokens || limits.maxTokens === -1;
      default:
        return limits.features.includes(feature);
    }
  }
}
```

##### API æœå‹™åŒ–

```typescript
// pages/api/v1/token/[address]/holders.ts
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // API Key é©—è­‰
  const apiKey = req.headers['x-api-key'] as string;
  const user = await validateApiKey(apiKey);
  
  if (!user) {
    return res.status(401).json({ error: 'Invalid API key' });
  }

  // ä½¿ç”¨é‡æª¢æŸ¥
  const canUse = await checkApiUsage(user.id, 'holders-query');
  if (!canUse) {
    return res.status(429).json({ 
      error: 'API usage limit exceeded',
      upgradeUrl: '/pricing'
    });
  }

  try {
    const { address } = req.query;
    const holders = await getTokenHolders(address as string);
    
    // è¨˜éŒ„ä½¿ç”¨é‡
    await recordApiUsage(user.id, 'holders-query');
    
    res.json({
      success: true,
      data: holders,
      usage: await getUserUsage(user.id),
    });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
}
```

#### 2. æ•¸æ“šè®Šç¾ç­–ç•¥

##### ç™½æ¨™è§£æ±ºæ–¹æ¡ˆ

```typescript
// components/WhiteLabelProvider.tsx
export function WhiteLabelProvider({ 
  children, 
  config 
}: { 
  children: React.ReactNode;
  config: WhiteLabelConfig;
}) {
  return (
    <ThemeProvider theme={config.theme}>
      <BrandProvider brand={config.brand}>
        <AnalyticsProvider trackingId={config.analytics.trackingId}>
          {children}
        </AnalyticsProvider>
      </BrandProvider>
    </ThemeProvider>
  );
}

interface WhiteLabelConfig {
  brand: {
    name: string;
    logo: string;
    colors: {
      primary: string;
      secondary: string;
    };
  };
  theme: {
    mode: 'light' | 'dark';
    customCss?: string;
  };
  analytics: {
    trackingId: string;
    customEvents?: string[];
  };
}
```

##### æ•¸æ“šæˆæ¬Šæœå‹™

```typescript
// services/dataLicensing.ts
export class DataLicensingService {
  async generateDataReport(tokenAddress: string, format: 'json' | 'csv' | 'pdf') {
    const holders = await this.getTokenHolders(tokenAddress);
    const analytics = await this.generateAnalytics(holders);
    
    switch (format) {
      case 'json':
        return this.generateJsonReport(holders, analytics);
      case 'csv':
        return this.generateCsvReport(holders);
      case 'pdf':
        return this.generatePdfReport(holders, analytics);
    }
  }

  async scheduleRegularReports(
    clientId: string, 
    tokens: string[], 
    frequency: 'daily' | 'weekly' | 'monthly'
  ) {
    // è¨­å®šå®šæœŸå ±å‘Šç”Ÿæˆ
    await this.scheduleJob({
      clientId,
      tokens,
      frequency,
      nextRun: this.calculateNextRun(frequency),
    });
  }
}
```

### ğŸ”§ ç¶­è­·æ€§æ”¹é€²

#### 1. ç›£æ§å’Œæ—¥èªŒç³»çµ±

```typescript
// utils/monitoring.ts
import { createLogger, transports, format } from 'winston';

export const logger = createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: format.combine(
    format.timestamp(),
    format.errors({ stack: true }),
    format.json()
  ),
  defaultMeta: { service: 'richlist-app' },
  transports: [
    new transports.File({ filename: 'logs/error.log', level: 'error' }),
    new transports.File({ filename: 'logs/combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new transports.Console({
    format: format.simple()
  }));
}

// æ•ˆèƒ½ç›£æ§
export class PerformanceMonitor {
  static startTimer(label: string): () => void {
    const start = Date.now();
    
    return () => {
      const duration = Date.now() - start;
      logger.info(`Performance: ${label} took ${duration}ms`);
      
      // ç™¼é€åˆ°ç›£æ§æœå‹™
      if (process.env.NODE_ENV === 'production') {
        this.sendMetric(label, duration);
      }
    };
  }

  private static async sendMetric(label: string, duration: number) {
    // ç™¼é€åˆ° DataDog, New Relic ç­‰ç›£æ§æœå‹™
    await fetch('https://api.datadoghq.com/api/v1/series', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'DD-API-KEY': process.env.DATADOG_API_KEY!,
      },
      body: JSON.stringify({
        series: [{
          metric: `richlist.${label}.duration`,
          points: [[Math.floor(Date.now() / 1000), duration]],
          tags: [`env:${process.env.NODE_ENV}`],
        }],
      }),
    });
  }
}
```

#### 2. è‡ªå‹•åŒ–æ¸¬è©¦æ“´å±•

```typescript
// e2e/richlist.spec.ts - Playwright E2E æ¸¬è©¦
import { test, expect } from '@playwright/test';

test.describe('Rich List Application', () => {
  test('should display token holders after search', async ({ page }) => {
    await page.goto('/');
    
    // è¼¸å…¥ä»£å¹£åœ°å€
    await page.fill('[data-testid=token-address-input]', '0x1234567890123456789012345678901234567890');
    
    // é»æ“Šæœå°‹
    await page.click('[data-testid=search-button]');
    
    // ç­‰å¾…çµæœè¼‰å…¥
    await page.waitForSelector('[data-testid=holders-table]');
    
    // é©—è­‰çµæœ
    const holdersCount = await page.locator('[data-testid=holders-row]').count();
    expect(holdersCount).toBeGreaterThan(0);
    
    // é©—è­‰åˆ†é åŠŸèƒ½
    if (holdersCount === 20) { // å¦‚æœæœ‰åˆ†é 
      await page.click('[data-testid=next-page-button]');
      await page.waitForSelector('[data-testid=holders-table]');
      
      const currentPage = await page.textContent('[data-testid=current-page]');
      expect(currentPage).toBe('2');
    }
  });

  test('should handle search and sorting', async ({ page }) => {
    await page.goto('/rich-list?token=0x1234567890123456789012345678901234567890');
    
    // ç­‰å¾…æ•¸æ“šè¼‰å…¥
    await page.waitForSelector('[data-testid=holders-table]');
    
    // æ¸¬è©¦æœå°‹åŠŸèƒ½
    await page.fill('[data-testid=search-input]', '0x123');
    await page.press('[data-testid=search-input]', 'Enter');
    
    // é©—è­‰æœå°‹çµæœ
    await page.waitForSelector('[data-testid=search-results]');
    const results = await page.locator('[data-testid=holders-row]').count();
    expect(results).toBeGreaterThanOrEqual(0);
    
    // æ¸¬è©¦æ’åºåŠŸèƒ½
    await page.click('[data-testid=sort-by-balance]');
    
    // é©—è­‰æ’åºçµæœ
    const firstBalance = await page.textContent('[data-testid=holder-balance]:first-child');
    const secondBalance = await page.textContent('[data-testid=holder-balance]:nth-child(2)');
    
    expect(parseFloat(firstBalance!)).toBeGreaterThanOrEqual(parseFloat(secondBalance!));
  });
});
```

### ğŸ“Š æˆåŠŸæŒ‡æ¨™è¿½è¹¤

#### 1. é—œéµæ•ˆèƒ½æŒ‡æ¨™ (KPIs)

```typescript
// utils/analytics.ts
export class AnalyticsTracker {
  private static instance: AnalyticsTracker;
  
  static getInstance(): AnalyticsTracker {
    if (!this.instance) {
      this.instance = new AnalyticsTracker();
    }
    return this.instance;
  }

  // ç”¨æˆ¶è¡Œç‚ºè¿½è¹¤
  trackUserAction(action: string, properties?: Record<string, any>) {
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', action, properties);
    }
    
    // åŒæ™‚ç™¼é€åˆ°è‡ªå®šç¾©åˆ†ææœå‹™
    this.sendToCustomAnalytics('user_action', {
      action,
      ...properties,
      timestamp: new Date().toISOString(),
      sessionId: this.getSessionId(),
    });
  }

  // æ¥­å‹™æŒ‡æ¨™è¿½è¹¤
  trackBusinessMetric(metric: string, value: number, unit?: string) {
    const data = {
      metric,
      value,
      unit,
      timestamp: new Date().toISOString(),
    };

    // ç™¼é€åˆ°æ¥­å‹™åˆ†æå¹³å°
    this.sendToBusinessAnalytics(data);
  }

  // æ•ˆèƒ½æŒ‡æ¨™è¿½è¹¤
  trackPerformanceMetric(metric: string, value: number) {
    if (typeof window !== 'undefined' && window.performance) {
      // ä½¿ç”¨ Performance API
      performance.mark(`${metric}-${value}`);
    }

    this.sendToPerformanceMonitoring({
      metric,
      value,
      timestamp: Date.now(),
      userAgent: typeof window !== 'undefined' ? window.navigator.userAgent : 'server',
    });
  }
}

// ä½¿ç”¨ç¯„ä¾‹
const analytics = AnalyticsTracker.getInstance();

// è¿½è¹¤ç”¨æˆ¶æŸ¥è©¢
analytics.trackUserAction('token_search', {
  tokenAddress: '0x123...',
  searchDuration: 1500, // ms
});

// è¿½è¹¤æ¥­å‹™æŒ‡æ¨™
analytics.trackBusinessMetric('daily_active_users', 1250);
analytics.trackBusinessMetric('api_calls', 50000, 'requests');

// è¿½è¹¤æ•ˆèƒ½æŒ‡æ¨™
analytics.trackPerformanceMetric('page_load_time', 2300);
```

### âœ… å¯¦ä½œå„ªå…ˆç´šå»ºè­°

#### çŸ­æœŸç›®æ¨™ (1-2å€‹æœˆ)
1. **éƒ¨ç½²åˆ°ç”Ÿç”¢ç’°å¢ƒ** - Vercel éƒ¨ç½²
2. **åŸºç¤ç›£æ§è¨­å®š** - éŒ¯èª¤è¿½è¹¤å’Œæ•ˆèƒ½ç›£æ§
3. **SEO å„ªåŒ–** - å…ƒæ¨™ç±¤å’Œçµæ§‹åŒ–æ•¸æ“š
4. **åŸºç¤åˆ†æ** - Google Analytics æ•´åˆ

#### ä¸­æœŸç›®æ¨™ (3-6å€‹æœˆ)
1. **åœ–è¡¨è¦–è¦ºåŒ–** - æŒæœ‰è€…åˆ†å¸ƒå’Œè¶¨å‹¢åœ–è¡¨
2. **å¤šéˆæ”¯æ´** - è‡³å°‘æ”¯æ´ 3 å€‹ä¸»è¦å€å¡Šéˆ
3. **API æœå‹™åŒ–** - æä¾›ä»˜è²» API æœå‹™
4. **ç”¨æˆ¶ç³»çµ±** - è¨»å†Šã€ç™»å…¥å’Œå€‹äººåŒ–åŠŸèƒ½

#### é•·æœŸç›®æ¨™ (6-12å€‹æœˆ)
1. **AI åˆ†æåŠŸèƒ½** - æ™ºèƒ½æ´å¯Ÿå’Œé æ¸¬
2. **ä¼æ¥­è§£æ±ºæ–¹æ¡ˆ** - ç™½æ¨™å’Œå®¢è£½åŒ–æœå‹™
3. **ç§»å‹•æ‡‰ç”¨** - React Native æˆ– Flutter æ‡‰ç”¨
4. **åœ‹éš›åŒ–** - å¤šèªè¨€æ”¯æ´

é€™äº›å„ªåŒ–æ–¹å‘å°‡å¹«åŠ©ä½ çš„ DApp å¾ä¸€å€‹å­¸ç¿’å°ˆæ¡ˆç™¼å±•æˆç‚ºä¸€å€‹çœŸæ­£çš„ç”¢å“ã€‚è¨˜ä½ï¼Œæœ€é‡è¦çš„æ˜¯å…ˆè®“ç”¢å“é‹è¡Œèµ·ä¾†ï¼Œç„¶å¾Œæ ¹æ“šç”¨æˆ¶åé¥‹æŒçºŒæ”¹é€²ï¼

---

**æº–å‚™å¥½å°‡ä½ çš„ DApp æ¨å‘å¸‚å ´äº†å—ï¼Ÿ** ğŸŒŸ
