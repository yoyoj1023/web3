# 單元五：進階功能 - 實現分頁

## 第一課：分頁邏輯設計

### 🎯 學習目標

在這一課中，我們將：
- 理解分頁在大數據處理中的重要性
- 學習不同分頁策略的優缺點
- 設計適合區塊鏈數據的分頁方案
- 實作高效的分頁邏輯和狀態管理

### 🤔 為什麼需要分頁？

#### 效能考量

當處理大量代幣持有者數據時，一次性載入和顯示所有數據會導致：

1. **記憶體消耗過大**：大量 DOM 元素影響瀏覽器效能
2. **載入時間過長**：用戶需要等待所有數據載入完成
3. **渲染效能下降**：大量元素導致頁面滾動和互動卡頓
4. **用戶體驗不佳**：資訊過載，難以找到重要資訊

#### 實際數據量分析

```typescript
// 典型 ERC20 代幣持有者數量分析
interface TokenStats {
  tokenName: string;
  holdersCount: number;
  category: 'small' | 'medium' | 'large' | 'massive';
}

const exampleTokens: TokenStats[] = [
  { tokenName: "小型項目代幣", holdersCount: 100, category: 'small' },
  { tokenName: "中型項目代幣", holdersCount: 5000, category: 'medium' },
  { tokenName: "大型項目代幣", holdersCount: 50000, category: 'large' },
  { tokenName: "主流代幣", holdersCount: 500000, category: 'massive' },
];

// 不同數據量的渲染時間估算
const calculateRenderTime = (holdersCount: number): number => {
  // 假設每個持有者項目渲染需要 0.1ms
  return holdersCount * 0.1; // 毫秒
};

// 範例：50,000 持有者 = 5,000ms (5秒) 渲染時間
```

#### 用戶體驗影響

```typescript
// 用戶行為分析
interface UserBehaviorData {
  totalHolders: number;
  viewedHolders: number;
  viewPercentage: number;
  averageViewTime: number; // 秒
}

const userBehaviorAnalysis: UserBehaviorData[] = [
  { totalHolders: 1000, viewedHolders: 50, viewPercentage: 5, averageViewTime: 30 },
  { totalHolders: 10000, viewedHolders: 100, viewPercentage: 1, averageViewTime: 45 },
  { totalHolders: 100000, viewedHolders: 200, viewPercentage: 0.2, averageViewTime: 60 },
];

// 結論：用戶通常只查看前面的少量數據
```

### 📊 分頁策略比較

#### 1. 客戶端分頁 (Client-side Pagination)

**工作原理：**
```typescript
interface ClientSidePagination {
  // 一次性獲取所有數據
  allData: TokenHolder[];
  
  // 客戶端計算分頁
  currentPage: number;
  itemsPerPage: number;
  
  // 計算當前頁數據
  getCurrentPageData(): TokenHolder[] {
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    return this.allData.slice(startIndex, endIndex);
  }
}
```

**優點：**
- ✅ 實作簡單
- ✅ 頁面切換速度快
- ✅ 支援即時搜尋和排序
- ✅ 無需額外 API 請求

**缺點：**
- ❌ 初始載入時間長
- ❌ 記憶體消耗大
- ❌ 不適合超大數據集
- ❌ 數據更新需要重新載入全部

**適用場景：**
- 數據量 < 10,000 筆
- 需要頻繁搜尋和排序
- 數據相對靜態

#### 2. 伺服器端分頁 (Server-side Pagination)

**工作原理：**
```typescript
interface ServerSidePagination {
  currentPage: number;
  itemsPerPage: number;
  totalItems: number;
  
  // 每次請求特定頁面的數據
  async fetchPage(page: number): Promise<{
    data: TokenHolder[];
    totalPages: number;
    currentPage: number;
  }> {
    const response = await fetch(`/api/holders?page=${page}&limit=${this.itemsPerPage}`);
    return response.json();
  }
}
```

**優點：**
- ✅ 記憶體使用效率高
- ✅ 初始載入速度快
- ✅ 適合超大數據集
- ✅ 支援即時數據更新

**缺點：**
- ❌ 頁面切換需要網路請求
- ❌ 實作複雜度較高
- ❌ 搜尋和排序需要後端支援
- ❌ 離線使用體驗差

**適用場景：**
- 數據量 > 10,000 筆
- 數據經常變動
- 需要減少頻寬使用

#### 3. 混合分頁 (Hybrid Pagination)

**工作原理：**
```typescript
interface HybridPagination {
  // 分批載入數據
  loadedPages: Map<number, TokenHolder[]>;
  currentPage: number;
  itemsPerPage: number;
  batchSize: number; // 每次載入的頁數
  
  async getCurrentPageData(): Promise<TokenHolder[]> {
    if (!this.loadedPages.has(this.currentPage)) {
      // 載入當前頁及附近頁面
      await this.loadPageBatch(this.currentPage);
    }
    return this.loadedPages.get(this.currentPage) || [];
  }
  
  async loadPageBatch(centerPage: number): Promise<void> {
    const startPage = Math.max(1, centerPage - Math.floor(this.batchSize / 2));
    const endPage = startPage + this.batchSize - 1;
    
    // 載入多頁數據
    for (let page = startPage; page <= endPage; page++) {
      if (!this.loadedPages.has(page)) {
        const data = await this.fetchPage(page);
        this.loadedPages.set(page, data);
      }
    }
  }
}
```

**優點：**
- ✅ 平衡載入速度和記憶體使用
- ✅ 預載入提升用戶體驗
- ✅ 靈活的快取策略
- ✅ 適應不同數據量

**缺點：**
- ❌ 實作複雜度最高
- ❌ 需要精細的快取管理
- ❌ 可能出現數據不一致

### 🏗️ 區塊鏈數據分頁設計

考慮到區塊鏈數據的特性，我們採用**客戶端分頁 + 虛擬滾動**的方案：

#### 數據特性分析

```typescript
interface BlockchainDataCharacteristics {
  // 數據相對靜態（除非有新交易）
  isStatic: boolean;
  
  // 數據量通常可控（大部分代幣 < 50,000 持有者）
  typicalSize: number;
  
  // 用戶主要關注前排數據
  userFocusOnTop: boolean;
  
  // API 請求成本較高（需要遍歷區塊鏈）
  apiCostHigh: boolean;
}

const blockchainDataProfile: BlockchainDataCharacteristics = {
  isStatic: true,
  typicalSize: 10000,
  userFocusOnTop: true,
  apiCostHigh: true,
};
```

#### 我們的分頁方案

```typescript
interface OptimizedPaginationStrategy {
  // 第一階段：載入前 1000 名（滿足大部分用戶需求）
  initialLoad: {
    count: 1000;
    showPagination: false;
    showLoadMore: true;
  };
  
  // 第二階段：按需載入更多數據
  onDemandLoad: {
    batchSize: 1000;
    maxTotal: 10000; // 限制最大載入量
    showPagination: true;
  };
  
  // 第三階段：虛擬滾動處理超大數據
  virtualScrolling: {
    threshold: 10000;
    renderWindowSize: 50; // 只渲染可見區域
    bufferSize: 10; // 上下緩衝區
  };
}
```

### 🔧 分頁邏輯實作

#### 基礎分頁類別

```typescript
export class PaginationManager<T> {
  private data: T[] = [];
  private currentPage: number = 1;
  private itemsPerPage: number = 20;
  private totalItems: number = 0;

  constructor(itemsPerPage: number = 20) {
    this.itemsPerPage = itemsPerPage;
  }

  /**
   * 設定數據
   */
  setData(data: T[]): void {
    this.data = data;
    this.totalItems = data.length;
    this.currentPage = 1; // 重置到第一頁
  }

  /**
   * 獲取當前頁數據
   */
  getCurrentPageData(): T[] {
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = Math.min(startIndex + this.itemsPerPage, this.totalItems);
    return this.data.slice(startIndex, endIndex);
  }

  /**
   * 獲取分頁資訊
   */
  getPaginationInfo(): {
    currentPage: number;
    totalPages: number;
    totalItems: number;
    itemsPerPage: number;
    startItem: number;
    endItem: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  } {
    const totalPages = Math.ceil(this.totalItems / this.itemsPerPage);
    const startItem = (this.currentPage - 1) * this.itemsPerPage + 1;
    const endItem = Math.min(this.currentPage * this.itemsPerPage, this.totalItems);

    return {
      currentPage: this.currentPage,
      totalPages,
      totalItems: this.totalItems,
      itemsPerPage: this.itemsPerPage,
      startItem,
      endItem,
      hasNextPage: this.currentPage < totalPages,
      hasPrevPage: this.currentPage > 1,
    };
  }

  /**
   * 跳轉到指定頁面
   */
  goToPage(page: number): boolean {
    const totalPages = Math.ceil(this.totalItems / this.itemsPerPage);
    
    if (page < 1 || page > totalPages) {
      return false;
    }

    this.currentPage = page;
    return true;
  }

  /**
   * 下一頁
   */
  nextPage(): boolean {
    return this.goToPage(this.currentPage + 1);
  }

  /**
   * 上一頁
   */
  prevPage(): boolean {
    return this.goToPage(this.currentPage - 1);
  }

  /**
   * 設定每頁項目數
   */
  setItemsPerPage(itemsPerPage: number): void {
    if (itemsPerPage < 1) return;
    
    // 計算當前項目在新分頁中的位置
    const currentFirstItem = (this.currentPage - 1) * this.itemsPerPage + 1;
    
    this.itemsPerPage = itemsPerPage;
    
    // 調整當前頁面以保持大致相同的位置
    const newPage = Math.ceil(currentFirstItem / itemsPerPage);
    this.goToPage(newPage);
  }

  /**
   * 獲取頁面範圍（用於分頁導航）
   */
  getPageRange(maxVisible: number = 5): number[] {
    const totalPages = Math.ceil(this.totalItems / this.itemsPerPage);
    
    if (totalPages <= maxVisible) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    const half = Math.floor(maxVisible / 2);
    let start = Math.max(1, this.currentPage - half);
    let end = Math.min(totalPages, start + maxVisible - 1);

    // 調整起始位置以確保顯示足夠的頁面
    if (end - start + 1 < maxVisible) {
      start = Math.max(1, end - maxVisible + 1);
    }

    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
  }

  /**
   * 搜尋功能
   */
  search(query: string, searchFn: (item: T, query: string) => boolean): T[] {
    if (!query.trim()) {
      return this.data;
    }

    return this.data.filter(item => searchFn(item, query.toLowerCase()));
  }

  /**
   * 排序功能
   */
  sort(compareFn: (a: T, b: T) => number): void {
    this.data.sort(compareFn);
  }
}
```

#### 針對代幣持有者的專用分頁類別

```typescript
export class TokenHoldersPagination extends PaginationManager<TokenHolder> {
  private originalData: TokenHolder[] = [];
  private filteredData: TokenHolder[] = [];
  private searchQuery: string = '';
  private sortField: keyof TokenHolder = 'balanceNumber';
  private sortDirection: 'asc' | 'desc' = 'desc';

  /**
   * 設定持有者數據
   */
  setHolders(holders: TokenHolder[]): void {
    this.originalData = [...holders];
    this.filteredData = [...holders];
    this.applyFiltersAndSort();
  }

  /**
   * 搜尋持有者
   */
  searchHolders(query: string): void {
    this.searchQuery = query.toLowerCase();
    this.applyFiltersAndSort();
  }

  /**
   * 排序持有者
   */
  sortHolders(field: keyof TokenHolder, direction: 'asc' | 'desc' = 'desc'): void {
    this.sortField = field;
    this.sortDirection = direction;
    this.applyFiltersAndSort();
  }

  /**
   * 按餘額範圍過濾
   */
  filterByBalance(minBalance: number, maxBalance: number = Infinity): void {
    this.filteredData = this.originalData.filter(holder => 
      holder.balanceNumber >= minBalance && holder.balanceNumber <= maxBalance
    );
    this.applyFiltersAndSort();
  }

  /**
   * 獲取前 N 名持有者
   */
  getTopHolders(count: number): TokenHolder[] {
    return this.filteredData
      .sort((a, b) => b.balanceNumber - a.balanceNumber)
      .slice(0, count);
  }

  /**
   * 查找特定地址
   */
  findHolder(address: string): {
    holder: TokenHolder | null;
    page: number;
    indexInPage: number;
  } {
    const normalizedAddress = address.toLowerCase();
    const index = this.filteredData.findIndex(
      holder => holder.address.toLowerCase() === normalizedAddress
    );

    if (index === -1) {
      return { holder: null, page: 0, indexInPage: 0 };
    }

    const holder = this.filteredData[index];
    const page = Math.ceil((index + 1) / this.itemsPerPage);
    const indexInPage = index % this.itemsPerPage;

    return { holder, page, indexInPage };
  }

  /**
   * 應用過濾和排序
   */
  private applyFiltersAndSort(): void {
    let data = [...this.originalData];

    // 應用搜尋過濾
    if (this.searchQuery) {
      data = data.filter(holder =>
        holder.address.toLowerCase().includes(this.searchQuery) ||
        holder.balanceFormatted.toLowerCase().includes(this.searchQuery)
      );
    }

    // 應用排序
    data.sort((a, b) => {
      const aValue = a[this.sortField];
      const bValue = b[this.sortField];
      
      let comparison = 0;
      if (typeof aValue === 'number' && typeof bValue === 'number') {
        comparison = aValue - bValue;
      } else {
        comparison = String(aValue).localeCompare(String(bValue));
      }

      return this.sortDirection === 'desc' ? -comparison : comparison;
    });

    this.filteredData = data;
    this.setData(this.filteredData);
  }

  /**
   * 獲取統計資訊
   */
  getStats(): {
    totalHolders: number;
    filteredHolders: number;
    currentPageHolders: number;
    averageBalance: number;
    totalBalance: number;
  } {
    const currentPageData = this.getCurrentPageData();
    const totalBalance = this.filteredData.reduce((sum, holder) => sum + holder.balanceNumber, 0);
    const averageBalance = this.filteredData.length > 0 ? totalBalance / this.filteredData.length : 0;

    return {
      totalHolders: this.originalData.length,
      filteredHolders: this.filteredData.length,
      currentPageHolders: currentPageData.length,
      averageBalance,
      totalBalance,
    };
  }

  /**
   * 導出當前頁面數據
   */
  exportCurrentPage(): string {
    const data = this.getCurrentPageData();
    const headers = ['Rank', 'Address', 'Balance', 'Percentage'];
    
    const csvContent = [
      headers.join(','),
      ...data.map(holder => [
        holder.rank || '',
        holder.address,
        holder.balanceFormatted,
        `${holder.percentage.toFixed(4)}%`
      ].join(','))
    ].join('\n');

    return csvContent;
  }
}
```

### 📊 效能優化策略

#### 1. 虛擬滾動實作

```typescript
interface VirtualScrollOptions {
  itemHeight: number;
  containerHeight: number;
  bufferSize: number;
}

class VirtualScrollManager<T> {
  private options: VirtualScrollOptions;
  private data: T[] = [];
  private scrollTop: number = 0;

  constructor(options: VirtualScrollOptions) {
    this.options = options;
  }

  /**
   * 計算可見範圍
   */
  getVisibleRange(): { start: number; end: number; offset: number } {
    const { itemHeight, containerHeight, bufferSize } = this.options;
    
    const start = Math.max(0, Math.floor(this.scrollTop / itemHeight) - bufferSize);
    const visibleCount = Math.ceil(containerHeight / itemHeight);
    const end = Math.min(this.data.length, start + visibleCount + bufferSize * 2);
    const offset = start * itemHeight;

    return { start, end, offset };
  }

  /**
   * 獲取可見項目
   */
  getVisibleItems(): { items: T[]; offset: number; totalHeight: number } {
    const { start, end, offset } = this.getVisibleRange();
    const items = this.data.slice(start, end);
    const totalHeight = this.data.length * this.options.itemHeight;

    return { items, offset, totalHeight };
  }

  /**
   * 更新滾動位置
   */
  updateScrollTop(scrollTop: number): void {
    this.scrollTop = scrollTop;
  }

  /**
   * 設定數據
   */
  setData(data: T[]): void {
    this.data = data;
    this.scrollTop = 0;
  }
}
```

#### 2. 記憶體管理

```typescript
class MemoryManager {
  private static readonly MAX_CACHE_SIZE = 50 * 1024 * 1024; // 50MB
  private static cacheSize = 0;
  private static cache = new Map<string, any>();

  static set(key: string, value: any): void {
    const size = this.estimateSize(value);
    
    // 如果新數據會超出限制，清理舊數據
    while (this.cacheSize + size > this.MAX_CACHE_SIZE && this.cache.size > 0) {
      const firstKey = this.cache.keys().next().value;
      const firstValue = this.cache.get(firstKey);
      this.cache.delete(firstKey);
      this.cacheSize -= this.estimateSize(firstValue);
    }

    this.cache.set(key, value);
    this.cacheSize += size;
  }

  static get(key: string): any {
    return this.cache.get(key);
  }

  static clear(): void {
    this.cache.clear();
    this.cacheSize = 0;
  }

  private static estimateSize(obj: any): number {
    return JSON.stringify(obj).length * 2; // 粗略估算
  }
}
```

### 🧪 效能測試

建立效能測試工具：

```typescript
class PaginationPerformanceTest {
  /**
   * 測試不同數據量的渲染效能
   */
  static async testRenderPerformance(dataSizes: number[]): Promise<void> {
    for (const size of dataSizes) {
      const testData = this.generateTestData(size);
      
      const startTime = performance.now();
      
      // 模擬渲染過程
      const pagination = new TokenHoldersPagination(20);
      pagination.setHolders(testData);
      
      for (let page = 1; page <= Math.min(10, pagination.getPaginationInfo().totalPages); page++) {
        pagination.goToPage(page);
        const pageData = pagination.getCurrentPageData();
        // 模擬 DOM 操作
        await new Promise(resolve => setTimeout(resolve, 1));
      }
      
      const endTime = performance.now();
      
      console.log(`數據量: ${size}, 渲染時間: ${(endTime - startTime).toFixed(2)}ms`);
    }
  }

  /**
   * 測試搜尋效能
   */
  static testSearchPerformance(dataSize: number, searchQueries: string[]): void {
    const testData = this.generateTestData(dataSize);
    const pagination = new TokenHoldersPagination(20);
    pagination.setHolders(testData);

    searchQueries.forEach(query => {
      const startTime = performance.now();
      pagination.searchHolders(query);
      const endTime = performance.now();
      
      console.log(`搜尋 "${query}": ${(endTime - startTime).toFixed(2)}ms`);
    });
  }

  /**
   * 生成測試數據
   */
  private static generateTestData(count: number): TokenHolder[] {
    return Array.from({ length: count }, (_, index) => ({
      address: `0x${Math.random().toString(16).substr(2, 40)}`,
      balance: `0x${Math.random().toString(16).substr(2, 16)}`,
      balanceFormatted: (Math.random() * 1000000).toFixed(2),
      balanceNumber: Math.random() * 1000000,
      percentage: Math.random() * 100,
      rank: index + 1,
    }));
  }
}

// 執行效能測試
// PaginationPerformanceTest.testRenderPerformance([100, 1000, 10000, 50000]);
```

### ✅ 小結

在這一課中，我們深入分析了分頁邏輯的設計原理：

✅ **分頁重要性理解**
- 效能考量和用戶體驗影響
- 不同數據量的處理策略
- 記憶體和渲染效能優化

✅ **分頁策略比較**
- 客戶端分頁 vs 伺服器端分頁
- 混合分頁方案設計
- 區塊鏈數據的特殊考量

✅ **完整分頁類別實作**
- 基礎分頁管理器
- 代幣持有者專用分頁
- 搜尋、排序、過濾功能

✅ **效能優化技術**
- 虛擬滾動實作
- 記憶體管理策略
- 效能測試工具

在下一課中，我們將把這些分頁邏輯整合到我們的 `useTokenHolders` Hook 中，實現真正可用的分頁功能！

---

**準備好將分頁邏輯整合到我們的 Hook 中了嗎？** 🔧
