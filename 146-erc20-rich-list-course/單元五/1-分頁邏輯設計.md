# å–®å…ƒäº”ï¼šé€²éšåŠŸèƒ½ - å¯¦ç¾åˆ†é 

## ç¬¬ä¸€èª²ï¼šåˆ†é é‚è¼¯è¨­è¨ˆ

### ğŸ¯ å­¸ç¿’ç›®æ¨™

åœ¨é€™ä¸€èª²ä¸­ï¼Œæˆ‘å€‘å°‡ï¼š
- ç†è§£åˆ†é åœ¨å¤§æ•¸æ“šè™•ç†ä¸­çš„é‡è¦æ€§
- å­¸ç¿’ä¸åŒåˆ†é ç­–ç•¥çš„å„ªç¼ºé»
- è¨­è¨ˆé©åˆå€å¡Šéˆæ•¸æ“šçš„åˆ†é æ–¹æ¡ˆ
- å¯¦ä½œé«˜æ•ˆçš„åˆ†é é‚è¼¯å’Œç‹€æ…‹ç®¡ç†

### ğŸ¤” ç‚ºä»€éº¼éœ€è¦åˆ†é ï¼Ÿ

#### æ•ˆèƒ½è€ƒé‡

ç•¶è™•ç†å¤§é‡ä»£å¹£æŒæœ‰è€…æ•¸æ“šæ™‚ï¼Œä¸€æ¬¡æ€§è¼‰å…¥å’Œé¡¯ç¤ºæ‰€æœ‰æ•¸æ“šæœƒå°è‡´ï¼š

1. **è¨˜æ†¶é«”æ¶ˆè€—éå¤§**ï¼šå¤§é‡ DOM å…ƒç´ å½±éŸ¿ç€è¦½å™¨æ•ˆèƒ½
2. **è¼‰å…¥æ™‚é–“éé•·**ï¼šç”¨æˆ¶éœ€è¦ç­‰å¾…æ‰€æœ‰æ•¸æ“šè¼‰å…¥å®Œæˆ
3. **æ¸²æŸ“æ•ˆèƒ½ä¸‹é™**ï¼šå¤§é‡å…ƒç´ å°è‡´é é¢æ»¾å‹•å’Œäº’å‹•å¡é “
4. **ç”¨æˆ¶é«”é©—ä¸ä½³**ï¼šè³‡è¨Šéè¼‰ï¼Œé›£ä»¥æ‰¾åˆ°é‡è¦è³‡è¨Š

#### å¯¦éš›æ•¸æ“šé‡åˆ†æ

```typescript
// å…¸å‹ ERC20 ä»£å¹£æŒæœ‰è€…æ•¸é‡åˆ†æ
interface TokenStats {
  tokenName: string;
  holdersCount: number;
  category: 'small' | 'medium' | 'large' | 'massive';
}

const exampleTokens: TokenStats[] = [
  { tokenName: "å°å‹é …ç›®ä»£å¹£", holdersCount: 100, category: 'small' },
  { tokenName: "ä¸­å‹é …ç›®ä»£å¹£", holdersCount: 5000, category: 'medium' },
  { tokenName: "å¤§å‹é …ç›®ä»£å¹£", holdersCount: 50000, category: 'large' },
  { tokenName: "ä¸»æµä»£å¹£", holdersCount: 500000, category: 'massive' },
];

// ä¸åŒæ•¸æ“šé‡çš„æ¸²æŸ“æ™‚é–“ä¼°ç®—
const calculateRenderTime = (holdersCount: number): number => {
  // å‡è¨­æ¯å€‹æŒæœ‰è€…é …ç›®æ¸²æŸ“éœ€è¦ 0.1ms
  return holdersCount * 0.1; // æ¯«ç§’
};

// ç¯„ä¾‹ï¼š50,000 æŒæœ‰è€… = 5,000ms (5ç§’) æ¸²æŸ“æ™‚é–“
```

#### ç”¨æˆ¶é«”é©—å½±éŸ¿

```typescript
// ç”¨æˆ¶è¡Œç‚ºåˆ†æ
interface UserBehaviorData {
  totalHolders: number;
  viewedHolders: number;
  viewPercentage: number;
  averageViewTime: number; // ç§’
}

const userBehaviorAnalysis: UserBehaviorData[] = [
  { totalHolders: 1000, viewedHolders: 50, viewPercentage: 5, averageViewTime: 30 },
  { totalHolders: 10000, viewedHolders: 100, viewPercentage: 1, averageViewTime: 45 },
  { totalHolders: 100000, viewedHolders: 200, viewPercentage: 0.2, averageViewTime: 60 },
];

// çµè«–ï¼šç”¨æˆ¶é€šå¸¸åªæŸ¥çœ‹å‰é¢çš„å°‘é‡æ•¸æ“š
```

### ğŸ“Š åˆ†é ç­–ç•¥æ¯”è¼ƒ

#### 1. å®¢æˆ¶ç«¯åˆ†é  (Client-side Pagination)

**å·¥ä½œåŸç†ï¼š**
```typescript
interface ClientSidePagination {
  // ä¸€æ¬¡æ€§ç²å–æ‰€æœ‰æ•¸æ“š
  allData: TokenHolder[];
  
  // å®¢æˆ¶ç«¯è¨ˆç®—åˆ†é 
  currentPage: number;
  itemsPerPage: number;
  
  // è¨ˆç®—ç•¶å‰é æ•¸æ“š
  getCurrentPageData(): TokenHolder[] {
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    return this.allData.slice(startIndex, endIndex);
  }
}
```

**å„ªé»ï¼š**
- âœ… å¯¦ä½œç°¡å–®
- âœ… é é¢åˆ‡æ›é€Ÿåº¦å¿«
- âœ… æ”¯æ´å³æ™‚æœå°‹å’Œæ’åº
- âœ… ç„¡éœ€é¡å¤– API è«‹æ±‚

**ç¼ºé»ï¼š**
- âŒ åˆå§‹è¼‰å…¥æ™‚é–“é•·
- âŒ è¨˜æ†¶é«”æ¶ˆè€—å¤§
- âŒ ä¸é©åˆè¶…å¤§æ•¸æ“šé›†
- âŒ æ•¸æ“šæ›´æ–°éœ€è¦é‡æ–°è¼‰å…¥å…¨éƒ¨

**é©ç”¨å ´æ™¯ï¼š**
- æ•¸æ“šé‡ < 10,000 ç­†
- éœ€è¦é »ç¹æœå°‹å’Œæ’åº
- æ•¸æ“šç›¸å°éœæ…‹

#### 2. ä¼ºæœå™¨ç«¯åˆ†é  (Server-side Pagination)

**å·¥ä½œåŸç†ï¼š**
```typescript
interface ServerSidePagination {
  currentPage: number;
  itemsPerPage: number;
  totalItems: number;
  
  // æ¯æ¬¡è«‹æ±‚ç‰¹å®šé é¢çš„æ•¸æ“š
  async fetchPage(page: number): Promise<{
    data: TokenHolder[];
    totalPages: number;
    currentPage: number;
  }> {
    const response = await fetch(`/api/holders?page=${page}&limit=${this.itemsPerPage}`);
    return response.json();
  }
}
```

**å„ªé»ï¼š**
- âœ… è¨˜æ†¶é«”ä½¿ç”¨æ•ˆç‡é«˜
- âœ… åˆå§‹è¼‰å…¥é€Ÿåº¦å¿«
- âœ… é©åˆè¶…å¤§æ•¸æ“šé›†
- âœ… æ”¯æ´å³æ™‚æ•¸æ“šæ›´æ–°

**ç¼ºé»ï¼š**
- âŒ é é¢åˆ‡æ›éœ€è¦ç¶²è·¯è«‹æ±‚
- âŒ å¯¦ä½œè¤‡é›œåº¦è¼ƒé«˜
- âŒ æœå°‹å’Œæ’åºéœ€è¦å¾Œç«¯æ”¯æ´
- âŒ é›¢ç·šä½¿ç”¨é«”é©—å·®

**é©ç”¨å ´æ™¯ï¼š**
- æ•¸æ“šé‡ > 10,000 ç­†
- æ•¸æ“šç¶“å¸¸è®Šå‹•
- éœ€è¦æ¸›å°‘é »å¯¬ä½¿ç”¨

#### 3. æ··åˆåˆ†é  (Hybrid Pagination)

**å·¥ä½œåŸç†ï¼š**
```typescript
interface HybridPagination {
  // åˆ†æ‰¹è¼‰å…¥æ•¸æ“š
  loadedPages: Map<number, TokenHolder[]>;
  currentPage: number;
  itemsPerPage: number;
  batchSize: number; // æ¯æ¬¡è¼‰å…¥çš„é æ•¸
  
  async getCurrentPageData(): Promise<TokenHolder[]> {
    if (!this.loadedPages.has(this.currentPage)) {
      // è¼‰å…¥ç•¶å‰é åŠé™„è¿‘é é¢
      await this.loadPageBatch(this.currentPage);
    }
    return this.loadedPages.get(this.currentPage) || [];
  }
  
  async loadPageBatch(centerPage: number): Promise<void> {
    const startPage = Math.max(1, centerPage - Math.floor(this.batchSize / 2));
    const endPage = startPage + this.batchSize - 1;
    
    // è¼‰å…¥å¤šé æ•¸æ“š
    for (let page = startPage; page <= endPage; page++) {
      if (!this.loadedPages.has(page)) {
        const data = await this.fetchPage(page);
        this.loadedPages.set(page, data);
      }
    }
  }
}
```

**å„ªé»ï¼š**
- âœ… å¹³è¡¡è¼‰å…¥é€Ÿåº¦å’Œè¨˜æ†¶é«”ä½¿ç”¨
- âœ… é è¼‰å…¥æå‡ç”¨æˆ¶é«”é©—
- âœ… éˆæ´»çš„å¿«å–ç­–ç•¥
- âœ… é©æ‡‰ä¸åŒæ•¸æ“šé‡

**ç¼ºé»ï¼š**
- âŒ å¯¦ä½œè¤‡é›œåº¦æœ€é«˜
- âŒ éœ€è¦ç²¾ç´°çš„å¿«å–ç®¡ç†
- âŒ å¯èƒ½å‡ºç¾æ•¸æ“šä¸ä¸€è‡´

### ğŸ—ï¸ å€å¡Šéˆæ•¸æ“šåˆ†é è¨­è¨ˆ

è€ƒæ…®åˆ°å€å¡Šéˆæ•¸æ“šçš„ç‰¹æ€§ï¼Œæˆ‘å€‘æ¡ç”¨**å®¢æˆ¶ç«¯åˆ†é  + è™›æ“¬æ»¾å‹•**çš„æ–¹æ¡ˆï¼š

#### æ•¸æ“šç‰¹æ€§åˆ†æ

```typescript
interface BlockchainDataCharacteristics {
  // æ•¸æ“šç›¸å°éœæ…‹ï¼ˆé™¤éæœ‰æ–°äº¤æ˜“ï¼‰
  isStatic: boolean;
  
  // æ•¸æ“šé‡é€šå¸¸å¯æ§ï¼ˆå¤§éƒ¨åˆ†ä»£å¹£ < 50,000 æŒæœ‰è€…ï¼‰
  typicalSize: number;
  
  // ç”¨æˆ¶ä¸»è¦é—œæ³¨å‰æ’æ•¸æ“š
  userFocusOnTop: boolean;
  
  // API è«‹æ±‚æˆæœ¬è¼ƒé«˜ï¼ˆéœ€è¦éæ­·å€å¡Šéˆï¼‰
  apiCostHigh: boolean;
}

const blockchainDataProfile: BlockchainDataCharacteristics = {
  isStatic: true,
  typicalSize: 10000,
  userFocusOnTop: true,
  apiCostHigh: true,
};
```

#### æˆ‘å€‘çš„åˆ†é æ–¹æ¡ˆ

```typescript
interface OptimizedPaginationStrategy {
  // ç¬¬ä¸€éšæ®µï¼šè¼‰å…¥å‰ 1000 åï¼ˆæ»¿è¶³å¤§éƒ¨åˆ†ç”¨æˆ¶éœ€æ±‚ï¼‰
  initialLoad: {
    count: 1000;
    showPagination: false;
    showLoadMore: true;
  };
  
  // ç¬¬äºŒéšæ®µï¼šæŒ‰éœ€è¼‰å…¥æ›´å¤šæ•¸æ“š
  onDemandLoad: {
    batchSize: 1000;
    maxTotal: 10000; // é™åˆ¶æœ€å¤§è¼‰å…¥é‡
    showPagination: true;
  };
  
  // ç¬¬ä¸‰éšæ®µï¼šè™›æ“¬æ»¾å‹•è™•ç†è¶…å¤§æ•¸æ“š
  virtualScrolling: {
    threshold: 10000;
    renderWindowSize: 50; // åªæ¸²æŸ“å¯è¦‹å€åŸŸ
    bufferSize: 10; // ä¸Šä¸‹ç·©è¡å€
  };
}
```

### ğŸ”§ åˆ†é é‚è¼¯å¯¦ä½œ

#### åŸºç¤åˆ†é é¡åˆ¥

```typescript
export class PaginationManager<T> {
  private data: T[] = [];
  private currentPage: number = 1;
  private itemsPerPage: number = 20;
  private totalItems: number = 0;

  constructor(itemsPerPage: number = 20) {
    this.itemsPerPage = itemsPerPage;
  }

  /**
   * è¨­å®šæ•¸æ“š
   */
  setData(data: T[]): void {
    this.data = data;
    this.totalItems = data.length;
    this.currentPage = 1; // é‡ç½®åˆ°ç¬¬ä¸€é 
  }

  /**
   * ç²å–ç•¶å‰é æ•¸æ“š
   */
  getCurrentPageData(): T[] {
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = Math.min(startIndex + this.itemsPerPage, this.totalItems);
    return this.data.slice(startIndex, endIndex);
  }

  /**
   * ç²å–åˆ†é è³‡è¨Š
   */
  getPaginationInfo(): {
    currentPage: number;
    totalPages: number;
    totalItems: number;
    itemsPerPage: number;
    startItem: number;
    endItem: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  } {
    const totalPages = Math.ceil(this.totalItems / this.itemsPerPage);
    const startItem = (this.currentPage - 1) * this.itemsPerPage + 1;
    const endItem = Math.min(this.currentPage * this.itemsPerPage, this.totalItems);

    return {
      currentPage: this.currentPage,
      totalPages,
      totalItems: this.totalItems,
      itemsPerPage: this.itemsPerPage,
      startItem,
      endItem,
      hasNextPage: this.currentPage < totalPages,
      hasPrevPage: this.currentPage > 1,
    };
  }

  /**
   * è·³è½‰åˆ°æŒ‡å®šé é¢
   */
  goToPage(page: number): boolean {
    const totalPages = Math.ceil(this.totalItems / this.itemsPerPage);
    
    if (page < 1 || page > totalPages) {
      return false;
    }

    this.currentPage = page;
    return true;
  }

  /**
   * ä¸‹ä¸€é 
   */
  nextPage(): boolean {
    return this.goToPage(this.currentPage + 1);
  }

  /**
   * ä¸Šä¸€é 
   */
  prevPage(): boolean {
    return this.goToPage(this.currentPage - 1);
  }

  /**
   * è¨­å®šæ¯é é …ç›®æ•¸
   */
  setItemsPerPage(itemsPerPage: number): void {
    if (itemsPerPage < 1) return;
    
    // è¨ˆç®—ç•¶å‰é …ç›®åœ¨æ–°åˆ†é ä¸­çš„ä½ç½®
    const currentFirstItem = (this.currentPage - 1) * this.itemsPerPage + 1;
    
    this.itemsPerPage = itemsPerPage;
    
    // èª¿æ•´ç•¶å‰é é¢ä»¥ä¿æŒå¤§è‡´ç›¸åŒçš„ä½ç½®
    const newPage = Math.ceil(currentFirstItem / itemsPerPage);
    this.goToPage(newPage);
  }

  /**
   * ç²å–é é¢ç¯„åœï¼ˆç”¨æ–¼åˆ†é å°èˆªï¼‰
   */
  getPageRange(maxVisible: number = 5): number[] {
    const totalPages = Math.ceil(this.totalItems / this.itemsPerPage);
    
    if (totalPages <= maxVisible) {
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    const half = Math.floor(maxVisible / 2);
    let start = Math.max(1, this.currentPage - half);
    let end = Math.min(totalPages, start + maxVisible - 1);

    // èª¿æ•´èµ·å§‹ä½ç½®ä»¥ç¢ºä¿é¡¯ç¤ºè¶³å¤ çš„é é¢
    if (end - start + 1 < maxVisible) {
      start = Math.max(1, end - maxVisible + 1);
    }

    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
  }

  /**
   * æœå°‹åŠŸèƒ½
   */
  search(query: string, searchFn: (item: T, query: string) => boolean): T[] {
    if (!query.trim()) {
      return this.data;
    }

    return this.data.filter(item => searchFn(item, query.toLowerCase()));
  }

  /**
   * æ’åºåŠŸèƒ½
   */
  sort(compareFn: (a: T, b: T) => number): void {
    this.data.sort(compareFn);
  }
}
```

#### é‡å°ä»£å¹£æŒæœ‰è€…çš„å°ˆç”¨åˆ†é é¡åˆ¥

```typescript
export class TokenHoldersPagination extends PaginationManager<TokenHolder> {
  private originalData: TokenHolder[] = [];
  private filteredData: TokenHolder[] = [];
  private searchQuery: string = '';
  private sortField: keyof TokenHolder = 'balanceNumber';
  private sortDirection: 'asc' | 'desc' = 'desc';

  /**
   * è¨­å®šæŒæœ‰è€…æ•¸æ“š
   */
  setHolders(holders: TokenHolder[]): void {
    this.originalData = [...holders];
    this.filteredData = [...holders];
    this.applyFiltersAndSort();
  }

  /**
   * æœå°‹æŒæœ‰è€…
   */
  searchHolders(query: string): void {
    this.searchQuery = query.toLowerCase();
    this.applyFiltersAndSort();
  }

  /**
   * æ’åºæŒæœ‰è€…
   */
  sortHolders(field: keyof TokenHolder, direction: 'asc' | 'desc' = 'desc'): void {
    this.sortField = field;
    this.sortDirection = direction;
    this.applyFiltersAndSort();
  }

  /**
   * æŒ‰é¤˜é¡ç¯„åœéæ¿¾
   */
  filterByBalance(minBalance: number, maxBalance: number = Infinity): void {
    this.filteredData = this.originalData.filter(holder => 
      holder.balanceNumber >= minBalance && holder.balanceNumber <= maxBalance
    );
    this.applyFiltersAndSort();
  }

  /**
   * ç²å–å‰ N åæŒæœ‰è€…
   */
  getTopHolders(count: number): TokenHolder[] {
    return this.filteredData
      .sort((a, b) => b.balanceNumber - a.balanceNumber)
      .slice(0, count);
  }

  /**
   * æŸ¥æ‰¾ç‰¹å®šåœ°å€
   */
  findHolder(address: string): {
    holder: TokenHolder | null;
    page: number;
    indexInPage: number;
  } {
    const normalizedAddress = address.toLowerCase();
    const index = this.filteredData.findIndex(
      holder => holder.address.toLowerCase() === normalizedAddress
    );

    if (index === -1) {
      return { holder: null, page: 0, indexInPage: 0 };
    }

    const holder = this.filteredData[index];
    const page = Math.ceil((index + 1) / this.itemsPerPage);
    const indexInPage = index % this.itemsPerPage;

    return { holder, page, indexInPage };
  }

  /**
   * æ‡‰ç”¨éæ¿¾å’Œæ’åº
   */
  private applyFiltersAndSort(): void {
    let data = [...this.originalData];

    // æ‡‰ç”¨æœå°‹éæ¿¾
    if (this.searchQuery) {
      data = data.filter(holder =>
        holder.address.toLowerCase().includes(this.searchQuery) ||
        holder.balanceFormatted.toLowerCase().includes(this.searchQuery)
      );
    }

    // æ‡‰ç”¨æ’åº
    data.sort((a, b) => {
      const aValue = a[this.sortField];
      const bValue = b[this.sortField];
      
      let comparison = 0;
      if (typeof aValue === 'number' && typeof bValue === 'number') {
        comparison = aValue - bValue;
      } else {
        comparison = String(aValue).localeCompare(String(bValue));
      }

      return this.sortDirection === 'desc' ? -comparison : comparison;
    });

    this.filteredData = data;
    this.setData(this.filteredData);
  }

  /**
   * ç²å–çµ±è¨ˆè³‡è¨Š
   */
  getStats(): {
    totalHolders: number;
    filteredHolders: number;
    currentPageHolders: number;
    averageBalance: number;
    totalBalance: number;
  } {
    const currentPageData = this.getCurrentPageData();
    const totalBalance = this.filteredData.reduce((sum, holder) => sum + holder.balanceNumber, 0);
    const averageBalance = this.filteredData.length > 0 ? totalBalance / this.filteredData.length : 0;

    return {
      totalHolders: this.originalData.length,
      filteredHolders: this.filteredData.length,
      currentPageHolders: currentPageData.length,
      averageBalance,
      totalBalance,
    };
  }

  /**
   * å°å‡ºç•¶å‰é é¢æ•¸æ“š
   */
  exportCurrentPage(): string {
    const data = this.getCurrentPageData();
    const headers = ['Rank', 'Address', 'Balance', 'Percentage'];
    
    const csvContent = [
      headers.join(','),
      ...data.map(holder => [
        holder.rank || '',
        holder.address,
        holder.balanceFormatted,
        `${holder.percentage.toFixed(4)}%`
      ].join(','))
    ].join('\n');

    return csvContent;
  }
}
```

### ğŸ“Š æ•ˆèƒ½å„ªåŒ–ç­–ç•¥

#### 1. è™›æ“¬æ»¾å‹•å¯¦ä½œ

```typescript
interface VirtualScrollOptions {
  itemHeight: number;
  containerHeight: number;
  bufferSize: number;
}

class VirtualScrollManager<T> {
  private options: VirtualScrollOptions;
  private data: T[] = [];
  private scrollTop: number = 0;

  constructor(options: VirtualScrollOptions) {
    this.options = options;
  }

  /**
   * è¨ˆç®—å¯è¦‹ç¯„åœ
   */
  getVisibleRange(): { start: number; end: number; offset: number } {
    const { itemHeight, containerHeight, bufferSize } = this.options;
    
    const start = Math.max(0, Math.floor(this.scrollTop / itemHeight) - bufferSize);
    const visibleCount = Math.ceil(containerHeight / itemHeight);
    const end = Math.min(this.data.length, start + visibleCount + bufferSize * 2);
    const offset = start * itemHeight;

    return { start, end, offset };
  }

  /**
   * ç²å–å¯è¦‹é …ç›®
   */
  getVisibleItems(): { items: T[]; offset: number; totalHeight: number } {
    const { start, end, offset } = this.getVisibleRange();
    const items = this.data.slice(start, end);
    const totalHeight = this.data.length * this.options.itemHeight;

    return { items, offset, totalHeight };
  }

  /**
   * æ›´æ–°æ»¾å‹•ä½ç½®
   */
  updateScrollTop(scrollTop: number): void {
    this.scrollTop = scrollTop;
  }

  /**
   * è¨­å®šæ•¸æ“š
   */
  setData(data: T[]): void {
    this.data = data;
    this.scrollTop = 0;
  }
}
```

#### 2. è¨˜æ†¶é«”ç®¡ç†

```typescript
class MemoryManager {
  private static readonly MAX_CACHE_SIZE = 50 * 1024 * 1024; // 50MB
  private static cacheSize = 0;
  private static cache = new Map<string, any>();

  static set(key: string, value: any): void {
    const size = this.estimateSize(value);
    
    // å¦‚æœæ–°æ•¸æ“šæœƒè¶…å‡ºé™åˆ¶ï¼Œæ¸…ç†èˆŠæ•¸æ“š
    while (this.cacheSize + size > this.MAX_CACHE_SIZE && this.cache.size > 0) {
      const firstKey = this.cache.keys().next().value;
      const firstValue = this.cache.get(firstKey);
      this.cache.delete(firstKey);
      this.cacheSize -= this.estimateSize(firstValue);
    }

    this.cache.set(key, value);
    this.cacheSize += size;
  }

  static get(key: string): any {
    return this.cache.get(key);
  }

  static clear(): void {
    this.cache.clear();
    this.cacheSize = 0;
  }

  private static estimateSize(obj: any): number {
    return JSON.stringify(obj).length * 2; // ç²—ç•¥ä¼°ç®—
  }
}
```

### ğŸ§ª æ•ˆèƒ½æ¸¬è©¦

å»ºç«‹æ•ˆèƒ½æ¸¬è©¦å·¥å…·ï¼š

```typescript
class PaginationPerformanceTest {
  /**
   * æ¸¬è©¦ä¸åŒæ•¸æ“šé‡çš„æ¸²æŸ“æ•ˆèƒ½
   */
  static async testRenderPerformance(dataSizes: number[]): Promise<void> {
    for (const size of dataSizes) {
      const testData = this.generateTestData(size);
      
      const startTime = performance.now();
      
      // æ¨¡æ“¬æ¸²æŸ“éç¨‹
      const pagination = new TokenHoldersPagination(20);
      pagination.setHolders(testData);
      
      for (let page = 1; page <= Math.min(10, pagination.getPaginationInfo().totalPages); page++) {
        pagination.goToPage(page);
        const pageData = pagination.getCurrentPageData();
        // æ¨¡æ“¬ DOM æ“ä½œ
        await new Promise(resolve => setTimeout(resolve, 1));
      }
      
      const endTime = performance.now();
      
      console.log(`æ•¸æ“šé‡: ${size}, æ¸²æŸ“æ™‚é–“: ${(endTime - startTime).toFixed(2)}ms`);
    }
  }

  /**
   * æ¸¬è©¦æœå°‹æ•ˆèƒ½
   */
  static testSearchPerformance(dataSize: number, searchQueries: string[]): void {
    const testData = this.generateTestData(dataSize);
    const pagination = new TokenHoldersPagination(20);
    pagination.setHolders(testData);

    searchQueries.forEach(query => {
      const startTime = performance.now();
      pagination.searchHolders(query);
      const endTime = performance.now();
      
      console.log(`æœå°‹ "${query}": ${(endTime - startTime).toFixed(2)}ms`);
    });
  }

  /**
   * ç”Ÿæˆæ¸¬è©¦æ•¸æ“š
   */
  private static generateTestData(count: number): TokenHolder[] {
    return Array.from({ length: count }, (_, index) => ({
      address: `0x${Math.random().toString(16).substr(2, 40)}`,
      balance: `0x${Math.random().toString(16).substr(2, 16)}`,
      balanceFormatted: (Math.random() * 1000000).toFixed(2),
      balanceNumber: Math.random() * 1000000,
      percentage: Math.random() * 100,
      rank: index + 1,
    }));
  }
}

// åŸ·è¡Œæ•ˆèƒ½æ¸¬è©¦
// PaginationPerformanceTest.testRenderPerformance([100, 1000, 10000, 50000]);
```

### âœ… å°çµ

åœ¨é€™ä¸€èª²ä¸­ï¼Œæˆ‘å€‘æ·±å…¥åˆ†æäº†åˆ†é é‚è¼¯çš„è¨­è¨ˆåŸç†ï¼š

âœ… **åˆ†é é‡è¦æ€§ç†è§£**
- æ•ˆèƒ½è€ƒé‡å’Œç”¨æˆ¶é«”é©—å½±éŸ¿
- ä¸åŒæ•¸æ“šé‡çš„è™•ç†ç­–ç•¥
- è¨˜æ†¶é«”å’Œæ¸²æŸ“æ•ˆèƒ½å„ªåŒ–

âœ… **åˆ†é ç­–ç•¥æ¯”è¼ƒ**
- å®¢æˆ¶ç«¯åˆ†é  vs ä¼ºæœå™¨ç«¯åˆ†é 
- æ··åˆåˆ†é æ–¹æ¡ˆè¨­è¨ˆ
- å€å¡Šéˆæ•¸æ“šçš„ç‰¹æ®Šè€ƒé‡

âœ… **å®Œæ•´åˆ†é é¡åˆ¥å¯¦ä½œ**
- åŸºç¤åˆ†é ç®¡ç†å™¨
- ä»£å¹£æŒæœ‰è€…å°ˆç”¨åˆ†é 
- æœå°‹ã€æ’åºã€éæ¿¾åŠŸèƒ½

âœ… **æ•ˆèƒ½å„ªåŒ–æŠ€è¡“**
- è™›æ“¬æ»¾å‹•å¯¦ä½œ
- è¨˜æ†¶é«”ç®¡ç†ç­–ç•¥
- æ•ˆèƒ½æ¸¬è©¦å·¥å…·

åœ¨ä¸‹ä¸€èª²ä¸­ï¼Œæˆ‘å€‘å°‡æŠŠé€™äº›åˆ†é é‚è¼¯æ•´åˆåˆ°æˆ‘å€‘çš„ `useTokenHolders` Hook ä¸­ï¼Œå¯¦ç¾çœŸæ­£å¯ç”¨çš„åˆ†é åŠŸèƒ½ï¼

---

**æº–å‚™å¥½å°‡åˆ†é é‚è¼¯æ•´åˆåˆ°æˆ‘å€‘çš„ Hook ä¸­äº†å—ï¼Ÿ** ğŸ”§
