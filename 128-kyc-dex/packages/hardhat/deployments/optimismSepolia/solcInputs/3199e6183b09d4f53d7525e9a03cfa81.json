{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/DEX.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title DEX Template\r\n * @author stevepham.eth and m00npapi.eth\r\n * @notice Empty DEX.sol that just outlines what features could be part of the challenge (up to you!)\r\n * @dev We want to create an automatic market where our contract will hold reserves of both ETH and 🎈 Balloons. These reserves will provide liquidity that allows anyone to swap between the assets.\r\n * NOTE: functions outlined here are what work with the front end of this challenge. Also return variable names need to be specified exactly may be referenced (It may be helpful to cross reference with front-end code function calls).\r\n */\r\ninterface IKYCRegistry {\r\n    function isVerified(address user) external view returns (bool);\r\n}\r\n\r\ncontract DEX is Ownable {\r\n    /* ========== GLOBAL VARIABLES ========== */\r\n    IERC20 token; //instantiates the imported contract\r\n    IKYCRegistry public kycRegistry;\r\n\r\n    uint256 public totalLiquidity;\r\n    mapping (address => uint256) public liquidity;\r\n\r\n    bool public isBlocked = true;\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n     * @notice Emitted when ethToToken() swap transacted\r\n     */\r\n    event EthToTokenSwap(address swapper, uint256 tokenOutput, uint256 ethInput);\r\n\r\n    /**\r\n     * @notice Emitted when tokenToEth() swap transacted\r\n     */\r\n    event TokenToEthSwap(address swapper, uint256 tokensInput, uint256 ethOutput);\r\n\r\n    /**\r\n     * @notice Emitted when liquidity provided to DEX and mints LPTs.\r\n     */\r\n    event LiquidityProvided(address liquidityProvider, uint256 liquidityMinted, uint256 ethInput, uint256 tokensInput);\r\n\r\n    /**\r\n     * @notice Emitted when liquidity removed from DEX and decreases LPT count within DEX.\r\n     */\r\n    event LiquidityRemoved(address liquidityRemover, uint256 liquidityWithdrawn, uint256 tokensOutput, uint256 ethOutput);\r\n\r\n    /* ========== MODIFIERS ========== */\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, 'DEX: LOCKED');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    modifier notBlocked() {\r\n        require(!isBlocked, \"DEX: DEX is blocked\");\r\n        _;\r\n    }\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n    constructor(address tokenAddr, address kycRegistryAddr) Ownable(msg.sender) {\r\n        token = IERC20(tokenAddr); //specifies the token address that will hook into the interface and be used through the variable 'token'\r\n        kycRegistry = IKYCRegistry(kycRegistryAddr);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice initializes amount of tokens that will be transferred to the DEX itself from the erc20 contract mintee (and only them based on how Balloons.sol is written). Loads contract up with both ETH and Balloons.\r\n     * @param tokens amount to be transferred to DEX\r\n     * @return totalLiquidity is the number of LPTs minting as a result of deposits made to DEX contract\r\n     * NOTE: since ratio is 1:1, this is fine to initialize the totalLiquidity (wrt to balloons) as equal to eth balance of contract.\r\n     */\r\n    function init(uint256 tokens) public payable onlyOwner returns (uint256) {\r\n        require(totalLiquidity == 0, \"DEX already initialized\");\r\n        require(address(this).balance == msg.value, \"DEX: initial ETH balance mismatch\");\r\n        totalLiquidity = msg.value;\r\n        liquidity[msg.sender] = msg.value;\r\n        require(token.transferFrom(msg.sender, address(this), tokens), \"DEX: init - transfer did not transact\");\r\n        return totalLiquidity;  \r\n    }\r\n\r\n    /**\r\n     * @notice returns yOutput, or yDelta for xInput (or xDelta)\r\n     * @dev Follow along with the [original tutorial](https://medium.com/@austin_48503/%EF%B8%8F-minimum-viable-exchange-d84f30bd0c90) Price section for an understanding of the DEX's pricing model and for a price function to add to your contract. You may need to update the Solidity syntax (e.g. use + instead of .add, * instead of .mul, etc). Deploy when you are done.\r\n     */\r\n    function price(uint256 xInput, uint256 xReserves, uint256 yReserves) public pure returns (uint256 yOutput) {\r\n        require(xInput < xReserves, \"DEX: INSUFFICIENT_LIQUIDITY\");\r\n        uint fee = (xInput * 3) / 1000;  // tax fee 0.03% from xInput\r\n        uint xInputWithFee  = xInput - fee;  \r\n        // k* 公式:  xReserves * yReserves == k == xReserves' * yReserves'\r\n        // (xReserves + xInput) * (yReserves - yOutput) == k\r\n        // xReserves * yReserves - xReserves * yOutput + xInput * yReserves - xInput * yOutput == k\r\n        // k - xReserves * yOutput + xInput * yReserves - xInput * yOutput == k\r\n        // xInput * yReserves == xReserves * yOutput + xInput * yOutput\r\n        // xInput * yReserves == (xReserves + xInput) * yOutput\r\n        // (xInput * yReserves) / (xReserves + xInput) == yOutput\r\n        // (xInputWithFee * yReserves) / (xReserves + xInputWithFee) == yOutput\r\n        yOutput = (xInputWithFee * yReserves) / (xReserves + xInputWithFee);\r\n        return yOutput;\r\n    }\r\n\r\n    /**\r\n     * @notice returns liquidity for a user.\r\n     * NOTE: this is not needed typically due to the `liquidity()` mapping variable being public and having a getter as a result. This is left though as it is used within the front end code (App.jsx).\r\n     * NOTE: if you are using a mapping liquidity, then you can use `return liquidity[lp]` to get the liquidity for a user.\r\n     * NOTE: if you will be submitting the challenge make sure to implement this function as it is used in the tests.\r\n     */\r\n    function getLiquidity(address lp) public view returns (uint256) {\r\n        return liquidity[lp];\r\n    }\r\n\r\n    /**\r\n     * @notice sends Ether to DEX in exchange for $BAL\r\n     */\r\n    function ethToToken(uint256 minTokenOutput) public payable lock notBlocked returns (uint256 tokenOutput) {\r\n        require(kycRegistry.isVerified(msg.sender), \"DEX: ethToToken - user not verified\");\r\n        require(msg.value > 0, \"cannot swap 0 ETH\");\r\n        uint256 ethInput = msg.value;\r\n        uint256 ethReserves = address(this).balance - msg.value;\r\n        uint256 tokenReserves = token.balanceOf(address(this));\r\n        tokenOutput = price(ethInput, ethReserves, tokenReserves);\r\n\r\n        require(tokenOutput >= minTokenOutput, \"DEX: ethToToken - token output below minimum\");\r\n        require(token.transfer(msg.sender, tokenOutput), \"DEX: ethToToken - transfer failed\");\r\n        \r\n        emit EthToTokenSwap(msg.sender, tokenOutput, ethInput);\r\n        return tokenOutput;\r\n    }\r\n\r\n    /**\r\n     * @notice sends $BAL tokens to DEX in exchange for Ether\r\n     */\r\n    function tokenToEth(uint256 tokenInput, uint256 minEthOutput) public lock notBlocked returns (uint256 ethOutput) {\r\n        require(kycRegistry.isVerified(msg.sender), \"DEX: tokenToEth - user not verified\");\r\n        require(tokenInput > 0, \"cannot swap 0 tokens\");\r\n        require(token.balanceOf(msg.sender) >= tokenInput, \"insufficient token balance\");\r\n        require(token.allowance(msg.sender, address(this)) >= tokenInput, \"insufficient allowance\");\r\n        uint256 tokenReserves = token.balanceOf(address(this));\r\n        uint256 ethReserves = address(this).balance;\r\n        ethOutput = price(tokenInput, tokenReserves, ethReserves);\r\n\r\n        require(ethOutput >= minEthOutput, \"DEX: tokenToEth - eth output below minimum\");\r\n        require(token.transferFrom(msg.sender, address(this), tokenInput), \"DEX: tokenToEth - transfer failed\");\r\n\r\n        (bool sent, ) = msg.sender.call{ value: ethOutput }(\"\");\r\n        require(sent, \"tokenToEth: revert in transferring eth to you!\");\r\n        emit TokenToEthSwap(msg.sender, tokenInput, ethOutput);\r\n        return ethOutput;\r\n    }\r\n\r\n    /**\r\n     * @notice allows deposits of $BAL and $ETH to liquidity pool\r\n     * NOTE: parameter is the msg.value sent with this function call. That amount is used to determine the amount of $BAL needed as well and taken from the depositor.\r\n     * NOTE: user has to make sure to give DEX approval to spend their tokens on their behalf by calling approve function prior to this function call.\r\n     * NOTE: Equal parts of both assets will be removed from the user's wallet with respect to the price outlined by the AMM.\r\n     */\r\n    function deposit() public payable onlyOwner lock returns (uint256 tokensDeposited) {\r\n        require(kycRegistry.isVerified(msg.sender), \"DEX: deposit - owner not verified\");\r\n        require(msg.value > 0, \"cannot deposit 0 ETH\");\r\n        uint256 ethReserves = address(this).balance - msg.value;\r\n        uint256 tokenReserves = token.balanceOf(address(this));\r\n        uint256 tokenDeposit;\r\n        tokenDeposit = (msg.value * tokenReserves / ethReserves) + 1;\r\n        // 💡 Discussion on adding 1 wei at end of calculation    ^\r\n        // -> https://t.me/c/1655715571/106\r\n        // 防止逼近零值存款、防止捨入誤差、維持流動性平衡，確保池子代幣略多於嚴格的數學比例要求，略為正向偏差的保守設計\r\n        require(token.balanceOf(msg.sender) >= tokenDeposit, \"insufficient token balance\");\r\n        require(token.allowance(msg.sender, address(this)) >= tokenDeposit, \"insufficient allowance\");\r\n\r\n        uint256 liquidityMinted = msg.value * totalLiquidity / ethReserves;\r\n        liquidity[msg.sender] += liquidityMinted;\r\n        totalLiquidity += liquidityMinted;\r\n\r\n        require(token.transferFrom(msg.sender, address(this), tokenDeposit), \"DEX: deposit - transfer failed\");\r\n        emit LiquidityProvided(msg.sender, liquidityMinted, msg.value, tokenDeposit);\r\n        return tokenDeposit;\r\n    }\r\n\r\n    /**\r\n     * @notice allows withdrawal of $BAL and $ETH from liquidity pool\r\n     * NOTE: with this current code, the msg caller could end up getting very little back if the liquidity is super low in the pool. I guess they could see that with the UI.\r\n     */\r\n    function withdraw(uint256 amount) public onlyOwner lock returns (uint256 ethAmount, uint256 tokenAmount) {\r\n        require(kycRegistry.isVerified(msg.sender), \"DEX: deposit - owner not verified\");\r\n        require(amount > 0, \"cannot withdraw 0 liquidity\");\r\n        require(liquidity[msg.sender] >= amount, \"msg.sender insufficient liquidity\");\r\n\r\n        ethAmount = amount * address(this).balance / totalLiquidity;\r\n        tokenAmount = amount * token.balanceOf(address(this)) / totalLiquidity;\r\n\r\n        liquidity[msg.sender] -= amount;\r\n        totalLiquidity -= amount;\r\n\r\n        (bool sent, ) = payable(msg.sender).call{ value: ethAmount }(\"\");\r\n        require(sent, \"withdraw: revert in transferring eth to you!\");\r\n        require(token.transfer(msg.sender, tokenAmount), \"withdraw: revert in transferring tokens to you!\");\r\n        \r\n        emit LiquidityRemoved(msg.sender, amount, tokenAmount, ethAmount);\r\n        return (ethAmount, tokenAmount);\r\n    }\r\n\r\n    function setBlocked(bool _isBlocked) public onlyOwner {\r\n        isBlocked = _isBlocked;\r\n    }\r\n}\r\n"
    },
    "contracts/HEX.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.20;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n/**\r\n@title IKYCRegistry Interface\r\n@dev Defines the interface for the KYC verification contract.\r\n*/\r\ninterface IKYCRegistry {\r\n    function isVerified(address user) external view returns (bool);\r\n}\r\n\r\n/**\r\n@title DEX (Refactored)\r\n@author stevepham.eth, m00npapi.eth (Original), Refactored by AI\r\n@notice A more secure and robust implementation of the DEX contract.\r\n@dev This contract has been refactored to address potential security vulnerabilities including\r\nreentrancy, centralization risks, and handling of non-standard ERC20 tokens.\r\nUse code with caution.\r\nIt uses OpenZeppelin's ReentrancyGuard for enhanced security.\r\nUse code with caution.\r\n*/\r\n\r\ncontract HEX is Ownable, ReentrancyGuard {\r\n    /* ========== STATE VARIABLES ========== */\r\n    IERC20 public immutable token;\r\n    IKYCRegistry public immutable kycRegistry;\r\n\r\n    uint256 public totalLiquidity;\r\n    mapping(address => uint256) public liquidity;\r\n\r\n    bool public isTradingBlocked = true;\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event EthToTokenSwap(address indexed swapper, uint256 tokenOutput, uint256 ethInput);\r\n    event TokenToEthSwap(address indexed swapper, uint256 tokensInput, uint256 ethOutput);\r\n    event LiquidityProvided(address indexed provider, uint256 liquidityMinted, uint256 ethInput, uint256 tokensInput);\r\n    event LiquidityRemoved(\r\n        address indexed remover,\r\n        uint256 liquidityWithdrawn,\r\n        uint256 tokensOutput,\r\n        uint256 ethOutput\r\n    );\r\n    event SettlementExecuted(address indexed beneficiary, uint256 ethWithdrawn, uint256 tokenWithdrawn);\r\n    event TradingBlockStatusChanged(address indexed owner, bool isBlocked);\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier tradingAllowed() {\r\n        require(!isTradingBlocked, \"DEX: Trading is currently blocked\");\r\n        _;\r\n    }\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n    /**\r\n     * @dev Sets the addresses for the token and KYC registry.\r\n     *      IMPORTANT: For production, the initial owner should be a Multi-Sig wallet to mitigate single-point-of-failure risk.\r\n     */\r\n    constructor(address tokenAddr, address kycRegistryAddr) Ownable(msg.sender) {\r\n        require(tokenAddr != address(0) && kycRegistryAddr != address(0), \"DEX: Zero address provided\");\r\n        token = IERC20(tokenAddr);\r\n        kycRegistry = IKYCRegistry(kycRegistryAddr);\r\n    }\r\n\r\n    /* ========== INITIALIZATION ========== */\r\n\r\n    /**\r\n     * @notice Initializes the DEX with the first batch of liquidity. Can only be called once by the owner.\r\n     * @param tokens The initial amount of tokens to seed the pool with.\r\n     * @return The initial total liquidity minted.\r\n     */\r\n    function init(uint256 tokens) public payable onlyOwner returns (uint256) {\r\n        require(totalLiquidity == 0, \"DEX: Already initialized\");\r\n        require(msg.value > 0 && tokens > 0, \"DEX: Initial liquidity cannot be zero\");\r\n\r\n        totalLiquidity = msg.value;\r\n        liquidity[msg.sender] = totalLiquidity;\r\n\r\n        require(token.transferFrom(msg.sender, address(this), tokens), \"DEX: Initial token transfer failed\");\r\n        emit LiquidityProvided(msg.sender, totalLiquidity, msg.value, tokens);\r\n        return totalLiquidity;\r\n    }\r\n\r\n    /* ========== READ-ONLY FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Calculates the output amount for a given input amount and reserve state.\r\n     * @dev This is a pure function for price calculation based on the constant product formula.\r\n     *      It includes a 0.3% trading fee.\r\n     *      WARNING: This should NOT be used as a price oracle due to its susceptibility to manipulation.\r\n     */\r\n    function getAmountOut(\r\n        uint256 inputAmount,\r\n        uint256 inputReserve,\r\n        uint256 outputReserve\r\n    ) public pure returns (uint256) {\r\n        require(inputAmount > 0, \"DEX: Input amount must be positive\");\r\n        require(inputReserve > 0 && outputReserve > 0, \"DEX: Reserves must be positive\");\r\n\r\n        uint256 fee = (inputAmount * 3) / 1000; // tax fee 0.3% from xInput\r\n        uint256 inputAmountWithFee = inputAmount - fee;\r\n\r\n        uint256 numerator = inputAmountWithFee * outputReserve;\r\n        uint256 denominator = inputReserve + inputAmountWithFee;\r\n\r\n        return numerator / denominator;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of liquidity tokens for a given address.\r\n     */\r\n    function getLiquidity(address lp) public view returns (uint256) {\r\n        return liquidity[lp];\r\n    }\r\n\r\n    /* ========== SWAP FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Swaps ETH for Tokens. Requires KYC verification.\r\n     * @param minTokensOut The minimum amount of tokens the user is willing to accept (slippage protection).\r\n     */\r\n    function ethToToken(uint256 minTokensOut) public payable nonReentrant tradingAllowed returns (uint256 tokenOutput) {\r\n        require(kycRegistry.isVerified(msg.sender), \"DEX: User not KYC verified\");\r\n        require(msg.value > 0, \"DEX: Cannot swap 0 ETH\");\r\n\r\n        uint256 ethReserves = address(this).balance - msg.value;\r\n        uint256 tokenReserves = token.balanceOf(address(this));\r\n\r\n        tokenOutput = getAmountOut(msg.value, ethReserves, tokenReserves);\r\n        require(tokenOutput >= minTokensOut, \"DEX: Slippage tolerance not met\");\r\n\r\n        require(token.transfer(msg.sender, tokenOutput), \"DEX: Token transfer failed\");\r\n\r\n        emit EthToTokenSwap(msg.sender, tokenOutput, msg.value);\r\n        return tokenOutput;\r\n    }\r\n\r\n    /**\r\n     * @notice Swaps Tokens for ETH. Requires KYC verification.\r\n     * @dev This function is robust against fee-on-transfer tokens by checking the balance change.\r\n     * @param tokensIn The amount of tokens the user wants to swap.\r\n     * @param minEthOut The minimum amount of ETH the user is willing to accept (slippage protection).\r\n     */\r\n    function tokenToEth(\r\n        uint256 tokensIn,\r\n        uint256 minEthOut\r\n    ) public nonReentrant tradingAllowed returns (uint256 ethOutput) {\r\n        require(kycRegistry.isVerified(msg.sender), \"DEX: User not KYC verified\");\r\n        require(tokensIn > 0, \"DEX: Cannot swap 0 tokens\");\r\n\r\n        uint256 tokenReserves = token.balanceOf(address(this));\r\n        uint256 ethReserves = address(this).balance;\r\n\r\n        // Securely transfer tokens first and calculate based on actual amount received\r\n        uint256 balanceBefore = token.balanceOf(address(this));\r\n        require(token.transferFrom(msg.sender, address(this), tokensIn), \"DEX: Token transferFrom failed\");\r\n        uint256 actualTokensIn = token.balanceOf(address(this)) - balanceBefore;\r\n\r\n        ethOutput = getAmountOut(actualTokensIn, tokenReserves, ethReserves);\r\n        require(ethOutput >= minEthOut, \"DEX: Slippage tolerance not met\");\r\n\r\n        (bool sent, ) = msg.sender.call{ value: ethOutput }(\"\");\r\n        require(sent, \"DEX: ETH transfer failed\");\r\n\r\n        emit TokenToEthSwap(msg.sender, actualTokensIn, ethOutput);\r\n        return ethOutput;\r\n    }\r\n\r\n    /* ========== LIQUIDITY FUNCTIONS (OWNER ONLY) ========== */\r\n\r\n    /**\r\n     * @notice Adds liquidity to the pool. Can only be called by the owner.\r\n     * @dev The amount of tokens to deposit is calculated based on the current pool ratio.\r\n     *      Owner must approve the DEX to spend their tokens beforehand.\r\n     */\r\n    function deposit() public payable onlyOwner nonReentrant returns (uint256 tokensDeposited) {\r\n        require(msg.value > 0, \"DEX: Cannot deposit 0 ETH\");\r\n\r\n        uint256 ethReserves = address(this).balance - msg.value;\r\n        uint256 tokenReserves = token.balanceOf(address(this));\r\n\r\n        // Calculate token amount based on current ratio, add 1 for rounding\r\n        uint256 tokenAmount = ((msg.value * tokenReserves) / ethReserves) + 1;\r\n        uint256 liquidityMinted = (msg.value * totalLiquidity) / ethReserves;\r\n\r\n        liquidity[msg.sender] += liquidityMinted;\r\n        totalLiquidity += liquidityMinted;\r\n\r\n        require(token.transferFrom(msg.sender, address(this), tokenAmount), \"DEX: Token deposit failed\");\r\n\r\n        emit LiquidityProvided(msg.sender, liquidityMinted, msg.value, tokenAmount);\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws liquidity from the pool. Can only be called by the owner.\r\n     * @param amountLPT The amount of liquidity pool tokens to burn.\r\n     */\r\n    function withdraw(\r\n        uint256 amountLPT\r\n    ) public onlyOwner nonReentrant returns (uint256 ethAmount, uint256 tokenAmount) {\r\n        require(amountLPT > 0, \"DEX: Cannot withdraw 0 liquidity\");\r\n        require(liquidity[msg.sender] >= amountLPT, \"DEX: Insufficient liquidity tokens\");\r\n\r\n        uint256 ethReserves = address(this).balance;\r\n        uint256 tokenReserves = token.balanceOf(address(this));\r\n\r\n        ethAmount = (amountLPT * ethReserves) / totalLiquidity;\r\n        tokenAmount = (amountLPT * tokenReserves) / totalLiquidity;\r\n\r\n        liquidity[msg.sender] -= amountLPT;\r\n        totalLiquidity -= amountLPT;\r\n\r\n        require(token.transfer(msg.sender, tokenAmount), \"DEX: Token withdrawal failed\");\r\n        (bool sent, ) = msg.sender.call{ value: ethAmount }(\"\");\r\n        require(sent, \"DEX: ETH withdrawal failed\");\r\n\r\n        emit LiquidityRemoved(msg.sender, amountLPT, tokenAmount, ethAmount);\r\n        return (ethAmount, tokenAmount);\r\n    }\r\n\r\n    /* ========== ADMIN FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Allows the owner to block or unblock trading functions.\r\n     */\r\n    function setTradingBlock(bool _isBlocked) public onlyOwner {\r\n        isTradingBlocked = _isBlocked;\r\n        emit TradingBlockStatusChanged(msg.sender, _isBlocked);\r\n    }\r\n\r\n    /**\r\n     * @notice [DANGEROUS] Settles the contract and withdraws all remaining funds to the owner.\r\n     * @dev This is a final, irreversible action intended for contract end-of-life or emergency situations.\r\n     *      It permanently stops trading and drains all assets from the contract.\r\n     *      MUST be controlled by a Multi-Sig wallet with a Timelock.\r\n     */\r\n    function settleAndClear() external onlyOwner nonReentrant {\r\n        // 1. 結算前，必須先停止交易\r\n        require(isTradingBlocked, \"DEX: Trading is not blocked\");\r\n\r\n        // 2. 獲取合約中所有剩餘的 ETH 和 Token 餘額\r\n        uint256 ethBalance = address(this).balance;\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n\r\n        // 3. 提領所有資產到 owner 地址\r\n        // 提領 Token\r\n        if (tokenBalance > 0) {\r\n            // 使用 require(token.transfer(...)) 而非 SafeERC20 在此處是可接受的，\r\n            // 因為如果失敗，整個交易都會回滾，但強烈建議使用 SafeERC20。\r\n            require(token.transfer(owner(), tokenBalance), \"DEX: Final token withdrawal failed\");\r\n        }\r\n\r\n        // 提領 ETH\r\n        if (ethBalance > 0) {\r\n            (bool sent, ) = owner().call{ value: ethBalance }(\"\");\r\n            require(sent, \"DEX: Final ETH withdrawal failed\");\r\n        }\r\n\r\n        // 4. 將流動性清零，使合約的流動性功能永久失效\r\n        totalLiquidity = 0;\r\n\r\n        // 5. 觸發事件，記錄操作\r\n        emit SettlementExecuted(owner(), ethBalance, tokenBalance);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2ERC20.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}