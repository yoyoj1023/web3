# 模組一：溫故知新 (The PLONK Legacy)

## 課程目標
精準複習對理解 Plonky2 至關重要的 PLONK 核心概念。

## 心智模型
在升級汽車引擎前，先再次確認我們對底盤、變速箱和方向盤的工作原理瞭若指掌。

---

## 1. 關鍵前景提要

### 1.1 PLONK 算術化

在 PLONK 中，任何計算問題都被轉化為一個 **算術電路**，而這個電路的核心是「通用約束門」：

```
q_L * w_a + q_M * w_a * w_b + q_R * w_b + q_O * w_c + q_C = 0
```

其中：
- `w_a`, `w_b`, `w_c` 是見證值（witness）
- `q_L`, `q_M`, `q_R`, `q_O`, `q_C` 是選擇器（selectors）

**關鍵理解：** 這個通用約束門是所有計算的基礎，通過調整選擇器的值，我們可以實現：
- 加法門：`q_L = 1, q_R = 1, q_O = -1, q_M = 0, q_C = 0` → `w_a + w_b - w_c = 0`
- 乘法門：`q_M = 1, q_O = -1, 其餘 = 0` → `w_a * w_b - w_c = 0`
- 常數門：`q_L = 1, q_C = -c, 其餘 = 0` → `w_a - c = 0`

### 1.2 置換參數 (Permutation Argument)

**目的：** 作為「黏合劑」，保證電路中不同門之間的線路連接正確無誤。

**問題：** 在電路中，一個值可能在多個地方被使用。例如，計算 `x^3` 需要：
1. 第一個門：`x * x = x²`
2. 第二個門：`x² * x = x³`

這裡的 `x` 在兩個門中都被使用，我們需要保證它們確實是同一個值。

**解決方案：** 
- 為每個位置分配一個「標籤」
- 如果兩個位置應該有相同的值，它們被分配到同一個「置換群組」
- 使用多項式技術驗證置換關係的正確性

**置換多項式：** `σ(X)` 編碼了哪些位置應該有相同的值

### 1.3 商多項式 t(X)

**Prover 的核心任務：** 將所有電路約束打包成一個大表達式，然後證明它可以被零化多項式 `Z_H(X)` 整除。

**詳細流程：**

1. **門約束：** 對於每個門 `i`，我們有約束 `gate_i(w_a, w_b, w_c) = 0`

2. **置換約束：** 驗證 copy constraint 的正確性

3. **總約束：** `F(X) = gate_constraint(X) + α * permutation_constraint(X)`

4. **商多項式：** `t(X) = F(X) / Z_H(X)`

**關鍵點：** 如果 `F(X)` 在定義域 `H` 上的所有點都為零，那麼 `Z_H(X) = ∏_{ω∈H}(X - ω)` 整除 `F(X)`

### 1.4 多項式承諾方案 (PCS) 的角色

**可插拔的模組：** 將 PCS 視為一個可以替換的組件

**在標準 PLONK 中：** 通常使用 KZG 承諾方案

**PCS 的職責：**
1. **承諾階段：** 為多項式 `P(X)` 生成簡短的承諾 `commit(P)`
2. **開啟階段：** 證明 `P(a) = v` 而不透露整個多項式

**PLONK 中需要承諾的多項式：**
- 見證多項式：`w_a(X)`, `w_b(X)`, `w_c(X)`
- 置換多項式：`Z(X)`
- 商多項式：`t(X)`

---

## 2. PLONK 協議流程回顧

### 預處理階段（一次性設置）
1. 確定電路結構和選擇器多項式
2. 計算置換多項式 `σ(X)`
3. 生成零化多項式 `Z_H(X)`

### 證明生成
1. **Round 1：** Prover 承諾見證多項式
2. **Round 2：** Prover 承諾置換檢查多項式 `Z(X)`
3. **Round 3：** Prover 計算並承諾商多項式 `t(X)`
4. **Round 4：** Verifier 挑戰點，Prover 提供開啟證明

### 驗證
Verifier 檢查所有的多項式評估和承諾是否一致

---

## 3. 練習題

### 練習 1：算術化
設計一個電路來計算 `f(x) = x² + 3x + 2`，並寫出對應的門約束。

**解答：**
```
門 1: x * x = x²     (q_M=1, q_O=-1, 其餘=0)
門 2: 3 * x = 3x     (q_M=1, q_C=-3, w_a=3, w_b=x, 其餘=0)  
門 3: x² + 3x = temp (q_L=1, q_R=1, q_O=-1, 其餘=0)
門 4: temp + 2 = f   (q_L=1, q_C=2, q_O=-1, 其餘=0)
```

### 練習 2：置換理解
解釋為什麼在上面的電路中，我們需要置換約束來保證第一個門的輸出 `x²` 和第三個門的第一個輸入是同一個值。

### 練習 3：商多項式
如果我們有一個在 `{1, 2, 3}` 上的約束 `f(x) = x - 2`，計算零化多項式和商多項式。

---

## 4. 關鍵要點總結

1. **算術化是基礎：** 任何計算都必須先表示為算術電路
2. **置換是黏合劑：** 保證電路中值的正確傳遞
3. **商多項式是核心：** 將所有約束統一為一個可驗證的整除關係
4. **PCS 是工具：** 可插拔的多項式承諾方案

**下一步：** 在模組二中，我們將看到 Plonky2 如何用 FRI 替代 KZG，以及這個替換帶來的好處。

---

## 5. 延伸閱讀

- [PLONK 原始論文](https://eprint.iacr.org/2019/953)
- [算術化的深度解析](https://zkproof.org/2020/08/12/information-theoretic-proof-systems/)
- [置換參數的數學原理](https://hackmd.io/@yuhan/plonky2_permutation_argument)