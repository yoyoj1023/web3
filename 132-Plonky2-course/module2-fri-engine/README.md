# 模組二：透明性的革命 (The FRI Engine Swap)

## 課程目標
理解 Plonky2 為何以及如何用 FRI 替代 KZG。

## 心智模型
我們決定將汽車的引擎從需要特殊燃料（可信設置）的 V8 (KZG) 換成使用普通汽油（無需信任）但同樣強勁的渦輪增壓引擎 (FRI)。

---

## 1. 為什麼要換掉 KZG？

### 1.1 可信設置 (Trusted Setup) 的痛點

**什麼是可信設置？**
KZG 承諾方案需要一個「可信設置」儀式，生成公共參數：
```
{g^1, g^τ, g^τ², ..., g^τ^n}
```
其中 `τ` 是一個秘密值，必須在設置後被銷毀。

**問題一：複雜性**
- 需要多方參與的複雜儀式
- 參與者必須正確執行協議
- 需要安全的環境來防止秘密洩露

**問題二：安全性風險（毒物垃圾）**
- 如果任何一個參與者保留了秘密 `τ`，他們就能創造虛假證明
- 這被稱為「毒物垃圾」(toxic waste) 問題
- 一旦秘密被洩露，整個系統的安全性就崩潰了

**問題三：僵化問題**
- 不同大小的電路需要不同的設置
- 如果你有 1000 個門的電路，但設置只支援到 500 個門，你就需要重新設置
- 升級系統變得困難

**真實案例：**
- Zcash 的 Sprout → Sapling 升級就需要新的可信設置
- 以太坊的 KZG 設置（為了 EIP-4844）需要數千人參與

### 1.2 透明性的價值

**透明 = 無需可信設置**
- 任何人都可以驗證證明的正確性
- 不依賴於任何秘密參數
- 系統的安全性僅依賴於密碼學假設（如哈希函數的安全性）

---

## 2. FRI vs. KZG 優劣勢對比

### 2.1 KZG 承諾方案

**優點：**
- ✅ **證明小：** 固定 48 字節（一個 G1 群元素）
- ✅ **驗證快：** 只需要幾個配對運算
- ✅ **成熟技術：** 被廣泛研究和使用

**缺點：**
- ❌ **需要可信設置：** 如上所述的所有問題
- ❌ **驗證操作昂貴：** 配對運算在電路中實現成本很高
- ❌ **不易遞迴：** 在 SNARK 電路中驗證 KZG 證明需要大量資源

### 2.2 FRI 承諾方案

**優點：**
- ✅ **透明：** 無需任何可信設置
- ✅ **基於哈希：** 安全性僅依賴於哈希函數
- ✅ **遞迴友好：** 哈希函數在電路中實現相對簡單
- ✅ **後量子安全：** 不依賴於橢圓曲線離散對數問題

**缺點：**
- ❌ **證明尺寸較大：** 通常是 KZG 的 10-100 倍
- ❌ **驗證較慢：** 需要計算多個哈希值

### 2.3 權衡的結論

**Plonky2 的選擇：**
為了**透明性**和**遞迴友好性**，Plonky2 選擇了 FRI。

**為什麼這個選擇是明智的？**
1. **遞迴應用：** 在 rollup 等應用中，遞迴能力比證明大小更重要
2. **長期考慮：** 透明性提供了更強的安全保證
3. **技術趨勢：** 哈希友好的設計為未來優化留下了空間

---

## 3. FRI 的高層思想

### 3.1 核心直覺

**問題：** 如何向別人證明一個巨大的多項式其實「度」很低？

**例子：** 假設你聲稱有一個度數不超過 1000 的多項式 `P(X)`，但這個多項式在某個大域上有百萬個係數。怎麼高效地證明它的度數確實不超過 1000？

**天真的方法：** 發送所有係數 → 太大了！

**FRI 的巧思：** 通過「折疊」操作，逐步將度數減半，直到變成常數。

### 3.2 Commit-and-Fold 流程

讓我們通過一個簡化的例子來理解：

**步驟 1：承諾**
```
Prover: "我有一個度數 ≤ 4 的多項式 P(X)"
Action: Prover 對 P(X) 在某個域上的評估進行承諾（使用 Merkle tree）
```

**步驟 2：挑戰**
```
Verifier: "好的，給我一個隨機數 α"
```

**步驟 3：折疊**
```
Prover 將 P(X) 分解為：
P(X) = P_even(X²) + X · P_odd(X²)

然後計算：
P'(X) = P_even(X) + α · P_odd(X)

注意：P'(X) 的度數是 P(X) 的一半！
```

**步驟 4：遞迴**
```
重複上述過程，直到多項式變成常數
```

**步驟 5：最終檢查**
```
Verifier 檢查最終的常數是否合理
```

### 3.3 為什麼這樣有效？

**關鍵洞察：**
1. **度數保持：** 如果 `P(X)` 度數為 `d`，那麼 `P'(X)` 度數為 `d/2`
2. **隨機性：** 如果 `P(X)` 的度數超過聲稱的值，那麼 `P'(X)` 也會以高概率保持「壞」的性質
3. **指數收斂：** 經過 `log(d)` 輪後，我們得到一個常數

---

## 4. FRI 的數學原理

### 4.1 多項式的奇偶分解

任何多項式都可以寫成：
```
P(X) = P_even(X²) + X · P_odd(X²)
```

其中：
- `P_even` 包含所有偶次項係數
- `P_odd` 包含所有奇次項係數

**例子：**
```
P(X) = 3X⁴ + 2X³ + X² + 5X + 1
     = (3X⁴ + X² + 1) + X(2X² + 5)
     = P_even(X²) + X · P_odd(X²)

其中：
P_even(Y) = 3Y² + Y + 1
P_odd(Y) = 2Y + 5
```

### 4.2 折疊操作

給定隨機挑戰 `α`，定義：
```
P'(X) = P_even(X) + α · P_odd(X)
```

**關鍵性質：**
- 如果 `deg(P) ≤ d`，那麼 `deg(P') ≤ d/2`
- `P'(α) = P_even(α) + α · P_odd(α)`
- 通過 `P(α)` 和 `P(-α)` 可以恢復 `P_even(α²)` 和 `P_odd(α²)`

### 4.3 健全性分析

**定理：** 如果 `P(X)` 的度數超過 `d`，那麼經過折疊後，`P'(X)` 也會以高概率超過其聲稱的度數。

**直覺：** 惡意的 Prover 無法通過折疊來「修復」高度數的多項式。

---

## 5. FRI 在 Plonky2 中的應用

### 5.1 替換 KZG 的位置

在 PLONK 協議中，所有需要 KZG 承諾的地方都被 FRI 替代：

```
標準 PLONK:
1. 承諾見證多項式 w_a, w_b, w_c (使用 KZG)
2. 承諾置換多項式 Z (使用 KZG)  
3. 承諾商多項式 t (使用 KZG)
4. 開啟評估 (使用 KZG)

Plonky2:
1. 承諾見證多項式 w_a, w_b, w_c (使用 FRI)
2. 承諾置換多項式 Z (使用 FRI)
3. 承諾商多項式 t (使用 FRI)
4. 開啟評估 (使用 FRI)
```

### 5.2 批量開啟 (Batch Opening)

FRI 的一個優勢是支援高效的批量開啟：
- 可以同時證明多個多項式在多個點的評估
- 比多個獨立的 KZG 開啟更高效

---

## 6. 實際考慮

### 6.1 參數選擇

**安全參數：**
- 折疊輪數：通常 log₂(domain_size)
- 查詢次數：影響健全性，通常 20-100 次
- 哈希函數：Plonky2 使用 Poseidon

**性能權衡：**
- 更多查詢 → 更高安全性，但更大證明
- 更少折疊輪數 → 更快驗證，但需要更多查詢

### 6.2 與 STARK 的關係

FRI 最初是為 STARK 設計的，Plonky2 將其適配到 PLONK：
- STARK 天然使用 FRI
- Plonky2 是 PLONK + FRI 的結合
- 這種結合為遞迴證明打下了基礎

---

## 7. 練習題

### 練習 1：奇偶分解
將多項式 `P(X) = X⁴ + 3X³ + 2X² + X + 5` 分解為奇偶兩部分。

### 練習 2：折疊操作
給定上面的 `P(X)` 和挑戰 `α = 2`，計算折疊後的多項式 `P'(X)`。

### 練習 3：安全性分析
解釋為什麼一個惡意的 Prover 無法通過選擇特殊的 `P_even` 和 `P_odd` 來欺騙 FRI 協議。

### 練習 4：效率比較
比較 FRI 和 KZG 在以下場景中的優劣：
a) 單個證明的生成和驗證
b) 在 SNARK 電路中驗證證明（遞迴）
c) 批量證明多個聲明

---

## 8. 關鍵要點總結

1. **透明性價值：** FRI 消除了對可信設置的需求
2. **度數測試：** FRI 的核心是一個度數測試協議
3. **折疊技術：** 通過奇偶分解和隨機折疊來減少問題規模
4. **遞迴友好：** 基於哈希的設計使其在電路中更容易實現
5. **權衡清晰：** 以證明大小換取透明性和遞迴能力

**下一步：** 在模組三中，我們將探討 Plonky2 的另一個關鍵創新——黃金域，以及它如何提供極致的性能。

---

## 9. 延伸閱讀

- [FRI 原始論文](https://drops.dagstuhl.de/opus/volltexte/2018/9018/)
- [STARK 和 FRI 的關係](https://starkware.co/stark/)
- [Plonky2 中的 FRI 實現](https://github.com/0xPolygonZero/plonky2)
- [透明性在區塊鏈中的重要性](https://a16zcrypto.com/building-for-the-cryptonetwork/)